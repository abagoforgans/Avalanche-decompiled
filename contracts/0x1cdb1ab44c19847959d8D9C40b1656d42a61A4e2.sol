contract main {




// =====================  Runtime code  =====================


#
#  - claim(address arg1, address arg2)
#
const BSC = 56

const REVISION = 21


uint8 stor0;
uint8 stor0; offset 8
uint256 stor0; offset 8
address owner;
address sub_23bf2705Address;
address sub_5d830fbeAddress;
array of struct stor362;
mapping of uint256 stor363;
mapping of struct sub_c9997aa9;
mapping of uint256 sub_fbde721d;
mapping of uint256 balances;
mapping of uint256 sub_b32b53ab;
mapping of uint256 sub_c4ccc25d;
mapping of uint256 sub_603f2f0c;
uint256 sub_a57f309a;
mapping of uint256 sub_3acf4148;
uint256 sub_bb5b5a6a;
uint256 sub_2730bcb7;
uint256 initialBlockNumber;
uint256 lastBlockNumber;
address sub_b10f04b0Address;
address sub_e56b22baAddress;
uint256 sub_df62497d;
mapping of uint32 sub_1e597e03;
uint256 sub_2fee582f;
uint256 sub_5c7cdf12;
uint256 sub_6cbe28ea;
uint256 sub_846374b8;
address sub_7dc65830Address;

function sub_04fe5081(?) payable {
    if initialBlockNumber > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    return (Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7)
}

function sub_07b50a36(?) payable {
    return sub_df62497d
}

function sub_1e597e03(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return address(sub_1e597e03[address(arg1)][arg2])
}

function sub_23bf2705(?) payable {
    return sub_23bf2705Address
}

function lastBlockNumber() payable {
    return lastBlockNumber
}

function sub_2730bcb7(?) payable {
    return sub_2730bcb7
}

function balances(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balances[arg1]
}

function sub_2fee582f(?) payable {
    return sub_2fee582f
}

function sub_3acf4148(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_3acf4148[arg1]
}

function sub_499dff19(?) payable {
    return sub_b10f04b0Address
}

function sub_5c7cdf12(?) payable {
    return sub_5c7cdf12
}

function sub_5d830fbe(?) payable {
    return sub_5d830fbeAddress
}

function sub_603f2f0c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_603f2f0c[arg1]
}

function sub_6cbe28ea(?) payable {
    return sub_6cbe28ea
}

function sub_7895538f(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return address(sub_1e597e03[arg1][arg2])
}

function sub_7dc65830(?) payable {
    return sub_7dc65830Address
}

function sub_846374b8(?) payable {
    return sub_846374b8
}

function owner() payable {
    return owner
}

function sub_a57f309a(?) payable {
    return sub_a57f309a
}

function sub_b10f04b0(?) payable {
    return sub_b10f04b0Address
}

function sub_b32b53ab(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_b32b53ab[arg1]
}

function initialBlockNumber() payable {
    return initialBlockNumber
}

function sub_bb5b5a6a(?) payable {
    return sub_bb5b5a6a
}

function sub_c4ccc25d(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return sub_c4ccc25d[arg1][arg2]
}

function sub_c9997aa9(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return uint256(sub_c9997aa9[arg1][arg2].field_0)
}

function sub_df62497d(?) payable {
    return sub_df62497d
}

function sub_e56b22ba(?) payable {
    return sub_e56b22baAddress
}

function sub_fbde721d(?) payable {
    require calldata.size - 4 >= 32
    return sub_fbde721d[arg1]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_37b09dbe(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    sub_b10f04b0Address = address(arg1)
}

function sub_76b9a19a(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    sub_7dc65830Address = address(arg1)
}

function sub_ade8d43c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    sub_e56b22baAddress = address(arg1)
}

function sub_a6e549f8(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == address(arg3)
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    address(sub_1e597e03[address(arg1)][arg2]) = address(arg3)
}

function sub_217e41d7(?) payable {
    require calldata.size - 4 >= 32
    if arg1 > 10000:
        revert with 0, 
                    32,
                    48,
                    0x7346656520646973747269627574696f6e207265776172642073686f756c64206265206c657373207468616e20313030, mem[176 len 16] >> 128,
                    0
    sub_df62497d = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x724f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_607b625a(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if balances[address(arg1)] > ext_call.return_data[0]:
        revert with 0, 'SafeMath: subtraction overflow'
    return (ext_call.return_data[0] - balances[address(arg1)])
}

function sub_96570023(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        if 10^9 * arg2 / 10^9 != arg2:
            revert with 0, ''
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^9 * arg2 / ext_call.return_data[0]) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
            revert with 0, 'SafeMath: addition overflow'
        sub_b32b53ab[address(arg1)] += 10^9 * arg2 / ext_call.return_data[0]
}

function getFunds(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[128] = 0x474f5645524e414e43455f524557415244000000000000000000000000000000
    mem[160] = 0x444556454c4f504d454e54000000000000000000000000000000000000000000
    mem[192] = 'INSURANCE' << 184
    mem[224] = 'CHARITY' << 200
    mem[256] = 0x4255595f414e445f4255524e0000000000000000000000000000000000000000
    mem[288] = 5
    mem[320 len 160] = call.data[calldata.size len 160]
    idx = 0
    while idx < 5:
        require idx < 5
        mem[0] = mem[(32 * idx) + 128]
        mem[32] = sha3(address(arg1), 364)
        require idx < 5
        mem[(32 * idx) + 320] = uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + 128]].field_0)
        idx = idx + 1
        continue 
    return 64, 
           256,
           5,
           0x474f5645524e414e43455f524557415244000000000000000000000000000000, 0x444556454c4f504d454e54000000000000000000000000000000000000000000, 'INSURANCE', 'CHARITY', 0x4255595f414e445f4255524e0000000000000000000000000000000000000000 >> 1024,
           5,
           mem[320 len 160]
}

function sub_465b78b7(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if uint256(sub_c9997aa9[address(arg1)][arg2].field_0):
        if address(sub_1e597e03[address(arg1)][arg2]):
            if uint256(sub_c9997aa9[address(arg1)][arg2].field_0) > balances[address(arg1)]:
                revert with 0, 'Balance of token is not expected'
            uint256(sub_c9997aa9[address(arg1)][arg2].field_0) = 0
            if uint256(sub_c9997aa9[address(arg1)][arg2].field_0) > balances[address(arg1)]:
                revert with 0, 'SafeMath: subtraction overflow'
            balances[address(arg1)] -= uint256(sub_c9997aa9[address(arg1)][arg2].field_0)
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(address(arg1)):
                revert with 0, 'SafeERC20: call to non-contract'
            mem[324 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, sub_1e597e03[address(arg1)][arg2]), uint32(sub_1e597e03[address(arg1)][arg2]), Mask(224, 0, sub_c9997aa9[address(arg1)][arg2].field_32)
            call address(arg1) with:
               funct uint32(sub_1e597e03[address(arg1)][arg2])
                 gas gas_remaining wei
                args Mask(480, 0, sub_c9997aa9[address(arg1)][arg2].field_0), mem[388 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if not 'Balance of token is not expected':
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[434 len 22]
            else:
                mem[356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[356]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 435 len 22]
}

function sub_fb4de68f(?) payable {
    require calldata.size - 4 >= 128
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    sub_2fee582f = arg1
    sub_5c7cdf12 = arg2
    sub_6cbe28ea = arg3
    sub_846374b8 = arg4
    require ext_code.size(sub_e56b22baAddress)
    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
            gas gas_remaining wei
           args 0x574f570000000000000000000000000000000000000000000000000000000000
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    if sub_2fee582f != 56:
        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            if sub_bb5b5a6a:
                sub_bb5b5a6a = 0
        else:
            if not ext_call.return_data[0]:
                require sub_846374b8
                if sub_bb5b5a6a != 0 / sub_846374b8:
                    sub_bb5b5a6a = 0 / sub_846374b8
            else:
                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 197 len 31]
                if not sub_6cbe28ea * ext_call.return_data[0]:
                    require sub_846374b8
                    if sub_bb5b5a6a != 0 / sub_846374b8:
                        sub_bb5b5a6a = 0 / sub_846374b8
                else:
                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 197 len 31]
                    require sub_846374b8
                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
    else:
        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                gas gas_remaining wei
               args sub_7dc65830Address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] > sub_846374b8:
            if sub_bb5b5a6a:
                sub_bb5b5a6a = 0
        else:
            if sub_846374b8 - ext_call.return_data[0] <= 0:
                if sub_bb5b5a6a:
                    sub_bb5b5a6a = 0
            else:
                if not sub_846374b8 - ext_call.return_data[0]:
                    require sub_846374b8
                    if sub_bb5b5a6a != 0 / sub_846374b8:
                        sub_bb5b5a6a = 0 / sub_846374b8
                else:
                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 261 len 31]
                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                        require sub_846374b8
                        if sub_bb5b5a6a != 0 / sub_846374b8:
                            sub_bb5b5a6a = 0 / sub_846374b8
                    else:
                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(2 * ceil32(return_data.size)) + 261 len 31]
                        require sub_846374b8
                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
}

function initialize(address arg1, address arg2, address arg3, address arg4, uint256 arg5, uint256 arg6) payable {
    require calldata.size - 4 >= 192
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(0, msg.sender);
        sub_b10f04b0Address = arg3
        sub_23bf2705Address = arg2
        sub_5d830fbeAddress = arg1
        sub_e56b22baAddress = arg4
        initialBlockNumber = block.number
        lastBlockNumber = block.number
        sub_bb5b5a6a = arg5
        sub_2730bcb7 = arg6
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_0):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                            mem[210 len 18]
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(0, msg.sender);
            sub_b10f04b0Address = arg3
            sub_23bf2705Address = arg2
            sub_5d830fbeAddress = arg1
            sub_e56b22baAddress = arg4
            initialBlockNumber = block.number
            lastBlockNumber = block.number
            sub_bb5b5a6a = arg5
            sub_2730bcb7 = arg6
        else:
            uint8(stor0.field_0) = 1
            uint8(stor0.field_8) = 1
            Mask(248, 0, stor0.field_8) = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_0):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                46,
                                0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                mem[210 len 18]
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(0, msg.sender);
                sub_b10f04b0Address = arg3
                sub_23bf2705Address = arg2
                sub_5d830fbeAddress = arg1
                sub_e56b22baAddress = arg4
                initialBlockNumber = block.number
                lastBlockNumber = block.number
                sub_bb5b5a6a = arg5
                sub_2730bcb7 = arg6
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_0):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    46,
                                    0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                    mem[210 len 18]
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    sub_b10f04b0Address = arg3
                    sub_23bf2705Address = arg2
                    sub_5d830fbeAddress = arg1
                    sub_e56b22baAddress = arg4
                    initialBlockNumber = block.number
                    lastBlockNumber = block.number
                    sub_bb5b5a6a = arg5
                    sub_2730bcb7 = arg6
                else:
                    uint8(stor0.field_0) = 1
                    uint8(stor0.field_8) = 1
                    Mask(248, 0, stor0.field_8) = 0
                    uint8(stor0.field_8) = 0
                    if ext_code.size(this.address):
                        if uint8(stor0.field_0):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        46,
                                        0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                        mem[210 len 18]
                    if uint8(stor0.field_8):
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                        sub_b10f04b0Address = arg3
                        sub_23bf2705Address = arg2
                        sub_5d830fbeAddress = arg1
                        sub_e56b22baAddress = arg4
                        initialBlockNumber = block.number
                        lastBlockNumber = block.number
                        sub_bb5b5a6a = arg5
                        sub_2730bcb7 = arg6
                    else:
                        uint8(stor0.field_0) = 1
                        uint8(stor0.field_8) = 1
                        Mask(248, 0, stor0.field_8) = 0
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                        uint8(stor0.field_8) = 0
                        uint8(stor0.field_8) = 0
                        sub_b10f04b0Address = arg3
                        sub_23bf2705Address = arg2
                        sub_5d830fbeAddress = arg1
                        sub_e56b22baAddress = arg4
                        initialBlockNumber = block.number
                        lastBlockNumber = block.number
                        sub_bb5b5a6a = arg5
                        sub_2730bcb7 = arg6
                        uint8(stor0.field_8) = 0
}

function sub_152bfa84(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[96] = 5
    mem[64] = 288
    mem[128] = 0x474f5645524e414e43455f524557415244000000000000000000000000000000
    mem[160] = 0x444556454c4f504d454e54000000000000000000000000000000000000000000
    mem[192] = 'INSURANCE' << 184
    mem[224] = 'CHARITY' << 200
    mem[256] = 0x4255595f414e445f4255524e0000000000000000000000000000000000000000
    idx = 0
    while idx < 5:
        require idx < mem[96]
        if mem[(32 * idx) + 128] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
            require idx < mem[96]
            _71 = mem[(32 * idx) + 128]
            _73 = sha3(mem[(32 * idx) + 128], sha3(address(arg1), 364))
            mem[0] = mem[(32 * idx) + 128]
            mem[32] = sha3(address(arg1), 379)
            _75 = sha3(mem[(32 * idx) + 128], sha3(address(arg1), 379))
            if uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + 128]].field_0):
                if address(sub_1e597e03[address(arg1)][mem[(32 * idx) + 128]]):
                    mem[0] = address(arg1)
                    mem[32] = 366
                    _77 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_77] = 32
                    mem[_77 + 32] = 'Balance of token is not expected'
                    if uint256(stor[_73]) > balances[address(arg1)]:
                        _81 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _81 + 68] = mem[idx + _77 + 32]
                            idx = idx + 32
                            continue 
                        revert with memory
                          from mem[64]
                           len _81 + -mem[64] + 100
                    uint256(sub_c9997aa9[address(arg1)][_71].field_0) = 0
                    mem[0] = address(arg1)
                    mem[32] = 366
                    _82 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_82] = 30
                    mem[_82 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(stor[_73]) > balances[address(arg1)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                        idx = 32
                        while idx < 30:
                            mem[idx + mem[64] + 68] = mem[idx + _82 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[0] = address(arg1)
                    mem[32] = 366
                    balances[address(arg1)] -= uint256(stor[_73])
                    _93 = mem[64]
                    mem[mem[64] + 36] = address(stor[_75])
                    mem[mem[64] + 68] = uint256(stor[_73])
                    _94 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_94 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_94 + 36 len 28]
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                        revert with 0, 'SafeERC20: call to non-contract'
                    if not ext_code.hash(address(arg1)):
                        revert with 0, 'SafeERC20: call to non-contract'
                    _105 = mem[_94]
                    t = _94 + 32
                    u = _93 + 100
                    s = mem[_94]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[_93 + floor32(mem[_94]) + 100] = mem[_94 + -(mem[_94] % 32) + floor32(mem[_94]) + 64 len mem[_94] % 32] or Mask(8 * -(mem[_94] % 32) + 32, -(8 * -(mem[_94] % 32) + 32) + 256, mem[_93 + floor32(mem[_94]) + 100])
                    call address(arg1).mem[_93 + 100 len 4] with:
                         gas gas_remaining wei
                        args mem[_93 + 104 len _105 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_93 + 210 len 22]
                    else:
                        mem[64] = _93 + ceil32(return_data.size) + 101
                        mem[_93 + 100] = return_data.size
                        mem[_93 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_93 + 132]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_93 + ceil32(return_data.size) + 211 len 22]
        idx = idx + 1
        continue 
}

function sub_99d01294(?) payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < stor362.length:
        mem[0] = 362
        _69 = mem[64]
        mem[mem[64]] = 5
        mem[64] = mem[64] + 192
        require 0 < mem[_69]
        mem[_69 + 32] = 0x474f5645524e414e43455f524557415244000000000000000000000000000000
        require 1 < mem[_69]
        mem[_69 + 64] = 0x444556454c4f504d454e54000000000000000000000000000000000000000000
        require 2 < mem[_69]
        mem[_69 + 96] = 'INSURANCE' << 184
        require 3 < mem[_69]
        mem[_69 + 128] = 'CHARITY' << 200
        require 4 < mem[_69]
        mem[_69 + 160] = 0x4255595f414e445f4255524e0000000000000000000000000000000000000000
        _135 = mem[_69]
        s = 0
        while s < _135:
            require s < mem[_69]
            if mem[(32 * s) + _69 + 32] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                require s < mem[_69]
                _139 = mem[(32 * s) + _69 + 32]
                _141 = sha3(mem[(32 * s) + _69 + 32], sha3(address(stor362[idx].field_0), 364))
                mem[0] = mem[(32 * s) + _69 + 32]
                mem[32] = sha3(address(stor362[idx].field_0), 379)
                if uint256(stor[_141]):
                    if address(sub_1e597e03[address(stor362[idx].field_0)][_139]):
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        _145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_145] = 32
                        mem[_145 + 32] = 'Balance of token is not expected'
                        if uint256(stor[_141]) > balances[address(stor362[idx].field_0)]:
                            _149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _149 + 68] = mem[idx + _145 + 32]
                                idx = idx + 32
                                continue 
                            revert with memory
                              from mem[64]
                               len _149 + -mem[64] + 100
                        uint256(sub_c9997aa9[address(stor362[idx].field_0)][_139].field_0) = 0
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        _150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_150] = 30
                        mem[_150 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(stor[_141]) > balances[address(stor362[idx].field_0)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _150 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        balances[address(stor362[idx].field_0)] -= uint256(stor[_141])
                        _161 = mem[64]
                        mem[mem[64] + 36] = address(sub_1e597e03[address(stor362[idx].field_0)][_139])
                        mem[mem[64] + 68] = uint256(stor[_141])
                        _162 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_162 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_162 + 36 len 28]
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(stor362[idx].field_0)):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(address(stor362[idx].field_0)):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _173 = mem[_162]
                        u = _162 + 32
                        v = _161 + 100
                        t = mem[_162]
                        while t >= 32:
                            mem[v] = mem[u]
                            u = u + 32
                            v = v + 32
                            t = t - 32
                            continue 
                        mem[_161 + floor32(mem[_162]) + 100] = mem[_162 + -(mem[_162] % 32) + floor32(mem[_162]) + 64 len mem[_162] % 32] or Mask(8 * -(mem[_162] % 32) + 32, -(8 * -(mem[_162] % 32) + 32) + 256, mem[_161 + floor32(mem[_162]) + 100])
                        call address(stor362[idx].field_0).mem[_161 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_161 + 104 len _173 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_161 + 210 len 22]
                        else:
                            mem[64] = _161 + ceil32(return_data.size) + 101
                            mem[_161 + 100] = return_data.size
                            mem[_161 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_161 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_161 + ceil32(return_data.size) + 211 len 22]
            s = s + 1
            continue 
        idx = idx + 1
        s = uint256(stor362[idx].field_0)
        continue 
}

function register(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if sub_23bf2705Address != msg.sender:
        revert with 0, 
                    32,
                    45,
                    0x7354686973206f7065726174696f6e206973206f6e6c7920616c6c6f77656420746f2078574f57206d696e7465, mem[173 len 19] >> 104,
                    0
    idx = 0
    s = 0
    while idx < stor362.length:
        mem[0] = arg1
        mem[32] = sha3(address(stor362[idx].field_0), 368)
        sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] = sub_b32b53ab[address(stor362[idx].field_0)]
        idx = idx + 1
        s = uint256(stor362[idx].field_0)
        continue 
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > ext_call.return_data[0]:
        revert with 0, 'SafeMath: subtraction overflow'
    if initialBlockNumber > lastBlockNumber:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if initialBlockNumber > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        if lastBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - lastBlockNumber:
            if sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            sub_3acf4148[address(arg1)] = sub_a57f309a
        else:
            if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 677 len 31]
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            sub_a57f309a = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
            sub_3acf4148[address(arg1)] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
    else:
        if not block.number - initialBlockNumber / sub_2730bcb7:
            if initialBlockNumber < 0:
                revert with 0, 'SafeMath: addition overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber - 1:
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_3acf4148[address(arg1)] = sub_a57f309a
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 805 len 31]
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
            else:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 741 len 31]
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 805 len 31]
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
        else:
            if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 613 len 31]
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 'SafeMath: addition overflow'
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
                if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_3acf4148[address(arg1)] = sub_a57f309a
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 805 len 31]
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
            else:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 741 len 31]
                if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 805 len 31]
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                    sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
    lastBlockNumber = block.number
}

function calcClaimAmount(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if sub_c4ccc25d[address(arg2)][address(arg1)] > sub_b32b53ab[address(arg2)]:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_b32b53ab[address(arg2)] - sub_c4ccc25d[address(arg2)][address(arg1)]:
        require ext_code.size(sub_23bf2705Address)
        staticcall sub_23bf2705Address.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if initialBlockNumber > lastBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        if initialBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            if lastBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - lastBlockNumber:
                if not ext_call.return_data[0]:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return 0
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 773 len 31]
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return 0, 
                           (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 837 len 31]
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 645 len 31]
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 773 len 31]
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return 0
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 837 len 31]
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return 0, 
                   ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not block.number - initialBlockNumber / sub_2730bcb7:
            if initialBlockNumber < 0:
                revert with 0, 'SafeMath: addition overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber - 1:
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    if not ext_call.return_data[0]:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            return 0
                        if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(2 * ceil32(return_data.size)) + 901 len 31]
                        if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        return 0, 
                               (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return 0
                    if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 965 len 31]
                    if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return 0, 
                           (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 773 len 31]
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not ext_call.return_data[0]:
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return 0
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 901 len 31]
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return 0, 
                           (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 965 len 31]
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 709 len 31]
            if lastBlockNumber > initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber - lastBlockNumber:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not ext_call.return_data[0]:
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return 0
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 901 len 31]
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return 0, 
                           (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 965 len 31]
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 773 len 31]
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return 0
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return 0, 
                   ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 581 len 31]
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 'SafeMath: addition overflow'
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
            if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                if not ext_call.return_data[0]:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return 0
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 901 len 31]
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return 0, 
                           (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 965 len 31]
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 773 len 31]
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return 0
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return 0, 
                   ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 709 len 31]
        if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return 0
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return 0, 
                       (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return 0
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return 0, 
                   ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 773 len 31]
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not ext_call.return_data[0]:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return 0
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 901 len 31]
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return 0, 
                   (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return 0
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 965 len 31]
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return 0, 
               ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(arg2)] - sub_c4ccc25d[address(arg2)][address(arg1)] != ext_call.return_data[0]:
        revert with 0, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[ceil32(return_data.size) + 261 len 31]
    if (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
        revert with 0, ''
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if initialBlockNumber > lastBlockNumber:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if initialBlockNumber > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        if lastBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - lastBlockNumber:
            if not ext_call.return_data[0]:
                if sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           0
                if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 773 len 31]
                if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 837 len 31]
            if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 645 len 31]
        if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not ext_call.return_data[0]:
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 773 len 31]
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   0
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 837 len 31]
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if not block.number - initialBlockNumber / sub_2730bcb7:
        if initialBlockNumber < 0:
            revert with 0, 'SafeMath: addition overflow'
        if initialBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - initialBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number + -initialBlockNumber - 1:
            if lastBlockNumber > initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber - lastBlockNumber:
                if not ext_call.return_data[0]:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                               0
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(2 * ceil32(return_data.size)) + 901 len 31]
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           0
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 965 len 31]
                if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 773 len 31]
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           0
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 709 len 31]
        if lastBlockNumber > initialBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber - lastBlockNumber:
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not ext_call.return_data[0]:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           0
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 773 len 31]
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not ext_call.return_data[0]:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 901 len 31]
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   0
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 965 len 31]
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
        revert with 0, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(2 * ceil32(return_data.size)) + 581 len 31]
    if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
        revert with 0, 'SafeMath: addition overflow'
    if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
        if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
            if not ext_call.return_data[0]:
                if sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                if sub_3acf4148[address(arg1)] > sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                           0
                if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(2 * ceil32(return_data.size)) + 901 len 31]
                if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (0 / ext_call.return_data[0]) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 965 len 31]
            if (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (0 / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 773 len 31]
        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not ext_call.return_data[0]:
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 901 len 31]
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   0
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 965 len 31]
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
        revert with 0, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(2 * ceil32(return_data.size)) + 709 len 31]
    if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
        revert with 0, 'SafeMath: subtraction overflow'
    if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not ext_call.return_data[0]:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                       0
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[(2 * ceil32(return_data.size)) + 901 len 31]
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   0
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 965 len 31]
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        revert with 0, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(2 * ceil32(return_data.size)) + 773 len 31]
    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
        revert with 0, 'SafeMath: addition overflow'
    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
        revert with 0, ''
    if not ext_call.return_data[0]:
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
                   0
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[(2 * ceil32(return_data.size)) + 901 len 31]
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a < sub_a57f309a:
        revert with 0, 'SafeMath: addition overflow'
    if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a:
        revert with 0, 'SafeMath: subtraction overflow'
    if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)]:
        return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
               0
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0]) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
        revert with 0, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[(2 * ceil32(return_data.size)) + 965 len 31]
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
        revert with 0, ''
    return (sub_b32b53ab[address(arg2)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(arg2)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9, 
           ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / ext_call.return_data[0] * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
}

function sub_49b87397(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    mem[96] = 28
    mem[128] = 'Unable to distribute WOW fee'
    if sub_5d830fbeAddress == address(arg1):
        revert with 0, 'Unable to distribute WOW fee', 0
    mem[164] = address(arg1)
    require ext_code.size(sub_b10f04b0Address)
    staticcall sub_b10f04b0Address.0x532cc278 with:
            gas gas_remaining wei
           args address(arg1)
    mem[160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[ceil32(return_data.size) + 160] = 43
    mem[ceil32(return_data.size) + 192 len 43] = 0x64556e61626c6520746f206469737472696275746520756e7265676973746572656420746f6b656e206665
    if not ext_call.return_data[0]:
        revert with 0, 
                    32,
                    43,
                    0x64556e61626c6520746f206469737472696275746520756e7265676973746572656420746f6b656e206665, mem[ceil32(return_data.size) + 235 len 21] >> 88,
                    0
    if stor363[address(arg1)]:
        mem[ceil32(return_data.size) + 260] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[0] = address(arg1)
        mem[32] = 366
        mem[(2 * ceil32(return_data.size)) + 256] = 30
        mem[(2 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
        if balances[address(arg1)] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ext_call.return_data[0] - balances[address(arg1)]:
            mem[(2 * ceil32(return_data.size)) + 320] = 30
            mem[(2 * ceil32(return_data.size)) + 352] = 'SafeMath: subtraction overflow'
            if 0 > ext_call.return_data[0] - balances[address(arg1)]:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[(2 * ceil32(return_data.size)) + 384] = 0x752f77f100000000000000000000000000000000000000000000000000000000
            require ext_code.size(sub_e56b22baAddress)
            staticcall sub_e56b22baAddress.getFeeDistribution() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 384
            require return_data.size >= 64
            _150 = mem[(2 * ceil32(return_data.size)) + 384]
            require mem[(2 * ceil32(return_data.size)) + 384] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
            _164 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384] <= test266151307()
            require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416 <= test266151307()
            mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416
            mem[(4 * ceil32(return_data.size)) + 384] = _164
            require _150 + (32 * _164) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 416 len 32 * _164] = mem[(2 * ceil32(return_data.size)) + _150 + 416 len 32 * _164]
            _2940 = mem[(2 * ceil32(return_data.size)) + 416]
            require mem[(2 * ceil32(return_data.size)) + 416] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
            _2996 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384] <= test266151307()
            _3004 = mem[64]
            require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 <= test266151307()
            mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32
            mem[_3004] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
            require return_data.size >= _2940 + (32 * _2996) + 32
            mem[_3004 + 32 len 32 * _2996] = mem[(2 * ceil32(return_data.size)) + _2940 + 416 len 32 * _2996]
            require _164 <= test266151307()
            _5760 = mem[64]
            mem[mem[64]] = _164
            mem[64] = mem[64] + (32 * _164) + 32
            if not _164:
                idx = 0
                s = ext_call.return_data[0] - balances[address(arg1)]
                while idx < _164:
                    require idx < mem[(4 * ceil32(return_data.size)) + 384]
                    require idx < mem[_3004]
                    if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                        _8560 = mem[(32 * idx) + _3004 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5760]
                            mem[(32 * idx) + _5760 + 32] = 0
                            require idx < mem[_5760]
                            _8895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8895] = 30
                            mem[_8895 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            s = 32
                            while s < 30:
                                mem[s + mem[64] + 68] = mem[s + _8895 + 32]
                                s = s + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3004 + 32]:
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = 0
                                require idx < mem[_5760]
                                _8993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8993] = 30
                                mem[_8993 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _8993 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8679] = 3
                                mem[_8679 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8560:
                                    _8704 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8704 + 68] = mem[idx + _8679 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8704 + 68] = mem[_8704 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8704 + -mem[64] + 100
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = (ext_call.return_data[0] * _8560) + (-1 * balances[address(arg1)] * _8560) + 5000 / 10000
                                require idx < mem[_5760]
                                _9089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9089] = 30
                                mem[_9089 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8560) + (-1 * balances[address(arg1)] * _8560) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8560) + (-1 * balances[address(arg1)] * _8560) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9089 + 32]
                                    idx = idx + 32
                                    continue 
                    else:
                        _8607 = mem[(32 * idx) + _3004 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5760]
                            mem[(32 * idx) + _5760 + 32] = 0
                            require idx < mem[_5760]
                            _8994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8994] = 30
                            mem[_8994 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _8994 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3004 + 32]:
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = 0
                                require idx < mem[_5760]
                                _9094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9094] = 30
                                mem[_9094 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9094 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8709] = 3
                                mem[_8709 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8607:
                                    _8802 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8802 + 68] = mem[idx + _8709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8802 + 68] = mem[_8802 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8802 + -mem[64] + 100
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = (ext_call.return_data[0] * _8607) + (-1 * balances[address(arg1)] * _8607) + 5000 / 10000
                                require idx < mem[_5760]
                                _9202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9202] = 30
                                mem[_9202 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8607) + (-1 * balances[address(arg1)] * _8607) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8607) + (-1 * balances[address(arg1)] * _8607) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9202 + 32]
                                    idx = idx + 32
                                    continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                require 0 < mem[_5760]
                if s + mem[_5760 + 32] < mem[_5760 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require 0 < mem[_5760]
                mem[_5760 + 32] = s + mem[_5760 + 32]
                require 0 < mem[_5760]
                _8642 = mem[_5760 + 32]
                require ext_code.size(sub_23bf2705Address)
                staticcall sub_23bf2705Address.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8702 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8894 = mem[_8702]
                if not mem[_8702]:
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5760]
                        if mem[(32 * idx) + _5760 + 32] > 0:
                            require idx < mem[_5760]
                            _11809 = mem[(32 * idx) + _5760 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5760 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11809
                        idx = idx + 1
                        continue 
                else:
                    _9194 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9194] = 3
                    mem[_9194 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if 10^9 * _8642 / 10^9 != _8642:
                        revert with 0, ''
                    _9640 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9640] = 26
                    mem[_9640 + 32] = 'SafeMath: division by zero'
                    if not _8894:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^9 * _8642 / _8894) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 367
                    sub_b32b53ab[address(arg1)] += 10^9 * _8642 / _8894
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5760]
                        if mem[(32 * idx) + _5760 + 32] > 0:
                            require idx < mem[_5760]
                            _11815 = mem[(32 * idx) + _5760 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5760 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11815
                        idx = idx + 1
                        continue 
            else:
                mem[_5760 + 32 len 32 * _164] = call.data[calldata.size len 32 * _164]
                idx = 0
                s = ext_call.return_data[0] - balances[address(arg1)]
                while idx < _164:
                    require idx < mem[(4 * ceil32(return_data.size)) + 384]
                    require idx < mem[_3004]
                    if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                        _8564 = mem[(32 * idx) + _3004 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5760]
                            mem[(32 * idx) + _5760 + 32] = 0
                            require idx < mem[_5760]
                            _8903 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8903] = 30
                            mem[_8903 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            s = 32
                            while s < 30:
                                mem[s + mem[64] + 68] = mem[s + _8903 + 32]
                                s = s + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3004 + 32]:
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = 0
                                require idx < mem[_5760]
                                _9001 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9001] = 30
                                mem[_9001 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9001 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8681] = 3
                                mem[_8681 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8564:
                                    _8712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8712 + 68] = mem[idx + _8681 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8712 + 68] = mem[_8712 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8712 + -mem[64] + 100
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = (ext_call.return_data[0] * _8564) + (-1 * balances[address(arg1)] * _8564) + 5000 / 10000
                                require idx < mem[_5760]
                                _9098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9098] = 30
                                mem[_9098 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8564) + (-1 * balances[address(arg1)] * _8564) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8564) + (-1 * balances[address(arg1)] * _8564) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9098 + 32]
                                    idx = idx + 32
                                    continue 
                    else:
                        _8609 = mem[(32 * idx) + _3004 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5760]
                            mem[(32 * idx) + _5760 + 32] = 0
                            require idx < mem[_5760]
                            _9002 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9002] = 30
                            mem[_9002 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _9002 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3004 + 32]:
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = 0
                                require idx < mem[_5760]
                                _9103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9103] = 30
                                mem[_9103 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9103 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8717 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8717] = 3
                                mem[_8717 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8609:
                                    _8810 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8810 + 68] = mem[idx + _8717 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8810 + 68] = mem[_8810 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8810 + -mem[64] + 100
                                require idx < mem[_5760]
                                mem[(32 * idx) + _5760 + 32] = (ext_call.return_data[0] * _8609) + (-1 * balances[address(arg1)] * _8609) + 5000 / 10000
                                require idx < mem[_5760]
                                _9212 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9212] = 30
                                mem[_9212 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8609) + (-1 * balances[address(arg1)] * _8609) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8609) + (-1 * balances[address(arg1)] * _8609) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9212 + 32]
                                    idx = idx + 32
                                    continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                require 0 < mem[_5760]
                if s + mem[_5760 + 32] < mem[_5760 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require 0 < mem[_5760]
                mem[_5760 + 32] = s + mem[_5760 + 32]
                require 0 < mem[_5760]
                _8643 = mem[_5760 + 32]
                require ext_code.size(sub_23bf2705Address)
                staticcall sub_23bf2705Address.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8710 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8902 = mem[_8710]
                if not mem[_8710]:
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5760]
                        if mem[(32 * idx) + _5760 + 32] > 0:
                            require idx < mem[_5760]
                            _11821 = mem[(32 * idx) + _5760 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5760 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11821
                        idx = idx + 1
                        continue 
                else:
                    _9204 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9204] = 3
                    mem[_9204 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if 10^9 * _8643 / 10^9 != _8643:
                        revert with 0, ''
                    _9656 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9656] = 26
                    mem[_9656 + 32] = 'SafeMath: division by zero'
                    if not _8902:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^9 * _8643 / _8902) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 367
                    sub_b32b53ab[address(arg1)] += 10^9 * _8643 / _8902
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5760]
                        if mem[(32 * idx) + _5760 + 32] > 0:
                            require idx < mem[_5760]
                            _11827 = mem[(32 * idx) + _5760 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5760 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11827
                        idx = idx + 1
                        continue 
            if 0 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            balances[address(arg1)] = ext_call.return_data[0]
        else:
            if not sub_df62497d:
                mem[(2 * ceil32(return_data.size)) + 320] = 30
                mem[(2 * ceil32(return_data.size)) + 352] = 'SafeMath: subtraction overflow'
                if 0 > ext_call.return_data[0] - balances[address(arg1)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[(2 * ceil32(return_data.size)) + 384] = 0x752f77f100000000000000000000000000000000000000000000000000000000
                require ext_code.size(sub_e56b22baAddress)
                staticcall sub_e56b22baAddress.getFeeDistribution() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 384
                require return_data.size >= 64
                _161 = mem[(2 * ceil32(return_data.size)) + 384]
                require mem[(2 * ceil32(return_data.size)) + 384] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
                _168 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384] <= test266151307()
                require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416 <= test266151307()
                mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416
                mem[(4 * ceil32(return_data.size)) + 384] = _168
                require _161 + (32 * _168) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 416 len 32 * _168] = mem[(2 * ceil32(return_data.size)) + _161 + 416 len 32 * _168]
                _2947 = mem[(2 * ceil32(return_data.size)) + 416]
                require mem[(2 * ceil32(return_data.size)) + 416] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
                _2998 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384] <= test266151307()
                _3006 = mem[64]
                require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 <= test266151307()
                mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32
                mem[_3006] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
                require return_data.size >= _2947 + (32 * _2998) + 32
                mem[_3006 + 32 len 32 * _2998] = mem[(2 * ceil32(return_data.size)) + _2947 + 416 len 32 * _2998]
                require _168 <= test266151307()
                _5762 = mem[64]
                mem[mem[64]] = _168
                mem[64] = mem[64] + (32 * _168) + 32
                if not _168:
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)]
                    while idx < _168:
                        require idx < mem[(4 * ceil32(return_data.size)) + 384]
                        require idx < mem[_3006]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8576 = mem[(32 * idx) + _3006 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5762]
                                mem[(32 * idx) + _5762 + 32] = 0
                                require idx < mem[_5762]
                                _8927 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8927] = 30
                                mem[_8927 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8927 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3006 + 32]:
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = 0
                                    require idx < mem[_5762]
                                    _9025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9025] = 30
                                    mem[_9025 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9025 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8687 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8687] = 3
                                    mem[_8687 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8576:
                                        _8736 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8736 + 68] = mem[idx + _8687 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8736 + 68] = mem[_8736 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8736 + -mem[64] + 100
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = (ext_call.return_data[0] * _8576) + (-1 * balances[address(arg1)] * _8576) + 5000 / 10000
                                    require idx < mem[_5762]
                                    _9125 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9125] = 30
                                    mem[_9125 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8576) + (-1 * balances[address(arg1)] * _8576) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8576) + (-1 * balances[address(arg1)] * _8576) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9125 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8615 = mem[(32 * idx) + _3006 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5762]
                                mem[(32 * idx) + _5762 + 32] = 0
                                require idx < mem[_5762]
                                _9026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9026] = 30
                                mem[_9026 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9026 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3006 + 32]:
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = 0
                                    require idx < mem[_5762]
                                    _9130 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9130] = 30
                                    mem[_9130 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9130 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8741] = 3
                                    mem[_8741 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8615:
                                        _8834 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8834 + 68] = mem[idx + _8741 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8834 + 68] = mem[_8834 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8834 + -mem[64] + 100
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = (ext_call.return_data[0] * _8615) + (-1 * balances[address(arg1)] * _8615) + 5000 / 10000
                                    require idx < mem[_5762]
                                    _9242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9242] = 30
                                    mem[_9242 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8615) + (-1 * balances[address(arg1)] * _8615) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8615) + (-1 * balances[address(arg1)] * _8615) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9242 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5762]
                    if s + mem[_5762 + 32] < mem[_5762 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5762]
                    mem[_5762 + 32] = s + mem[_5762 + 32]
                    require 0 < mem[_5762]
                    _8646 = mem[_5762 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8734 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8926 = mem[_8734]
                    if not mem[_8734]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5762]
                            if mem[(32 * idx) + _5762 + 32] > 0:
                                require idx < mem[_5762]
                                _11857 = mem[(32 * idx) + _5762 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5762 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11857
                            idx = idx + 1
                            continue 
                    else:
                        _9234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9234] = 3
                        mem[_9234 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8646 / 10^9 != _8646:
                            revert with 0, ''
                        _9704 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9704] = 26
                        mem[_9704 + 32] = 'SafeMath: division by zero'
                        if not _8926:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8646 / _8926) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8646 / _8926
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5762]
                            if mem[(32 * idx) + _5762 + 32] > 0:
                                require idx < mem[_5762]
                                _11863 = mem[(32 * idx) + _5762 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5762 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11863
                            idx = idx + 1
                            continue 
                else:
                    mem[_5762 + 32 len 32 * _168] = call.data[calldata.size len 32 * _168]
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)]
                    while idx < _168:
                        require idx < mem[(4 * ceil32(return_data.size)) + 384]
                        require idx < mem[_3006]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8580 = mem[(32 * idx) + _3006 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5762]
                                mem[(32 * idx) + _5762 + 32] = 0
                                require idx < mem[_5762]
                                _8935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8935] = 30
                                mem[_8935 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8935 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3006 + 32]:
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = 0
                                    require idx < mem[_5762]
                                    _9033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9033] = 30
                                    mem[_9033 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9033 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8689 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8689] = 3
                                    mem[_8689 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8580:
                                        _8744 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8744 + 68] = mem[idx + _8689 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8744 + 68] = mem[_8744 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8744 + -mem[64] + 100
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = (ext_call.return_data[0] * _8580) + (-1 * balances[address(arg1)] * _8580) + 5000 / 10000
                                    require idx < mem[_5762]
                                    _9134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9134] = 30
                                    mem[_9134 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8580) + (-1 * balances[address(arg1)] * _8580) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8580) + (-1 * balances[address(arg1)] * _8580) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9134 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8617 = mem[(32 * idx) + _3006 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5762]
                                mem[(32 * idx) + _5762 + 32] = 0
                                require idx < mem[_5762]
                                _9034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9034] = 30
                                mem[_9034 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9034 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3006 + 32]:
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = 0
                                    require idx < mem[_5762]
                                    _9139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9139] = 30
                                    mem[_9139 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9139 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8749 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8749] = 3
                                    mem[_8749 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8617:
                                        _8842 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8842 + 68] = mem[idx + _8749 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8842 + 68] = mem[_8842 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8842 + -mem[64] + 100
                                    require idx < mem[_5762]
                                    mem[(32 * idx) + _5762 + 32] = (ext_call.return_data[0] * _8617) + (-1 * balances[address(arg1)] * _8617) + 5000 / 10000
                                    require idx < mem[_5762]
                                    _9252 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9252] = 30
                                    mem[_9252 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8617) + (-1 * balances[address(arg1)] * _8617) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8617) + (-1 * balances[address(arg1)] * _8617) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9252 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5762]
                    if s + mem[_5762 + 32] < mem[_5762 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5762]
                    mem[_5762 + 32] = s + mem[_5762 + 32]
                    require 0 < mem[_5762]
                    _8647 = mem[_5762 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8742 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8934 = mem[_8742]
                    if not mem[_8742]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5762]
                            if mem[(32 * idx) + _5762 + 32] > 0:
                                require idx < mem[_5762]
                                _11869 = mem[(32 * idx) + _5762 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5762 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11869
                            idx = idx + 1
                            continue 
                    else:
                        _9244 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9244] = 3
                        mem[_9244 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8647 / 10^9 != _8647:
                            revert with 0, ''
                        _9720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9720] = 26
                        mem[_9720 + 32] = 'SafeMath: division by zero'
                        if not _8934:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8647 / _8934) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8647 / _8934
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5762]
                            if mem[(32 * idx) + _5762 + 32] > 0:
                                require idx < mem[_5762]
                                _11875 = mem[(32 * idx) + _5762 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5762 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11875
                            idx = idx + 1
                            continue 
                if 0 > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                balances[address(arg1)] = ext_call.return_data[0]
            else:
                mem[(2 * ceil32(return_data.size)) + 320] = 3
                mem[(2 * ceil32(return_data.size)) + 352] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / sub_df62497d:
                    revert with 0, ''
                mem[(2 * ceil32(return_data.size)) + 384] = 30
                mem[(2 * ceil32(return_data.size)) + 416] = 'SafeMath: subtraction overflow'
                if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0] - balances[address(arg1)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[(2 * ceil32(return_data.size)) + 448] = 0x752f77f100000000000000000000000000000000000000000000000000000000
                require ext_code.size(sub_e56b22baAddress)
                staticcall sub_e56b22baAddress.getFeeDistribution() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 448 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 448
                require return_data.size >= 64
                _165 = mem[(2 * ceil32(return_data.size)) + 448]
                require mem[(2 * ceil32(return_data.size)) + 448] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 479 < (2 * ceil32(return_data.size)) + return_data.size + 448
                _170 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448] <= test266151307()
                require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 480 <= test266151307()
                mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 480
                mem[(4 * ceil32(return_data.size)) + 448] = _170
                require _165 + (32 * _170) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 480 len 32 * _170] = mem[(2 * ceil32(return_data.size)) + _165 + 480 len 32 * _170]
                _2943 = mem[(2 * ceil32(return_data.size)) + 480]
                require mem[(2 * ceil32(return_data.size)) + 480] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 479 < (2 * ceil32(return_data.size)) + return_data.size + 448
                _2997 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448] <= test266151307()
                _3005 = mem[64]
                require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32 <= test266151307()
                mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32
                mem[_3005] = _2997
                require return_data.size >= _2943 + (32 * _2997) + 32
                mem[_3005 + 32 len 32 * _2997] = mem[(2 * ceil32(return_data.size)) + _2943 + 480 len 32 * _2997]
                require _170 <= test266151307()
                _5761 = mem[64]
                mem[mem[64]] = _170
                mem[64] = mem[64] + (32 * _170) + 32
                if not _170:
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                    while idx < _170:
                        require idx < mem[(4 * ceil32(return_data.size)) + 448]
                        require idx < mem[_3005]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8568 = mem[(32 * idx) + _3005 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5761]
                                mem[(32 * idx) + _5761 + 32] = 0
                                require idx < mem[_5761]
                                _8911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8911] = 30
                                mem[_8911 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8911 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3005 + 32]:
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = 0
                                    require idx < mem[_5761]
                                    _9009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9009] = 30
                                    mem[_9009 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9009 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8683] = 3
                                    mem[_8683 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8568:
                                        _8720 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8720 + 68] = mem[idx + _8683 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8720 + 68] = mem[_8720 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8720 + -mem[64] + 100
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = (ext_call.return_data[0] * _8568) + (-1 * balances[address(arg1)] * _8568) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8568) + 5000 / 10000
                                    require idx < mem[_5761]
                                    _9107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9107] = 30
                                    mem[_9107 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8568) + (-1 * balances[address(arg1)] * _8568) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8568) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8568) + (-1 * balances[address(arg1)] * _8568) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8568) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9107 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8611 = mem[(32 * idx) + _3005 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5761]
                                mem[(32 * idx) + _5761 + 32] = 0
                                require idx < mem[_5761]
                                _9010 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9010] = 30
                                mem[_9010 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9010 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3005 + 32]:
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = 0
                                    require idx < mem[_5761]
                                    _9112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9112] = 30
                                    mem[_9112 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9112 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8725 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8725] = 3
                                    mem[_8725 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8611:
                                        _8818 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8818 + 68] = mem[idx + _8725 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8818 + 68] = mem[_8818 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8818 + -mem[64] + 100
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = (ext_call.return_data[0] * _8611) + (-1 * balances[address(arg1)] * _8611) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8611) + 5000 / 10000
                                    require idx < mem[_5761]
                                    _9222 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9222] = 30
                                    mem[_9222 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8611) + (-1 * balances[address(arg1)] * _8611) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8611) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8611) + (-1 * balances[address(arg1)] * _8611) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8611) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9222 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5761]
                    if s + mem[_5761 + 32] < mem[_5761 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5761]
                    mem[_5761 + 32] = s + mem[_5761 + 32]
                    require 0 < mem[_5761]
                    _8644 = mem[_5761 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8718 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8910 = mem[_8718]
                    if not mem[_8718]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5761]
                            if mem[(32 * idx) + _5761 + 32] > 0:
                                require idx < mem[_5761]
                                _11833 = mem[(32 * idx) + _5761 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5761 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11833
                            idx = idx + 1
                            continue 
                        _11422 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11422] = 30
                        mem[_11422 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12206 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12207 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12207 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12385 = mem[_12207]
                            mem[mem[64] len floor32(mem[_12207])] = mem[_12207 + 32 len floor32(mem[_12207])]
                            mem[mem[64] + floor32(mem[_12207]) + -(mem[_12207] % 32) + 32 len mem[_12207] % 32] = mem[_12207 + floor32(mem[_12207]) + -(mem[_12207] % 32) + 64 len mem[_12207] % 32]
                            call address(arg1) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12385 + _12206 + -mem[64] + 96]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                            else:
                                _12646 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_12646] = return_data.size
                                mem[_12646 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12646 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                    else:
                        _9214 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9214] = 3
                        mem[_9214 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8644 / 10^9 != _8644:
                            revert with 0, ''
                        _9672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9672] = 26
                        mem[_9672 + 32] = 'SafeMath: division by zero'
                        if not _8910:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8644 / _8910) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8644 / _8910
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5761]
                            if mem[(32 * idx) + _5761 + 32] > 0:
                                require idx < mem[_5761]
                                _11839 = mem[(32 * idx) + _5761 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5761 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11839
                            idx = idx + 1
                            continue 
                        _11424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11424] = 30
                        mem[_11424 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12213 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12214 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12214 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12391 = mem[_12214]
                            mem[_12213 + 100 len floor32(mem[_12214])] = mem[_12214 + 32 len floor32(mem[_12214])]
                            mem[_12213 + floor32(mem[_12214]) + -(mem[_12214] % 32) + 132 len mem[_12214] % 32] = mem[_12214 + -(mem[_12214] % 32) + floor32(mem[_12214]) + 64 len mem[_12214] % 32]
                            call address(arg1).mem[_12213 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12213 + 104 len _12391 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12213 + 210 len 22]
                            else:
                                mem[_12213 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12213 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12213 + ceil32(return_data.size) + 211 len 22]
                else:
                    mem[_5761 + 32 len 32 * _170] = call.data[calldata.size len 32 * _170]
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                    while idx < _170:
                        require idx < mem[(4 * ceil32(return_data.size)) + 448]
                        require idx < mem[_3005]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8572 = mem[(32 * idx) + _3005 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5761]
                                mem[(32 * idx) + _5761 + 32] = 0
                                require idx < mem[_5761]
                                _8919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8919] = 30
                                mem[_8919 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8919 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3005 + 32]:
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = 0
                                    require idx < mem[_5761]
                                    _9017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9017] = 30
                                    mem[_9017 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9017 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8685 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8685] = 3
                                    mem[_8685 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8572:
                                        _8728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8728 + 68] = mem[idx + _8685 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8728 + 68] = mem[_8728 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8728 + -mem[64] + 100
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = (ext_call.return_data[0] * _8572) + (-1 * balances[address(arg1)] * _8572) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8572) + 5000 / 10000
                                    require idx < mem[_5761]
                                    _9116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9116] = 30
                                    mem[_9116 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8572) + (-1 * balances[address(arg1)] * _8572) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8572) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8572) + (-1 * balances[address(arg1)] * _8572) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8572) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9116 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8613 = mem[(32 * idx) + _3005 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5761]
                                mem[(32 * idx) + _5761 + 32] = 0
                                require idx < mem[_5761]
                                _9018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9018] = 30
                                mem[_9018 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9018 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3005 + 32]:
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = 0
                                    require idx < mem[_5761]
                                    _9121 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9121] = 30
                                    mem[_9121 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9121 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8733 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8733] = 3
                                    mem[_8733 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8613:
                                        _8826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8826 + 68] = mem[idx + _8733 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8826 + 68] = mem[_8826 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8826 + -mem[64] + 100
                                    require idx < mem[_5761]
                                    mem[(32 * idx) + _5761 + 32] = (ext_call.return_data[0] * _8613) + (-1 * balances[address(arg1)] * _8613) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8613) + 5000 / 10000
                                    require idx < mem[_5761]
                                    _9232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9232] = 30
                                    mem[_9232 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8613) + (-1 * balances[address(arg1)] * _8613) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8613) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8613) + (-1 * balances[address(arg1)] * _8613) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8613) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9232 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5761]
                    if s + mem[_5761 + 32] < mem[_5761 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5761]
                    mem[_5761 + 32] = s + mem[_5761 + 32]
                    require 0 < mem[_5761]
                    _8645 = mem[_5761 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8726 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8918 = mem[_8726]
                    if not mem[_8726]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5761]
                            if mem[(32 * idx) + _5761 + 32] > 0:
                                require idx < mem[_5761]
                                _11845 = mem[(32 * idx) + _5761 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5761 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11845
                            idx = idx + 1
                            continue 
                        _11446 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11446] = 30
                        mem[_11446 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12220 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12221 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12221 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12397 = mem[_12221]
                            mem[_12220 + 100 len floor32(mem[_12221])] = mem[_12221 + 32 len floor32(mem[_12221])]
                            mem[_12220 + floor32(mem[_12221]) + -(mem[_12221] % 32) + 132 len mem[_12221] % 32] = mem[_12221 + -(mem[_12221] % 32) + floor32(mem[_12221]) + 64 len mem[_12221] % 32]
                            call address(arg1).mem[_12220 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12220 + 104 len _12397 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12220 + 210 len 22]
                            else:
                                mem[_12220 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12220 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12220 + ceil32(return_data.size) + 211 len 22]
                    else:
                        _9224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9224] = 3
                        mem[_9224 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8645 / 10^9 != _8645:
                            revert with 0, ''
                        _9688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9688] = 26
                        mem[_9688 + 32] = 'SafeMath: division by zero'
                        if not _8918:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8645 / _8918) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8645 / _8918
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5761]
                            if mem[(32 * idx) + _5761 + 32] > 0:
                                require idx < mem[_5761]
                                _11851 = mem[(32 * idx) + _5761 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5761 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11851
                            idx = idx + 1
                            continue 
                        _11448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11448] = 30
                        mem[_11448 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12227 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12228 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12228 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12403 = mem[_12228]
                            mem[_12227 + 100 len floor32(mem[_12228])] = mem[_12228 + 32 len floor32(mem[_12228])]
                            mem[_12227 + floor32(mem[_12228]) + -(mem[_12228] % 32) + 132 len mem[_12228] % 32] = mem[_12228 + -(mem[_12228] % 32) + floor32(mem[_12228]) + 64 len mem[_12228] % 32]
                            call address(arg1).mem[_12227 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12227 + 104 len _12403 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12227 + 210 len 22]
                            else:
                                mem[_12227 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12227 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12227 + ceil32(return_data.size) + 211 len 22]
    else:
        stor362.length++
        address(stor362[stor362.length].field_0) = address(arg1)
        Mask(96, 0, stor362[stor362.length].field_160) = 0
        stor363[address(arg1)] = stor362.length
        mem[ceil32(return_data.size) + 260] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[0] = address(arg1)
        mem[32] = 366
        mem[(2 * ceil32(return_data.size)) + 256] = 30
        mem[(2 * ceil32(return_data.size)) + 288] = 'SafeMath: subtraction overflow'
        if balances[address(arg1)] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ext_call.return_data[0] - balances[address(arg1)]:
            mem[(2 * ceil32(return_data.size)) + 320] = 30
            mem[(2 * ceil32(return_data.size)) + 352] = 'SafeMath: subtraction overflow'
            if 0 > ext_call.return_data[0] - balances[address(arg1)]:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[(2 * ceil32(return_data.size)) + 384] = 0x752f77f100000000000000000000000000000000000000000000000000000000
            require ext_code.size(sub_e56b22baAddress)
            staticcall sub_e56b22baAddress.getFeeDistribution() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 384
            require return_data.size >= 64
            _155 = mem[(2 * ceil32(return_data.size)) + 384]
            require mem[(2 * ceil32(return_data.size)) + 384] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
            _166 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384] <= test266151307()
            require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416 <= test266151307()
            mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416
            mem[(4 * ceil32(return_data.size)) + 384] = _166
            require _155 + (32 * _166) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 416 len 32 * _166] = mem[(2 * ceil32(return_data.size)) + _155 + 416 len 32 * _166]
            _2951 = mem[(2 * ceil32(return_data.size)) + 416]
            require mem[(2 * ceil32(return_data.size)) + 416] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
            _2999 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
            require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384] <= test266151307()
            _3007 = mem[64]
            require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 <= test266151307()
            mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32
            mem[_3007] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
            require return_data.size >= _2951 + (32 * _2999) + 32
            mem[_3007 + 32 len 32 * _2999] = mem[(2 * ceil32(return_data.size)) + _2951 + 416 len 32 * _2999]
            require _166 <= test266151307()
            _5763 = mem[64]
            mem[mem[64]] = _166
            mem[64] = mem[64] + (32 * _166) + 32
            if not _166:
                idx = 0
                s = ext_call.return_data[0] - balances[address(arg1)]
                while idx < _166:
                    require idx < mem[(4 * ceil32(return_data.size)) + 384]
                    require idx < mem[_3007]
                    if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                        _8584 = mem[(32 * idx) + _3007 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5763]
                            mem[(32 * idx) + _5763 + 32] = 0
                            require idx < mem[_5763]
                            _8943 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8943] = 30
                            mem[_8943 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            s = 32
                            while s < 30:
                                mem[s + mem[64] + 68] = mem[s + _8943 + 32]
                                s = s + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3007 + 32]:
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = 0
                                require idx < mem[_5763]
                                _9041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9041] = 30
                                mem[_9041 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9041 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8691] = 3
                                mem[_8691 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8584:
                                    _8752 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8752 + 68] = mem[idx + _8691 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8752 + 68] = mem[_8752 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8752 + -mem[64] + 100
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = (ext_call.return_data[0] * _8584) + (-1 * balances[address(arg1)] * _8584) + 5000 / 10000
                                require idx < mem[_5763]
                                _9143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9143] = 30
                                mem[_9143 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8584) + (-1 * balances[address(arg1)] * _8584) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8584) + (-1 * balances[address(arg1)] * _8584) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9143 + 32]
                                    idx = idx + 32
                                    continue 
                    else:
                        _8619 = mem[(32 * idx) + _3007 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5763]
                            mem[(32 * idx) + _5763 + 32] = 0
                            require idx < mem[_5763]
                            _9042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9042] = 30
                            mem[_9042 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _9042 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3007 + 32]:
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = 0
                                require idx < mem[_5763]
                                _9148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9148] = 30
                                mem[_9148 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9148 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8757 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8757] = 3
                                mem[_8757 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8619:
                                    _8850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8850 + 68] = mem[idx + _8757 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8850 + 68] = mem[_8850 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8850 + -mem[64] + 100
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = (ext_call.return_data[0] * _8619) + (-1 * balances[address(arg1)] * _8619) + 5000 / 10000
                                require idx < mem[_5763]
                                _9262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9262] = 30
                                mem[_9262 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8619) + (-1 * balances[address(arg1)] * _8619) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8619) + (-1 * balances[address(arg1)] * _8619) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9262 + 32]
                                    idx = idx + 32
                                    continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                require 0 < mem[_5763]
                if s + mem[_5763 + 32] < mem[_5763 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require 0 < mem[_5763]
                mem[_5763 + 32] = s + mem[_5763 + 32]
                require 0 < mem[_5763]
                _8648 = mem[_5763 + 32]
                require ext_code.size(sub_23bf2705Address)
                staticcall sub_23bf2705Address.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8750 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8942 = mem[_8750]
                if not mem[_8750]:
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5763]
                        if mem[(32 * idx) + _5763 + 32] > 0:
                            require idx < mem[_5763]
                            _11881 = mem[(32 * idx) + _5763 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5763 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11881
                        idx = idx + 1
                        continue 
                else:
                    _9254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9254] = 3
                    mem[_9254 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if 10^9 * _8648 / 10^9 != _8648:
                        revert with 0, ''
                    _9736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9736] = 26
                    mem[_9736 + 32] = 'SafeMath: division by zero'
                    if not _8942:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^9 * _8648 / _8942) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 367
                    sub_b32b53ab[address(arg1)] += 10^9 * _8648 / _8942
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5763]
                        if mem[(32 * idx) + _5763 + 32] > 0:
                            require idx < mem[_5763]
                            _11887 = mem[(32 * idx) + _5763 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5763 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11887
                        idx = idx + 1
                        continue 
            else:
                mem[_5763 + 32 len 32 * _166] = call.data[calldata.size len 32 * _166]
                idx = 0
                s = ext_call.return_data[0] - balances[address(arg1)]
                while idx < _166:
                    require idx < mem[(4 * ceil32(return_data.size)) + 384]
                    require idx < mem[_3007]
                    if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                        _8588 = mem[(32 * idx) + _3007 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5763]
                            mem[(32 * idx) + _5763 + 32] = 0
                            require idx < mem[_5763]
                            _8951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8951] = 30
                            mem[_8951 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            s = 32
                            while s < 30:
                                mem[s + mem[64] + 68] = mem[s + _8951 + 32]
                                s = s + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3007 + 32]:
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = 0
                                require idx < mem[_5763]
                                _9049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9049] = 30
                                mem[_9049 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9049 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8693] = 3
                                mem[_8693 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8588:
                                    _8760 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8760 + 68] = mem[idx + _8693 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8760 + 68] = mem[_8760 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8760 + -mem[64] + 100
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = (ext_call.return_data[0] * _8588) + (-1 * balances[address(arg1)] * _8588) + 5000 / 10000
                                require idx < mem[_5763]
                                _9152 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9152] = 30
                                mem[_9152 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8588) + (-1 * balances[address(arg1)] * _8588) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8588) + (-1 * balances[address(arg1)] * _8588) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9152 + 32]
                                    idx = idx + 32
                                    continue 
                    else:
                        _8621 = mem[(32 * idx) + _3007 + 32]
                        if not ext_call.return_data[0] - balances[address(arg1)]:
                            require idx < mem[_5763]
                            mem[(32 * idx) + _5763 + 32] = 0
                            require idx < mem[_5763]
                            _9050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9050] = 30
                            mem[_9050 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= s:
                                idx = idx + 1
                                s = s
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _9050 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not mem[(32 * idx) + _3007 + 32]:
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = 0
                                require idx < mem[_5763]
                                _9157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9157] = 30
                                mem[_9157 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9157 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _8765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8765] = 3
                                mem[_8765 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8621:
                                    _8858 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 3
                                    idx = 0
                                    while idx < 3:
                                        mem[idx + _8858 + 68] = mem[idx + _8765 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8858 + 68] = mem[_8858 + 97 len 3]
                                    revert with memory
                                      from mem[64]
                                       len _8858 + -mem[64] + 100
                                require idx < mem[_5763]
                                mem[(32 * idx) + _5763 + 32] = (ext_call.return_data[0] * _8621) + (-1 * balances[address(arg1)] * _8621) + 5000 / 10000
                                require idx < mem[_5763]
                                _9272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9272] = 30
                                mem[_9272 + 32] = 'SafeMath: subtraction overflow'
                                if (ext_call.return_data[0] * _8621) + (-1 * balances[address(arg1)] * _8621) + 5000 / 10000 <= s:
                                    idx = idx + 1
                                    s = s - ((ext_call.return_data[0] * _8621) + (-1 * balances[address(arg1)] * _8621) + 5000 / 10000)
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9272 + 32]
                                    idx = idx + 32
                                    continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                require 0 < mem[_5763]
                if s + mem[_5763 + 32] < mem[_5763 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require 0 < mem[_5763]
                mem[_5763 + 32] = s + mem[_5763 + 32]
                require 0 < mem[_5763]
                _8649 = mem[_5763 + 32]
                require ext_code.size(sub_23bf2705Address)
                staticcall sub_23bf2705Address.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8758 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8950 = mem[_8758]
                if not mem[_8758]:
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5763]
                        if mem[(32 * idx) + _5763 + 32] > 0:
                            require idx < mem[_5763]
                            _11893 = mem[(32 * idx) + _5763 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5763 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11893
                        idx = idx + 1
                        continue 
                else:
                    _9264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9264] = 3
                    mem[_9264 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if 10^9 * _8649 / 10^9 != _8649:
                        revert with 0, ''
                    _9752 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9752] = 26
                    mem[_9752 + 32] = 'SafeMath: division by zero'
                    if not _8950:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^9 * _8649 / _8950) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 367
                    sub_b32b53ab[address(arg1)] += 10^9 * _8649 / _8950
                    idx = 0
                    while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                        require idx < mem[_5763]
                        if mem[(32 * idx) + _5763 + 32] > 0:
                            require idx < mem[_5763]
                            _11899 = mem[(32 * idx) + _5763 + 32]
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            if mem[(32 * idx) + _5763 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < mem[(4 * ceil32(return_data.size)) + 384]
                            mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                            mem[32] = sha3(address(arg1), 364)
                            uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11899
                        idx = idx + 1
                        continue 
            if 0 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            balances[address(arg1)] = ext_call.return_data[0]
        else:
            if not sub_df62497d:
                mem[(2 * ceil32(return_data.size)) + 320] = 30
                mem[(2 * ceil32(return_data.size)) + 352] = 'SafeMath: subtraction overflow'
                if 0 > ext_call.return_data[0] - balances[address(arg1)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[(2 * ceil32(return_data.size)) + 384] = 0x752f77f100000000000000000000000000000000000000000000000000000000
                require ext_code.size(sub_e56b22baAddress)
                staticcall sub_e56b22baAddress.getFeeDistribution() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 384
                require return_data.size >= 64
                _163 = mem[(2 * ceil32(return_data.size)) + 384]
                require mem[(2 * ceil32(return_data.size)) + 384] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
                _169 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384] <= test266151307()
                require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416 <= test266151307()
                mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 384] + 384]) + 416
                mem[(4 * ceil32(return_data.size)) + 384] = _169
                require _163 + (32 * _169) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 416 len 32 * _169] = mem[(2 * ceil32(return_data.size)) + _163 + 416 len 32 * _169]
                _2958 = mem[(2 * ceil32(return_data.size)) + 416]
                require mem[(2 * ceil32(return_data.size)) + 416] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 415 < (2 * ceil32(return_data.size)) + return_data.size + 384
                _3001 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384] <= test266151307()
                _3009 = mem[64]
                require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32 <= test266151307()
                mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]) + 32
                mem[_3009] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 416] + 384]
                require return_data.size >= _2958 + (32 * _3001) + 32
                mem[_3009 + 32 len 32 * _3001] = mem[(2 * ceil32(return_data.size)) + _2958 + 416 len 32 * _3001]
                require _169 <= test266151307()
                _5765 = mem[64]
                mem[mem[64]] = _169
                mem[64] = mem[64] + (32 * _169) + 32
                if not _169:
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)]
                    while idx < _169:
                        require idx < mem[(4 * ceil32(return_data.size)) + 384]
                        require idx < mem[_3009]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8600 = mem[(32 * idx) + _3009 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5765]
                                mem[(32 * idx) + _5765 + 32] = 0
                                require idx < mem[_5765]
                                _8975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8975] = 30
                                mem[_8975 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8975 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3009 + 32]:
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = 0
                                    require idx < mem[_5765]
                                    _9073 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9073] = 30
                                    mem[_9073 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9073 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8699] = 3
                                    mem[_8699 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8600:
                                        _8784 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8784 + 68] = mem[idx + _8699 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8784 + 68] = mem[_8784 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8784 + -mem[64] + 100
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = (ext_call.return_data[0] * _8600) + (-1 * balances[address(arg1)] * _8600) + 5000 / 10000
                                    require idx < mem[_5765]
                                    _9179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9179] = 30
                                    mem[_9179 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8600) + (-1 * balances[address(arg1)] * _8600) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8600) + (-1 * balances[address(arg1)] * _8600) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9179 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8627 = mem[(32 * idx) + _3009 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5765]
                                mem[(32 * idx) + _5765 + 32] = 0
                                require idx < mem[_5765]
                                _9074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9074] = 30
                                mem[_9074 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9074 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3009 + 32]:
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = 0
                                    require idx < mem[_5765]
                                    _9184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9184] = 30
                                    mem[_9184 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9184 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8789] = 3
                                    mem[_8789 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8627:
                                        _8882 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8882 + 68] = mem[idx + _8789 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8882 + 68] = mem[_8882 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8882 + -mem[64] + 100
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = (ext_call.return_data[0] * _8627) + (-1 * balances[address(arg1)] * _8627) + 5000 / 10000
                                    require idx < mem[_5765]
                                    _9302 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9302] = 30
                                    mem[_9302 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8627) + (-1 * balances[address(arg1)] * _8627) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8627) + (-1 * balances[address(arg1)] * _8627) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9302 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5765]
                    if s + mem[_5765 + 32] < mem[_5765 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5765]
                    mem[_5765 + 32] = s + mem[_5765 + 32]
                    require 0 < mem[_5765]
                    _8652 = mem[_5765 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8782 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8974 = mem[_8782]
                    if not mem[_8782]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5765]
                            if mem[(32 * idx) + _5765 + 32] > 0:
                                require idx < mem[_5765]
                                _11929 = mem[(32 * idx) + _5765 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5765 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11929
                            idx = idx + 1
                            continue 
                    else:
                        _9294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9294] = 3
                        mem[_9294 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8652 / 10^9 != _8652:
                            revert with 0, ''
                        _9800 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9800] = 26
                        mem[_9800 + 32] = 'SafeMath: division by zero'
                        if not _8974:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8652 / _8974) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8652 / _8974
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5765]
                            if mem[(32 * idx) + _5765 + 32] > 0:
                                require idx < mem[_5765]
                                _11935 = mem[(32 * idx) + _5765 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5765 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11935
                            idx = idx + 1
                            continue 
                else:
                    mem[_5765 + 32 len 32 * _169] = call.data[calldata.size len 32 * _169]
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)]
                    while idx < _169:
                        require idx < mem[(4 * ceil32(return_data.size)) + 384]
                        require idx < mem[_3009]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8604 = mem[(32 * idx) + _3009 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5765]
                                mem[(32 * idx) + _5765 + 32] = 0
                                require idx < mem[_5765]
                                _8983 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8983] = 30
                                mem[_8983 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8983 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3009 + 32]:
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = 0
                                    require idx < mem[_5765]
                                    _9081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9081] = 30
                                    mem[_9081 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9081 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8701 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8701] = 3
                                    mem[_8701 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8604:
                                        _8792 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8792 + 68] = mem[idx + _8701 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8792 + 68] = mem[_8792 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8792 + -mem[64] + 100
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = (ext_call.return_data[0] * _8604) + (-1 * balances[address(arg1)] * _8604) + 5000 / 10000
                                    require idx < mem[_5765]
                                    _9188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9188] = 30
                                    mem[_9188 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8604) + (-1 * balances[address(arg1)] * _8604) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8604) + (-1 * balances[address(arg1)] * _8604) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9188 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8629 = mem[(32 * idx) + _3009 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)]:
                                require idx < mem[_5765]
                                mem[(32 * idx) + _5765 + 32] = 0
                                require idx < mem[_5765]
                                _9082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9082] = 30
                                mem[_9082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9082 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3009 + 32]:
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = 0
                                    require idx < mem[_5765]
                                    _9193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9193] = 30
                                    mem[_9193 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9193 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8797] = 3
                                    mem[_8797 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] > -5001 / _8629:
                                        _8890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8890 + 68] = mem[idx + _8797 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8890 + 68] = mem[_8890 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8890 + -mem[64] + 100
                                    require idx < mem[_5765]
                                    mem[(32 * idx) + _5765 + 32] = (ext_call.return_data[0] * _8629) + (-1 * balances[address(arg1)] * _8629) + 5000 / 10000
                                    require idx < mem[_5765]
                                    _9312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9312] = 30
                                    mem[_9312 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8629) + (-1 * balances[address(arg1)] * _8629) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8629) + (-1 * balances[address(arg1)] * _8629) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9312 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5765]
                    if s + mem[_5765 + 32] < mem[_5765 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5765]
                    mem[_5765 + 32] = s + mem[_5765 + 32]
                    require 0 < mem[_5765]
                    _8653 = mem[_5765 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8790 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8982 = mem[_8790]
                    if not mem[_8790]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5765]
                            if mem[(32 * idx) + _5765 + 32] > 0:
                                require idx < mem[_5765]
                                _11941 = mem[(32 * idx) + _5765 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5765 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11941
                            idx = idx + 1
                            continue 
                    else:
                        _9304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9304] = 3
                        mem[_9304 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8653 / 10^9 != _8653:
                            revert with 0, ''
                        _9816 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9816] = 26
                        mem[_9816 + 32] = 'SafeMath: division by zero'
                        if not _8982:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8653 / _8982) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8653 / _8982
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 384]:
                            require idx < mem[_5765]
                            if mem[(32 * idx) + _5765 + 32] > 0:
                                require idx < mem[_5765]
                                _11947 = mem[(32 * idx) + _5765 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                if mem[(32 * idx) + _5765 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 384]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 416]].field_0) += _11947
                            idx = idx + 1
                            continue 
                if 0 > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                balances[address(arg1)] = ext_call.return_data[0]
            else:
                mem[(2 * ceil32(return_data.size)) + 320] = 3
                mem[(2 * ceil32(return_data.size)) + 352] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if ext_call.return_data[0] - balances[address(arg1)] > -5001 / sub_df62497d:
                    revert with 0, ''
                mem[(2 * ceil32(return_data.size)) + 384] = 30
                mem[(2 * ceil32(return_data.size)) + 416] = 'SafeMath: subtraction overflow'
                if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0] - balances[address(arg1)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[(2 * ceil32(return_data.size)) + 448] = 0x752f77f100000000000000000000000000000000000000000000000000000000
                require ext_code.size(sub_e56b22baAddress)
                staticcall sub_e56b22baAddress.getFeeDistribution() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 448 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 448
                require return_data.size >= 64
                _167 = mem[(2 * ceil32(return_data.size)) + 448]
                require mem[(2 * ceil32(return_data.size)) + 448] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 479 < (2 * ceil32(return_data.size)) + return_data.size + 448
                _171 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448] <= test266151307()
                require (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 32 >= 0 and (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 480 <= test266151307()
                mem[64] = (4 * ceil32(return_data.size)) + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 448] + 448]) + 480
                mem[(4 * ceil32(return_data.size)) + 448] = _171
                require _167 + (32 * _171) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 480 len 32 * _171] = mem[(2 * ceil32(return_data.size)) + _167 + 480 len 32 * _171]
                _2954 = mem[(2 * ceil32(return_data.size)) + 480]
                require mem[(2 * ceil32(return_data.size)) + 480] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 479 < (2 * ceil32(return_data.size)) + return_data.size + 448
                _3000 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]
                require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448] <= test266151307()
                _3008 = mem[64]
                require mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32 >= mem[64] and mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32 <= test266151307()
                mem[64] = mem[64] + (32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 480] + 448]) + 32
                mem[_3008] = _3000
                require return_data.size >= _2954 + (32 * _3000) + 32
                mem[_3008 + 32 len 32 * _3000] = mem[(2 * ceil32(return_data.size)) + _2954 + 480 len 32 * _3000]
                require _171 <= test266151307()
                _5764 = mem[64]
                mem[mem[64]] = _171
                mem[64] = mem[64] + (32 * _171) + 32
                if not _171:
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                    while idx < _171:
                        require idx < mem[(4 * ceil32(return_data.size)) + 448]
                        require idx < mem[_3008]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8592 = mem[(32 * idx) + _3008 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5764]
                                mem[(32 * idx) + _5764 + 32] = 0
                                require idx < mem[_5764]
                                _8959 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8959] = 30
                                mem[_8959 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8959 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3008 + 32]:
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = 0
                                    require idx < mem[_5764]
                                    _9057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9057] = 30
                                    mem[_9057 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9057 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8695 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8695] = 3
                                    mem[_8695 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8592:
                                        _8768 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8768 + 68] = mem[idx + _8695 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8768 + 68] = mem[_8768 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8768 + -mem[64] + 100
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = (ext_call.return_data[0] * _8592) + (-1 * balances[address(arg1)] * _8592) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8592) + 5000 / 10000
                                    require idx < mem[_5764]
                                    _9161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9161] = 30
                                    mem[_9161 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8592) + (-1 * balances[address(arg1)] * _8592) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8592) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8592) + (-1 * balances[address(arg1)] * _8592) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8592) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9161 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8623 = mem[(32 * idx) + _3008 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5764]
                                mem[(32 * idx) + _5764 + 32] = 0
                                require idx < mem[_5764]
                                _9058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9058] = 30
                                mem[_9058 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9058 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3008 + 32]:
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = 0
                                    require idx < mem[_5764]
                                    _9166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9166] = 30
                                    mem[_9166 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9166 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8773 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8773] = 3
                                    mem[_8773 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8623:
                                        _8866 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8866 + 68] = mem[idx + _8773 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8866 + 68] = mem[_8866 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8866 + -mem[64] + 100
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = (ext_call.return_data[0] * _8623) + (-1 * balances[address(arg1)] * _8623) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8623) + 5000 / 10000
                                    require idx < mem[_5764]
                                    _9282 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9282] = 30
                                    mem[_9282 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8623) + (-1 * balances[address(arg1)] * _8623) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8623) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8623) + (-1 * balances[address(arg1)] * _8623) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8623) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9282 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5764]
                    if s + mem[_5764 + 32] < mem[_5764 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5764]
                    mem[_5764 + 32] = s + mem[_5764 + 32]
                    require 0 < mem[_5764]
                    _8650 = mem[_5764 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8766 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8958 = mem[_8766]
                    if not mem[_8766]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5764]
                            if mem[(32 * idx) + _5764 + 32] > 0:
                                require idx < mem[_5764]
                                _11905 = mem[(32 * idx) + _5764 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5764 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11905
                            idx = idx + 1
                            continue 
                        _11566 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11566] = 30
                        mem[_11566 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12266 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12267 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12267 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12409 = mem[_12267]
                            mem[_12266 + 100 len floor32(mem[_12267])] = mem[_12267 + 32 len floor32(mem[_12267])]
                            mem[_12266 + floor32(mem[_12267]) + -(mem[_12267] % 32) + 132 len mem[_12267] % 32] = mem[_12267 + -(mem[_12267] % 32) + floor32(mem[_12267]) + 64 len mem[_12267] % 32]
                            call address(arg1).mem[_12266 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12266 + 104 len _12409 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12266 + 210 len 22]
                            else:
                                mem[_12266 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12266 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12266 + ceil32(return_data.size) + 211 len 22]
                    else:
                        _9274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9274] = 3
                        mem[_9274 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8650 / 10^9 != _8650:
                            revert with 0, ''
                        _9768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9768] = 26
                        mem[_9768 + 32] = 'SafeMath: division by zero'
                        if not _8958:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8650 / _8958) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8650 / _8958
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5764]
                            if mem[(32 * idx) + _5764 + 32] > 0:
                                require idx < mem[_5764]
                                _11911 = mem[(32 * idx) + _5764 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5764 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11911
                            idx = idx + 1
                            continue 
                        _11568 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11568] = 30
                        mem[_11568 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12273 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12274 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12274 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12415 = mem[_12274]
                            mem[_12273 + 100 len floor32(mem[_12274])] = mem[_12274 + 32 len floor32(mem[_12274])]
                            mem[_12273 + floor32(mem[_12274]) + -(mem[_12274] % 32) + 132 len mem[_12274] % 32] = mem[_12274 + -(mem[_12274] % 32) + floor32(mem[_12274]) + 64 len mem[_12274] % 32]
                            call address(arg1).mem[_12273 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12273 + 104 len _12415 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12273 + 210 len 22]
                            else:
                                mem[_12273 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12273 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12273 + ceil32(return_data.size) + 211 len 22]
                else:
                    mem[_5764 + 32 len 32 * _171] = call.data[calldata.size len 32 * _171]
                    idx = 0
                    s = ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                    while idx < _171:
                        require idx < mem[(4 * ceil32(return_data.size)) + 448]
                        require idx < mem[_3008]
                        if mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480] != 0x474f5645524e414e43455f524557415244000000000000000000000000000000:
                            _8596 = mem[(32 * idx) + _3008 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5764]
                                mem[(32 * idx) + _5764 + 32] = 0
                                require idx < mem[_5764]
                                _8967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8967] = 30
                                mem[_8967 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                s = 32
                                while s < 30:
                                    mem[s + mem[64] + 68] = mem[s + _8967 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3008 + 32]:
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = 0
                                    require idx < mem[_5764]
                                    _9065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9065] = 30
                                    mem[_9065 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9065 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8697 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8697] = 3
                                    mem[_8697 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8596:
                                        _8776 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8776 + 68] = mem[idx + _8697 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8776 + 68] = mem[_8776 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8776 + -mem[64] + 100
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = (ext_call.return_data[0] * _8596) + (-1 * balances[address(arg1)] * _8596) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8596) + 5000 / 10000
                                    require idx < mem[_5764]
                                    _9170 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9170] = 30
                                    mem[_9170 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8596) + (-1 * balances[address(arg1)] * _8596) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8596) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8596) + (-1 * balances[address(arg1)] * _8596) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8596) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9170 + 32]
                                        idx = idx + 32
                                        continue 
                        else:
                            _8625 = mem[(32 * idx) + _3008 + 32]
                            if not ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000):
                                require idx < mem[_5764]
                                mem[(32 * idx) + _5764 + 32] = 0
                                require idx < mem[_5764]
                                _9066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9066] = 30
                                mem[_9066 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= s:
                                    idx = idx + 1
                                    s = s
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _9066 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                if not mem[(32 * idx) + _3008 + 32]:
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = 0
                                    require idx < mem[_5764]
                                    _9175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9175] = 30
                                    mem[_9175 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= s:
                                        idx = idx + 1
                                        s = s
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9175 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _8781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8781] = 3
                                    mem[_8781 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                                    if ext_call.return_data[0] - balances[address(arg1)] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000) > -5001 / _8625:
                                        _8874 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 3
                                        idx = 0
                                        while idx < 3:
                                            mem[idx + _8874 + 68] = mem[idx + _8781 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8874 + 68] = mem[_8874 + 97 len 3]
                                        revert with memory
                                          from mem[64]
                                           len _8874 + -mem[64] + 100
                                    require idx < mem[_5764]
                                    mem[(32 * idx) + _5764 + 32] = (ext_call.return_data[0] * _8625) + (-1 * balances[address(arg1)] * _8625) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8625) + 5000 / 10000
                                    require idx < mem[_5764]
                                    _9292 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9292] = 30
                                    mem[_9292 + 32] = 'SafeMath: subtraction overflow'
                                    if (ext_call.return_data[0] * _8625) + (-1 * balances[address(arg1)] * _8625) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8625) + 5000 / 10000 <= s:
                                        idx = idx + 1
                                        s = s - ((ext_call.return_data[0] * _8625) + (-1 * balances[address(arg1)] * _8625) + (-1 * (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 * _8625) + 5000 / 10000)
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _9292 + 32]
                                        idx = idx + 32
                                        continue 
                        revert with 0, 'SafeMath: subtraction overflow'
                    require 0 < mem[_5764]
                    if s + mem[_5764 + 32] < mem[_5764 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require 0 < mem[_5764]
                    mem[_5764 + 32] = s + mem[_5764 + 32]
                    require 0 < mem[_5764]
                    _8651 = mem[_5764 + 32]
                    require ext_code.size(sub_23bf2705Address)
                    staticcall sub_23bf2705Address.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8774 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8966 = mem[_8774]
                    if not mem[_8774]:
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5764]
                            if mem[(32 * idx) + _5764 + 32] > 0:
                                require idx < mem[_5764]
                                _11917 = mem[(32 * idx) + _5764 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5764 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11917
                            idx = idx + 1
                            continue 
                        _11590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11590] = 30
                        mem[_11590 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12280 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12281 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12281 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12421 = mem[_12281]
                            mem[_12280 + 100 len floor32(mem[_12281])] = mem[_12281 + 32 len floor32(mem[_12281])]
                            mem[_12280 + floor32(mem[_12281]) + -(mem[_12281] % 32) + 132 len mem[_12281] % 32] = mem[_12281 + -(mem[_12281] % 32) + floor32(mem[_12281]) + 64 len mem[_12281] % 32]
                            call address(arg1).mem[_12280 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12280 + 104 len _12421 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12280 + 210 len 22]
                            else:
                                mem[_12280 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12280 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12280 + ceil32(return_data.size) + 211 len 22]
                    else:
                        _9284 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9284] = 3
                        mem[_9284 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if 10^9 * _8651 / 10^9 != _8651:
                            revert with 0, ''
                        _9784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9784] = 26
                        mem[_9784 + 32] = 'SafeMath: division by zero'
                        if not _8966:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^9 * _8651 / _8966) + sub_b32b53ab[address(arg1)] < sub_b32b53ab[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 367
                        sub_b32b53ab[address(arg1)] += 10^9 * _8651 / _8966
                        idx = 0
                        while idx < mem[(4 * ceil32(return_data.size)) + 448]:
                            require idx < mem[_5764]
                            if mem[(32 * idx) + _5764 + 32] > 0:
                                require idx < mem[_5764]
                                _11923 = mem[(32 * idx) + _5764 + 32]
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                if mem[(32 * idx) + _5764 + 32] + uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) < uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < mem[(4 * ceil32(return_data.size)) + 448]
                                mem[0] = mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]
                                mem[32] = sha3(address(arg1), 364)
                                uint256(sub_c9997aa9[address(arg1)][mem[(32 * idx) + (4 * ceil32(return_data.size)) + 480]].field_0) += _11923
                            idx = idx + 1
                            continue 
                        _11592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11592] = 30
                        mem[_11592 + 32] = 'SafeMath: subtraction overflow'
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000 > ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[0] = address(arg1)
                        mem[32] = 366
                        balances[address(arg1)] = ext_call.return_data[0] - ((ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000)
                        if (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000:
                            _12287 = mem[64]
                            mem[mem[64] + 36] = address(arg2)
                            mem[mem[64] + 68] = (ext_call.return_data[0] * sub_df62497d) + (-1 * balances[address(arg1)] * sub_df62497d) + 5000 / 10000
                            _12288 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12288 + 32 len 4] = unknown_0xa9059cbb(?????)
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            if not ext_code.hash(address(arg1)):
                                revert with 0, 'SafeERC20: call to non-contract'
                            _12427 = mem[_12288]
                            mem[_12287 + 100 len floor32(mem[_12288])] = mem[_12288 + 32 len floor32(mem[_12288])]
                            mem[_12287 + floor32(mem[_12288]) + -(mem[_12288] % 32) + 132 len mem[_12288] % 32] = mem[_12288 + -(mem[_12288] % 32) + floor32(mem[_12288]) + 64 len mem[_12288] % 32]
                            call address(arg1).mem[_12287 + 100 len 4] with:
                                 gas gas_remaining wei
                                args mem[_12287 + 104 len _12427 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12287 + 210 len 22]
                            else:
                                mem[_12287 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_12287 + 132]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_12287 + ceil32(return_data.size) + 211 len 22]
}

function sub_9f7a3adf(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[100] = address(arg1)
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require stor362.length + 1 <= test266151307()
    mem[ceil32(return_data.size) + 96] = stor362.length + 1
    if not stor362.length + 1:
        require stor362.length + 1 <= test266151307()
        mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128] = stor362.length + 1
        mem[64] = ceil32(return_data.size) + (64 * stor362.length + 1) + 160
        if not stor362.length + 1:
            idx = 0
            while idx < stor362.length:
                require idx < mem[ceil32(return_data.size) + 96]
                mem[(32 * idx) + ceil32(return_data.size) + 128] = address(stor362[idx].field_0)
                require idx < mem[ceil32(return_data.size) + 96]
                mem[0] = address(stor362[idx].field_0)
                mem[32] = 367
                _5324 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5324] = 30
                mem[_5324 + 32] = 'SafeMath: subtraction overflow'
                if sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] > sub_b32b53ab[address(stor362[idx].field_0)]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _5324 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)]:
                    _5454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5454] = 3
                    mem[_5454 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    idx = idx + 1
                    continue 
                if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5467 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5467] = 3
                mem[_5467 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 >= 500 * 10^6:
                    require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 3
                mem[mem[64] + 68] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                idx = 32
                while idx < 3:
                    mem[idx + mem[64] + 68] = mem[idx + _5467 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + 96]
            mem[(32 * stor362.length) + ceil32(return_data.size) + 128] = sub_5d830fbeAddress
            require ext_code.size(sub_23bf2705Address)
            staticcall sub_23bf2705Address.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5284 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _5292 = mem[_5284]
            _5308 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5308] = 30
            mem[_5308 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber > lastBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            _5368 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5368] = 26
            mem[_5368 + 32] = 'SafeMath: division by zero'
            if not sub_2730bcb7:
                revert with 0, 'SafeMath: division by zero'
            _5464 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5464] = 30
            mem[_5464 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _5548 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5548] = 26
            mem[_5548 + 32] = 'SafeMath: division by zero'
            if not sub_2730bcb7:
                revert with 0, 'SafeMath: division by zero'
            if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                _5624 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5624] = 30
                mem[_5624 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - lastBlockNumber:
                    _5716 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5716] = 3
                    mem[_5716 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if not _5292:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _5978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5978] = 30
                        mem[_5978 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _6338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6338] = 3
                            mem[_6338 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _6603 = mem[64]
                            mem[mem[64]] = 64
                            _6655 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _6655:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_6603 + 32] = (32 * _6655) + 96
                            _11003 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_6603 + (32 * _6655) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_6603 + (32 * _6655) + 128 len 32 * _11003] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11003]
                            return memory
                              from mem[64]
                               len _6603 + (32 * _6655) + (32 * _11003) + -mem[64] + 128
                        if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6396 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6396] = 3
                        mem[_6396 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _6652 = mem[64]
                        mem[mem[64]] = 64
                        _6722 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _6722:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_6652 + 32] = (32 * _6722) + 96
                        _11000 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6652 + (32 * _6722) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6652 + (32 * _6722) + 128 len 32 * _11000] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11000]
                        return memory
                          from mem[64]
                           len _6652 + (32 * _6722) + (32 * _11000) + -mem[64] + 128
                    _5830 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5830] = 26
                    mem[_5830 + 32] = 'SafeMath: division by zero'
                    if not _5292:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / _5292) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _6248 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6248] = 30
                    mem[_6248 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (0 / _5292) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _6724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6724] = 3
                        mem[_6724 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _7059 = mem[64]
                        mem[mem[64]] = 64
                        _7160 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _7160:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_7059 + 32] = (32 * _7160) + 96
                        _11009 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_7059 + (32 * _7160) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_7059 + (32 * _7160) + 128 len 32 * _11009] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11009]
                        return memory
                          from mem[64]
                           len _7059 + (32 * _7160) + (32 * _11009) + -mem[64] + 128
                    if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6776] = 3
                    mem[_6776 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _7157 = mem[64]
                    mem[mem[64]] = 64
                    _7282 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _7282:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_7157 + 32] = (32 * _7282) + 96
                    _11006 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7157 + (32 * _7282) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7157 + (32 * _7282) + 128 len 32 * _11006] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11006]
                    return memory
                      from mem[64]
                       len _7157 + (32 * _7282) + (32 * _11006) + -mem[64] + 128
                if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5732 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5732] = 3
                mem[_5732 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5292:
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _6012 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6012] = 30
                    mem[_6012 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _6392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6392] = 3
                        mem[_6392 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _6650 = mem[64]
                        mem[mem[64]] = 64
                        _6719 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _6719:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_6650 + 32] = (32 * _6719) + 96
                        _10987 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6650 + (32 * _6719) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6650 + (32 * _6719) + 128 len 32 * _10987] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _10987]
                        return memory
                          from mem[64]
                           len _6650 + (32 * _6719) + (32 * _10987) + -mem[64] + 128
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6444] = 3
                    mem[_6444 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _6716 = mem[64]
                    mem[mem[64]] = 64
                    _6772 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6772:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6716 + 32] = (32 * _6772) + 96
                    _10984 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6716 + (32 * _6772) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6716 + (32 * _6772) + 128 len 32 * _10984] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _10984]
                    return memory
                      from mem[64]
                       len _6716 + (32 * _6772) + (32 * _10984) + -mem[64] + 128
                _5864 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5864] = 26
                mem[_5864 + 32] = 'SafeMath: division by zero'
                if not _5292:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6293 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6293] = 30
                mem[_6293 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6774 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6774] = 3
                    mem[_6774 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _7155 = mem[64]
                    mem[mem[64]] = 64
                    _7280 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _7280:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_7155 + 32] = (32 * _7280) + 96
                    _10993 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7155 + (32 * _7280) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7155 + (32 * _7280) + 128 len 32 * _10993] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _10993]
                    return memory
                      from mem[64]
                       len _7155 + (32 * _7280) + (32 * _10993) + -mem[64] + 128
                if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6829 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6829] = 3
                mem[_6829 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _7277 = mem[64]
                mem[mem[64]] = 64
                _7401 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7401:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7277 + 32] = (32 * _7401) + 96
                _10990 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7277 + (32 * _7401) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7277 + (32 * _7401) + 128 len 32 * _10990] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _10990]
                return memory
                  from mem[64]
                   len _7277 + (32 * _7401) + (32 * _10990) + -mem[64] + 128
            if not block.number - initialBlockNumber / sub_2730bcb7:
                if initialBlockNumber < 0:
                    revert with 0, 'SafeMath: addition overflow'
                _5697 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5697] = 30
                mem[_5697 + 32] = 'SafeMath: subtraction overflow'
                if initialBlockNumber > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                _5779 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5779] = 30
                mem[_5779 + 32] = 'SafeMath: subtraction overflow'
                if 1 > block.number - initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number + -initialBlockNumber - 1:
                    _6095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6095] = 30
                    mem[_6095 + 32] = 'SafeMath: subtraction overflow'
                    if lastBlockNumber > initialBlockNumber:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not initialBlockNumber - lastBlockNumber:
                        _6664 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6664] = 3
                        mem[_6664 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                        if not _5292:
                            if sub_a57f309a < sub_a57f309a:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = address(arg1)
                            mem[32] = 371
                            _7422 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7422] = 30
                            mem[_7422 + 32] = 'SafeMath: subtraction overflow'
                            if sub_3acf4148[address(arg1)] > sub_a57f309a:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                                _8307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8307] = 3
                                mem[_8307 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                                _8842 = mem[64]
                                mem[mem[64]] = 64
                                _8986 = mem[ceil32(return_data.size) + 96]
                                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                                idx = 0
                                s = ceil32(return_data.size) + 128
                                t = mem[64] + 96
                                while idx < _8986:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8842 + 32] = (32 * _8986) + 96
                                _11139 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                                mem[_8842 + (32 * _8986) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                                mem[_8842 + (32 * _8986) + 128 len 32 * _11139] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11139]
                                return memory
                                  from mem[64]
                                   len _8842 + (32 * _8986) + (32 * _11139) + -mem[64] + 128
                            if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8388 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8388] = 3
                            mem[_8388 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                            _8983 = mem[64]
                            mem[mem[64]] = 64
                            _9135 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9135:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8983 + 32] = (32 * _9135) + 96
                            _11136 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8983 + (32 * _9135) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8983 + (32 * _9135) + 128 len 32 * _11136] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11136]
                            return memory
                              from mem[64]
                               len _8983 + (32 * _9135) + (32 * _11136) + -mem[64] + 128
                        _6994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6994] = 26
                        mem[_6994 + 32] = 'SafeMath: division by zero'
                        if not _5292:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / _5292) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _8155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8155] = 30
                        mem[_8155 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (0 / _5292) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _9137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9137] = 3
                            mem[_9137 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _9745 = mem[64]
                            mem[mem[64]] = 64
                            _9867 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9867:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_9745 + 32] = (32 * _9867) + 96
                            _11145 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_9745 + (32 * _9867) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_9745 + (32 * _9867) + 128 len 32 * _11145] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11145]
                            return memory
                              from mem[64]
                               len _9745 + (32 * _9867) + (32 * _11145) + -mem[64] + 128
                        if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _9284 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9284] = 3
                        mem[_9284 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9864 = mem[64]
                        mem[mem[64]] = 64
                        _9996 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9996:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9864 + 32] = (32 * _9996) + 96
                        _11142 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9864 + (32 * _9996) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9864 + (32 * _9996) + 128 len 32 * _11142] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11142]
                        return memory
                          from mem[64]
                           len _9864 + (32 * _9996) + (32 * _11142) + -mem[64] + 128
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6729] = 3
                    mem[_6729 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _5292:
                        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _7518 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7518] = 30
                        mem[_7518 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8384] = 3
                            mem[_8384 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _8981 = mem[64]
                            mem[mem[64]] = 64
                            _9132 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9132:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8981 + 32] = (32 * _9132) + 96
                            _11123 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8981 + (32 * _9132) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8981 + (32 * _9132) + 128 len 32 * _11123] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11123]
                            return memory
                              from mem[64]
                               len _8981 + (32 * _9132) + (32 * _11123) + -mem[64] + 128
                        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _8474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8474] = 3
                        mem[_8474 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9129 = mem[64]
                        mem[mem[64]] = 64
                        _9280 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9280:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9129 + 32] = (32 * _9280) + 96
                        _11120 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9129 + (32 * _9280) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9129 + (32 * _9280) + 128 len 32 * _11120] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11120]
                        return memory
                          from mem[64]
                           len _9129 + (32 * _9280) + (32 * _11120) + -mem[64] + 128
                    _7072 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7072] = 26
                    mem[_7072 + 32] = 'SafeMath: division by zero'
                    if not _5292:
                        revert with 0, 'SafeMath: division by zero'
                    if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _8232 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8232] = 30
                    mem[_8232 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _9282 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9282] = 3
                        mem[_9282 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9862 = mem[64]
                        mem[mem[64]] = 64
                        _9994 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9994:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9862 + 32] = (32 * _9994) + 96
                        _11129 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9862 + (32 * _9994) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9862 + (32 * _9994) + 128 len 32 * _11129] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11129]
                        return memory
                          from mem[64]
                           len _9862 + (32 * _9994) + (32 * _11129) + -mem[64] + 128
                    if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _9404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9404] = 3
                    mem[_9404 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9991 = mem[64]
                    mem[mem[64]] = 64
                    _10126 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10126:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9991 + 32] = (32 * _10126) + 96
                    _11126 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9991 + (32 * _10126) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9991 + (32 * _10126) + 128 len 32 * _11126] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11126]
                    return memory
                      from mem[64]
                       len _9991 + (32 * _10126) + (32 * _11126) + -mem[64] + 128
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6139 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6139] = 30
                mem[_6139 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _6728 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6728] = 3
                    mem[_6728 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _5292:
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _7515 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7515] = 30
                        mem[_7515 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8380] = 3
                            mem[_8380 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _8977 = mem[64]
                            mem[mem[64]] = 64
                            _9126 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9126:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8977 + 32] = (32 * _9126) + 96
                            _11105 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8977 + (32 * _9126) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8977 + (32 * _9126) + 128 len 32 * _11105] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11105]
                            return memory
                              from mem[64]
                               len _8977 + (32 * _9126) + (32 * _11105) + -mem[64] + 128
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _8472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8472] = 3
                        mem[_8472 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9123 = mem[64]
                        mem[mem[64]] = 64
                        _9277 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9277:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9123 + 32] = (32 * _9277) + 96
                        _11102 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9123 + (32 * _9277) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9123 + (32 * _9277) + 128 len 32 * _11102] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11102]
                        return memory
                          from mem[64]
                           len _9123 + (32 * _9277) + (32 * _11102) + -mem[64] + 128
                    _7069 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7069] = 26
                    mem[_7069 + 32] = 'SafeMath: division by zero'
                    if not _5292:
                        revert with 0, 'SafeMath: division by zero'
                    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _8230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8230] = 30
                    mem[_8230 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _9279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9279] = 3
                        mem[_9279 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9858 = mem[64]
                        mem[mem[64]] = 64
                        _9989 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9989:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9858 + 32] = (32 * _9989) + 96
                        _11111 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9858 + (32 * _9989) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9858 + (32 * _9989) + 128 len 32 * _11111] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11111]
                        return memory
                          from mem[64]
                           len _9858 + (32 * _9989) + (32 * _11111) + -mem[64] + 128
                    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _9402 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9402] = 3
                    mem[_9402 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9986 = mem[64]
                    mem[mem[64]] = 64
                    _10123 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10123:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9986 + 32] = (32 * _10123) + 96
                    _11108 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9986 + (32 * _10123) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9986 + (32 * _10123) + 128 len 32 * _11108] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11108]
                    return memory
                      from mem[64]
                       len _9986 + (32 * _10123) + (32 * _11108) + -mem[64] + 128
                if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                _6779 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6779] = 3
                mem[_6779 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5292:
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7605 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7605] = 30
                    mem[_7605 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8468 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8468] = 3
                        mem[_8468 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9121 = mem[64]
                        mem[mem[64]] = 64
                        _9274 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9274:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9121 + 32] = (32 * _9274) + 96
                        _11089 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9121 + (32 * _9274) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9121 + (32 * _9274) + 128 len 32 * _11089] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11089]
                        return memory
                          from mem[64]
                           len _9121 + (32 * _9274) + (32 * _11089) + -mem[64] + 128
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8569] = 3
                    mem[_8569 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9271 = mem[64]
                    mem[mem[64]] = 64
                    _9398 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9398:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9271 + 32] = (32 * _9398) + 96
                    _11086 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9271 + (32 * _9398) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9271 + (32 * _9398) + 128 len 32 * _11086] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11086]
                    return memory
                      from mem[64]
                       len _9271 + (32 * _9398) + (32 * _11086) + -mem[64] + 128
                _7171 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7171] = 26
                mem[_7171 + 32] = 'SafeMath: division by zero'
                if not _5292:
                    revert with 0, 'SafeMath: division by zero'
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8302 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8302] = 30
                mem[_8302 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9400] = 3
                    mem[_9400 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9984 = mem[64]
                    mem[mem[64]] = 64
                    _10121 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10121:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9984 + 32] = (32 * _10121) + 96
                    _11095 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9984 + (32 * _10121) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9984 + (32 * _10121) + 128 len 32 * _11095] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11095]
                    return memory
                      from mem[64]
                       len _9984 + (32 * _10121) + (32 * _11095) + -mem[64] + 128
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9501 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9501] = 3
                mem[_9501 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10118 = mem[64]
                mem[mem[64]] = 64
                _10229 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10229:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10118 + 32] = (32 * _10229) + 96
                _11092 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10118 + (32 * _10229) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10118 + (32 * _10229) + 128 len 32 * _11092] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11092]
                return memory
                  from mem[64]
                   len _10118 + (32 * _10229) + (32 * _11092) + -mem[64] + 128
            if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 'SafeMath: addition overflow'
            _5706 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5706] = 30
            mem[_5706 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _5802 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5802] = 30
            mem[_5802 + 32] = 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
                _6138 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6138] = 30
                mem[_6138 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                    _6727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6727] = 3
                    mem[_6727 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if not _5292:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _7510 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7510] = 30
                        mem[_7510 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8374 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8374] = 3
                            mem[_8374 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _8968 = mem[64]
                            mem[mem[64]] = 64
                            _9116 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9116:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8968 + 32] = (32 * _9116) + 96
                            _11069 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8968 + (32 * _9116) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8968 + (32 * _9116) + 128 len 32 * _11069] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11069]
                            return memory
                              from mem[64]
                               len _8968 + (32 * _9116) + (32 * _11069) + -mem[64] + 128
                        if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _8466 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8466] = 3
                        mem[_8466 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9113 = mem[64]
                        mem[mem[64]] = 64
                        _9268 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9268:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9113 + 32] = (32 * _9268) + 96
                        _11066 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9113 + (32 * _9268) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9113 + (32 * _9268) + 128 len 32 * _11066] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11066]
                        return memory
                          from mem[64]
                           len _9113 + (32 * _9268) + (32 * _11066) + -mem[64] + 128
                    _7066 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7066] = 26
                    mem[_7066 + 32] = 'SafeMath: division by zero'
                    if not _5292:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / _5292) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _8225 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8225] = 30
                    mem[_8225 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (0 / _5292) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _9270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9270] = 3
                        mem[_9270 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9850 = mem[64]
                        mem[mem[64]] = 64
                        _9980 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9980:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9850 + 32] = (32 * _9980) + 96
                        _11075 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9850 + (32 * _9980) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9850 + (32 * _9980) + 128 len 32 * _11075] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11075]
                        return memory
                          from mem[64]
                           len _9850 + (32 * _9980) + (32 * _11075) + -mem[64] + 128
                    if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _9397 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9397] = 3
                    mem[_9397 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9977 = mem[64]
                    mem[mem[64]] = 64
                    _10115 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10115:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9977 + 32] = (32 * _10115) + 96
                    _11072 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9977 + (32 * _10115) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9977 + (32 * _10115) + 128 len 32 * _11072] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11072]
                    return memory
                      from mem[64]
                       len _9977 + (32 * _10115) + (32 * _11072) + -mem[64] + 128
                if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6778 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6778] = 3
                mem[_6778 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5292:
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7600] = 30
                    mem[_7600 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8462] = 3
                        mem[_8462 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9111 = mem[64]
                        mem[mem[64]] = 64
                        _9265 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9265:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9111 + 32] = (32 * _9265) + 96
                        _11053 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9111 + (32 * _9265) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9111 + (32 * _9265) + 128 len 32 * _11053] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11053]
                        return memory
                          from mem[64]
                           len _9111 + (32 * _9265) + (32 * _11053) + -mem[64] + 128
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8562 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8562] = 3
                    mem[_8562 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9262 = mem[64]
                    mem[mem[64]] = 64
                    _9393 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9393:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9262 + 32] = (32 * _9393) + 96
                    _11050 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9262 + (32 * _9393) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9262 + (32 * _9393) + 128 len 32 * _11050] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11050]
                    return memory
                      from mem[64]
                       len _9262 + (32 * _9393) + (32 * _11050) + -mem[64] + 128
                _7166 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7166] = 26
                mem[_7166 + 32] = 'SafeMath: division by zero'
                if not _5292:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8298 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8298] = 30
                mem[_8298 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9395] = 3
                    mem[_9395 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9975 = mem[64]
                    mem[mem[64]] = 64
                    _10113 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10113:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9975 + 32] = (32 * _10113) + 96
                    _11059 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9975 + (32 * _10113) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9975 + (32 * _10113) + 128 len 32 * _11059] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11059]
                    return memory
                      from mem[64]
                       len _9975 + (32 * _10113) + (32 * _11059) + -mem[64] + 128
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9494 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9494] = 3
                mem[_9494 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10110 = mem[64]
                mem[mem[64]] = 64
                _10225 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10225:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10110 + 32] = (32 * _10225) + 96
                _11056 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10110 + (32 * _10225) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10110 + (32 * _10225) + 128 len 32 * _11056] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11056]
                return memory
                  from mem[64]
                   len _10110 + (32 * _10225) + (32 * _11056) + -mem[64] + 128
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6168 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6168] = 30
            mem[_6168 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                _6777 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6777] = 3
                mem[_6777 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5292:
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7597 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7597] = 30
                    mem[_7597 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8458 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8458] = 3
                        mem[_8458 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9107 = mem[64]
                        mem[mem[64]] = 64
                        _9259 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9259:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9107 + 32] = (32 * _9259) + 96
                        _11035 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9107 + (32 * _9259) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9107 + (32 * _9259) + 128 len 32 * _11035] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11035]
                        return memory
                          from mem[64]
                           len _9107 + (32 * _9259) + (32 * _11035) + -mem[64] + 128
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8560 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8560] = 3
                    mem[_8560 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9256 = mem[64]
                    mem[mem[64]] = 64
                    _9390 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9390:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9256 + 32] = (32 * _9390) + 96
                    _11032 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9256 + (32 * _9390) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9256 + (32 * _9390) + 128 len 32 * _11032] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11032]
                    return memory
                      from mem[64]
                       len _9256 + (32 * _9390) + (32 * _11032) + -mem[64] + 128
                _7163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7163] = 26
                mem[_7163 + 32] = 'SafeMath: division by zero'
                if not _5292:
                    revert with 0, 'SafeMath: division by zero'
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8296 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8296] = 30
                mem[_8296 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9392] = 3
                    mem[_9392 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9971 = mem[64]
                    mem[mem[64]] = 64
                    _10108 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10108:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9971 + 32] = (32 * _10108) + 96
                    _11041 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9971 + (32 * _10108) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9971 + (32 * _10108) + 128 len 32 * _11041] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11041]
                    return memory
                      from mem[64]
                       len _9971 + (32 * _10108) + (32 * _11041) + -mem[64] + 128
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9492 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9492] = 3
                mem[_9492 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10105 = mem[64]
                mem[mem[64]] = 64
                _10222 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10222:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10105 + 32] = (32 * _10222) + 96
                _11038 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10105 + (32 * _10222) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10105 + (32 * _10222) + 128 len 32 * _11038] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11038]
                return memory
                  from mem[64]
                   len _10105 + (32 * _10222) + (32 * _11038) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6835 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6835] = 3
            mem[_6835 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5292:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7694 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7694] = 30
                mem[_7694 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8556] = 3
                    mem[_8556 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9254 = mem[64]
                    mem[mem[64]] = 64
                    _9387 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9387:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9254 + 32] = (32 * _9387) + 96
                    _11019 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9254 + (32 * _9387) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9254 + (32 * _9387) + 128 len 32 * _11019] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11019]
                    return memory
                      from mem[64]
                       len _9254 + (32 * _9387) + (32 * _11019) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8672 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8672] = 3
                mem[_8672 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9384 = mem[64]
                mem[mem[64]] = 64
                _9488 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9488:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9384 + 32] = (32 * _9488) + 96
                _11016 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9384 + (32 * _9488) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9384 + (32 * _9488) + 128 len 32 * _11016] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11016]
                return memory
                  from mem[64]
                   len _9384 + (32 * _9488) + (32 * _11016) + -mem[64] + 128
            _7284 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7284] = 26
            mem[_7284 + 32] = 'SafeMath: division by zero'
            if not _5292:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8369 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8369] = 30
            mem[_8369 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9490 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9490] = 3
                mem[_9490 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10103 = mem[64]
                mem[mem[64]] = 64
                _10220 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10220:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10103 + 32] = (32 * _10220) + 96
                _11025 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10103 + (32 * _10220) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10103 + (32 * _10220) + 128 len 32 * _11025] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11025]
                return memory
                  from mem[64]
                   len _10103 + (32 * _10220) + (32 * _11025) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9597 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9597] = 3
            mem[_9597 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5292 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10217 = mem[64]
            mem[mem[64]] = 64
            _10293 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10293:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10217 + 32] = (32 * _10293) + 96
            _11022 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10217 + (32 * _10293) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10217 + (32 * _10293) + 128 len 32 * _11022] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11022]
            return memory
              from mem[64]
               len _10217 + (32 * _10293) + (32 * _11022) + -mem[64] + 128
        mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * stor362.length + 1] = call.data[calldata.size len 32 * stor362.length + 1]
        idx = 0
        while idx < stor362.length:
            require idx < mem[ceil32(return_data.size) + 96]
            mem[(32 * idx) + ceil32(return_data.size) + 128] = address(stor362[idx].field_0)
            require idx < mem[ceil32(return_data.size) + 96]
            mem[0] = address(stor362[idx].field_0)
            mem[32] = 367
            _5325 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5325] = 30
            mem[_5325 + 32] = 'SafeMath: subtraction overflow'
            if sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] > sub_b32b53ab[address(stor362[idx].field_0)]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _5325 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)]:
                _5457 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5457] = 3
                mem[_5457 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                idx = idx + 1
                continue 
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5471 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5471] = 3
            mem[_5471 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 >= 500 * 10^6:
                require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                idx = idx + 1
                continue 
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 3
            mem[mem[64] + 68] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            idx = 32
            while idx < 3:
                mem[idx + mem[64] + 68] = mem[idx + _5471 + 32]
                idx = idx + 32
                continue 
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + 96]
        mem[(32 * stor362.length) + ceil32(return_data.size) + 128] = sub_5d830fbeAddress
        require ext_code.size(sub_23bf2705Address)
        staticcall sub_23bf2705Address.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _5286 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _5294 = mem[_5286]
        _5312 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5312] = 30
        mem[_5312 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber > lastBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        _5373 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5373] = 26
        mem[_5373 + 32] = 'SafeMath: division by zero'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        _5468 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5468] = 30
        mem[_5468 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        _5553 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5553] = 26
        mem[_5553 + 32] = 'SafeMath: division by zero'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            _5626 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5626] = 30
            mem[_5626 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - lastBlockNumber:
                _5720 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5720] = 3
                mem[_5720 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if not _5294:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _5987 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5987] = 30
                    mem[_5987 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _6352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6352] = 3
                        mem[_6352 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _6616 = mem[64]
                        mem[mem[64]] = 64
                        _6672 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _6672:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_6616 + 32] = (32 * _6672) + 96
                        _11187 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6616 + (32 * _6672) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6616 + (32 * _6672) + 128 len 32 * _11187] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11187]
                        return memory
                          from mem[64]
                           len _6616 + (32 * _6672) + (32 * _11187) + -mem[64] + 128
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6409 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6409] = 3
                    mem[_6409 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _6669 = mem[64]
                    mem[mem[64]] = 64
                    _6736 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6736:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6669 + 32] = (32 * _6736) + 96
                    _11184 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6669 + (32 * _6736) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6669 + (32 * _6736) + 128 len 32 * _11184] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11184]
                    return memory
                      from mem[64]
                       len _6669 + (32 * _6736) + (32 * _11184) + -mem[64] + 128
                _5839 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5839] = 26
                mem[_5839 + 32] = 'SafeMath: division by zero'
                if not _5294:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _5294) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6260 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6260] = 30
                mem[_6260 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _5294) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6738 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6738] = 3
                    mem[_6738 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _7084 = mem[64]
                    mem[mem[64]] = 64
                    _7191 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _7191:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_7084 + 32] = (32 * _7191) + 96
                    _11193 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7084 + (32 * _7191) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7084 + (32 * _7191) + 128 len 32 * _11193] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11193]
                    return memory
                      from mem[64]
                       len _7084 + (32 * _7191) + (32 * _11193) + -mem[64] + 128
                if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6790 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6790] = 3
                mem[_6790 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _7188 = mem[64]
                mem[mem[64]] = 64
                _7313 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7313:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7188 + 32] = (32 * _7313) + 96
                _11190 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7188 + (32 * _7313) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7188 + (32 * _7313) + 128 len 32 * _11190] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11190]
                return memory
                  from mem[64]
                   len _7188 + (32 * _7313) + (32 * _11190) + -mem[64] + 128
            if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5737 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5737] = 3
            mem[_5737 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5294:
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6020 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6020] = 30
                mem[_6020 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6405 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6405] = 3
                    mem[_6405 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _6667 = mem[64]
                    mem[mem[64]] = 64
                    _6733 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6733:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6667 + 32] = (32 * _6733) + 96
                    _11171 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6667 + (32 * _6733) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6667 + (32 * _6733) + 128 len 32 * _11171] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11171]
                    return memory
                      from mem[64]
                       len _6667 + (32 * _6733) + (32 * _11171) + -mem[64] + 128
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6457 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6457] = 3
                mem[_6457 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _6730 = mem[64]
                mem[mem[64]] = 64
                _6786 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _6786:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_6730 + 32] = (32 * _6786) + 96
                _11168 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6730 + (32 * _6786) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6730 + (32 * _6786) + 128 len 32 * _11168] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11168]
                return memory
                  from mem[64]
                   len _6730 + (32 * _6786) + (32 * _11168) + -mem[64] + 128
            _5874 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5874] = 26
            mem[_5874 + 32] = 'SafeMath: division by zero'
            if not _5294:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _6304 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6304] = 30
            mem[_6304 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _6788 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6788] = 3
                mem[_6788 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _7186 = mem[64]
                mem[mem[64]] = 64
                _7311 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7311:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7186 + 32] = (32 * _7311) + 96
                _11177 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7186 + (32 * _7311) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7186 + (32 * _7311) + 128 len 32 * _11177] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11177]
                return memory
                  from mem[64]
                   len _7186 + (32 * _7311) + (32 * _11177) + -mem[64] + 128
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6848 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6848] = 3
            mem[_6848 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _7308 = mem[64]
            mem[mem[64]] = 64
            _7426 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _7426:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_7308 + 32] = (32 * _7426) + 96
            _11174 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7308 + (32 * _7426) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7308 + (32 * _7426) + 128 len 32 * _11174] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11174]
            return memory
              from mem[64]
               len _7308 + (32 * _7426) + (32 * _11174) + -mem[64] + 128
        if not block.number - initialBlockNumber / sub_2730bcb7:
            if initialBlockNumber < 0:
                revert with 0, 'SafeMath: addition overflow'
            _5699 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5699] = 30
            mem[_5699 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _5785 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5785] = 30
            mem[_5785 + 32] = 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber - 1:
                _6107 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6107] = 30
                mem[_6107 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    _6681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6681] = 3
                    mem[_6681 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if not _5294:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _7447 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7447] = 30
                        mem[_7447 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8326] = 3
                            mem[_8326 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _8878 = mem[64]
                            mem[mem[64]] = 64
                            _9023 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9023:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8878 + 32] = (32 * _9023) + 96
                            _11323 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8878 + (32 * _9023) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8878 + (32 * _9023) + 128 len 32 * _11323] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11323]
                            return memory
                              from mem[64]
                               len _8878 + (32 * _9023) + (32 * _11323) + -mem[64] + 128
                        if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _8410 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8410] = 3
                        mem[_8410 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9020 = mem[64]
                        mem[mem[64]] = 64
                        _9173 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9173:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9020 + 32] = (32 * _9173) + 96
                        _11320 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9020 + (32 * _9173) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9020 + (32 * _9173) + 128 len 32 * _11320] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11320]
                        return memory
                          from mem[64]
                           len _9020 + (32 * _9173) + (32 * _11320) + -mem[64] + 128
                    _7013 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7013] = 26
                    mem[_7013 + 32] = 'SafeMath: division by zero'
                    if not _5294:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / _5294) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _8175 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8175] = 30
                    mem[_8175 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (0 / _5294) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _9175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9175] = 3
                        mem[_9175 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9775 = mem[64]
                        mem[mem[64]] = 64
                        _9899 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9899:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9775 + 32] = (32 * _9899) + 96
                        _11329 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9775 + (32 * _9899) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9775 + (32 * _9899) + 128 len 32 * _11329] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11329]
                        return memory
                          from mem[64]
                           len _9775 + (32 * _9899) + (32 * _11329) + -mem[64] + 128
                    if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _9317 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9317] = 3
                    mem[_9317 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9896 = mem[64]
                    mem[mem[64]] = 64
                    _10030 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10030:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9896 + 32] = (32 * _10030) + 96
                    _11326 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9896 + (32 * _10030) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9896 + (32 * _10030) + 128 len 32 * _11326] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11326]
                    return memory
                      from mem[64]
                       len _9896 + (32 * _10030) + (32 * _11326) + -mem[64] + 128
                if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6743 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6743] = 3
                mem[_6743 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5294:
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7541 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7541] = 30
                    mem[_7541 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8406 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8406] = 3
                        mem[_8406 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9018 = mem[64]
                        mem[mem[64]] = 64
                        _9170 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9170:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9018 + 32] = (32 * _9170) + 96
                        _11307 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9018 + (32 * _9170) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9018 + (32 * _9170) + 128 len 32 * _11307] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11307]
                        return memory
                          from mem[64]
                           len _9018 + (32 * _9170) + (32 * _11307) + -mem[64] + 128
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8499 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8499] = 3
                    mem[_8499 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9167 = mem[64]
                    mem[mem[64]] = 64
                    _9313 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9313:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9167 + 32] = (32 * _9313) + 96
                    _11304 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9167 + (32 * _9313) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9167 + (32 * _9313) + 128 len 32 * _11304] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11304]
                    return memory
                      from mem[64]
                       len _9167 + (32 * _9313) + (32 * _11304) + -mem[64] + 128
                _7097 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7097] = 26
                mem[_7097 + 32] = 'SafeMath: division by zero'
                if not _5294:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8251 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8251] = 30
                mem[_8251 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9315] = 3
                    mem[_9315 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9894 = mem[64]
                    mem[mem[64]] = 64
                    _10028 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10028:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9894 + 32] = (32 * _10028) + 96
                    _11313 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9894 + (32 * _10028) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9894 + (32 * _10028) + 128 len 32 * _11313] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11313]
                    return memory
                      from mem[64]
                       len _9894 + (32 * _10028) + (32 * _11313) + -mem[64] + 128
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9430 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9430] = 3
                mem[_9430 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10025 = mem[64]
                mem[mem[64]] = 64
                _10155 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10155:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10025 + 32] = (32 * _10155) + 96
                _11310 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10025 + (32 * _10155) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10025 + (32 * _10155) + 128 len 32 * _11310] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11310]
                return memory
                  from mem[64]
                   len _10025 + (32 * _10155) + (32 * _11310) + -mem[64] + 128
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6147 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6147] = 30
            mem[_6147 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber - lastBlockNumber:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                _6742 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6742] = 3
                mem[_6742 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5294:
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7538 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7538] = 30
                    mem[_7538 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8402] = 3
                        mem[_8402 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9014 = mem[64]
                        mem[mem[64]] = 64
                        _9164 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9164:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9014 + 32] = (32 * _9164) + 96
                        _11289 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9014 + (32 * _9164) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9014 + (32 * _9164) + 128 len 32 * _11289] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11289]
                        return memory
                          from mem[64]
                           len _9014 + (32 * _9164) + (32 * _11289) + -mem[64] + 128
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8497 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8497] = 3
                    mem[_8497 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9161 = mem[64]
                    mem[mem[64]] = 64
                    _9310 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9310:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9161 + 32] = (32 * _9310) + 96
                    _11286 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9161 + (32 * _9310) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9161 + (32 * _9310) + 128 len 32 * _11286] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11286]
                    return memory
                      from mem[64]
                       len _9161 + (32 * _9310) + (32 * _11286) + -mem[64] + 128
                _7094 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7094] = 26
                mem[_7094 + 32] = 'SafeMath: division by zero'
                if not _5294:
                    revert with 0, 'SafeMath: division by zero'
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8249 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8249] = 30
                mem[_8249 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9312 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9312] = 3
                    mem[_9312 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9890 = mem[64]
                    mem[mem[64]] = 64
                    _10023 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10023:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9890 + 32] = (32 * _10023) + 96
                    _11295 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9890 + (32 * _10023) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9890 + (32 * _10023) + 128 len 32 * _11295] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11295]
                    return memory
                      from mem[64]
                       len _9890 + (32 * _10023) + (32 * _11295) + -mem[64] + 128
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9428 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9428] = 3
                mem[_9428 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10020 = mem[64]
                mem[mem[64]] = 64
                _10152 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10152:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10020 + 32] = (32 * _10152) + 96
                _11292 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10020 + (32 * _10152) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10020 + (32 * _10152) + 128 len 32 * _11292] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11292]
                return memory
                  from mem[64]
                   len _10020 + (32 * _10152) + (32 * _11292) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6793 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6793] = 3
            mem[_6793 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5294:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7630 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7630] = 30
                mem[_7630 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8493] = 3
                    mem[_8493 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9159 = mem[64]
                    mem[mem[64]] = 64
                    _9307 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9307:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9159 + 32] = (32 * _9307) + 96
                    _11273 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9159 + (32 * _9307) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9159 + (32 * _9307) + 128 len 32 * _11273] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11273]
                    return memory
                      from mem[64]
                       len _9159 + (32 * _9307) + (32 * _11273) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8598 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8598] = 3
                mem[_8598 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9304 = mem[64]
                mem[mem[64]] = 64
                _9424 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9424:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9304 + 32] = (32 * _9424) + 96
                _11270 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9304 + (32 * _9424) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9304 + (32 * _9424) + 128 len 32 * _11270] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11270]
                return memory
                  from mem[64]
                   len _9304 + (32 * _9424) + (32 * _11270) + -mem[64] + 128
            _7202 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7202] = 26
            mem[_7202 + 32] = 'SafeMath: division by zero'
            if not _5294:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8321 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8321] = 30
            mem[_8321 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9426 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9426] = 3
                mem[_9426 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10018 = mem[64]
                mem[mem[64]] = 64
                _10150 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10150:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10018 + 32] = (32 * _10150) + 96
                _11279 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10018 + (32 * _10150) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10018 + (32 * _10150) + 128 len 32 * _11279] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11279]
                return memory
                  from mem[64]
                   len _10018 + (32 * _10150) + (32 * _11279) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9528 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9528] = 3
            mem[_9528 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10147 = mem[64]
            mem[mem[64]] = 64
            _10248 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10248:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10147 + 32] = (32 * _10248) + 96
            _11276 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10147 + (32 * _10248) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10147 + (32 * _10248) + 128 len 32 * _11276] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11276]
            return memory
              from mem[64]
               len _10147 + (32 * _10248) + (32 * _11276) + -mem[64] + 128
        if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 'SafeMath: addition overflow'
        _5709 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5709] = 30
        mem[_5709 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        _5809 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5809] = 30
        mem[_5809 + 32] = 'SafeMath: subtraction overflow'
        if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
            _6146 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6146] = 30
            mem[_6146 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                _6741 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6741] = 3
                mem[_6741 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if not _5294:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7533 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7533] = 30
                    mem[_7533 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8396 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8396] = 3
                        mem[_8396 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9005 = mem[64]
                        mem[mem[64]] = 64
                        _9154 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9154:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9005 + 32] = (32 * _9154) + 96
                        _11253 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9005 + (32 * _9154) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9005 + (32 * _9154) + 128 len 32 * _11253] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11253]
                        return memory
                          from mem[64]
                           len _9005 + (32 * _9154) + (32 * _11253) + -mem[64] + 128
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8491 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8491] = 3
                    mem[_8491 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9151 = mem[64]
                    mem[mem[64]] = 64
                    _9301 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9301:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9151 + 32] = (32 * _9301) + 96
                    _11250 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9151 + (32 * _9301) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9151 + (32 * _9301) + 128 len 32 * _11250] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11250]
                    return memory
                      from mem[64]
                       len _9151 + (32 * _9301) + (32 * _11250) + -mem[64] + 128
                _7091 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7091] = 26
                mem[_7091 + 32] = 'SafeMath: division by zero'
                if not _5294:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _5294) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8244 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8244] = 30
                mem[_8244 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _5294) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9303] = 3
                    mem[_9303 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9882 = mem[64]
                    mem[mem[64]] = 64
                    _10014 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10014:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9882 + 32] = (32 * _10014) + 96
                    _11259 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9882 + (32 * _10014) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9882 + (32 * _10014) + 128 len 32 * _11259] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11259]
                    return memory
                      from mem[64]
                       len _9882 + (32 * _10014) + (32 * _11259) + -mem[64] + 128
                if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9423 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9423] = 3
                mem[_9423 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10011 = mem[64]
                mem[mem[64]] = 64
                _10144 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10144:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10011 + 32] = (32 * _10144) + 96
                _11256 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10011 + (32 * _10144) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10011 + (32 * _10144) + 128 len 32 * _11256] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11256]
                return memory
                  from mem[64]
                   len _10011 + (32 * _10144) + (32 * _11256) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6792 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6792] = 3
            mem[_6792 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5294:
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7625 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7625] = 30
                mem[_7625 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8487 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8487] = 3
                    mem[_8487 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9149 = mem[64]
                    mem[mem[64]] = 64
                    _9298 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9298:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9149 + 32] = (32 * _9298) + 96
                    _11237 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9149 + (32 * _9298) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9149 + (32 * _9298) + 128 len 32 * _11237] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11237]
                    return memory
                      from mem[64]
                       len _9149 + (32 * _9298) + (32 * _11237) + -mem[64] + 128
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8591 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8591] = 3
                mem[_8591 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9295 = mem[64]
                mem[mem[64]] = 64
                _9419 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9419:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9295 + 32] = (32 * _9419) + 96
                _11234 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9295 + (32 * _9419) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9295 + (32 * _9419) + 128 len 32 * _11234] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11234]
                return memory
                  from mem[64]
                   len _9295 + (32 * _9419) + (32 * _11234) + -mem[64] + 128
            _7197 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7197] = 26
            mem[_7197 + 32] = 'SafeMath: division by zero'
            if not _5294:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8317 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8317] = 30
            mem[_8317 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9421 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9421] = 3
                mem[_9421 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10009 = mem[64]
                mem[mem[64]] = 64
                _10142 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10142:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10009 + 32] = (32 * _10142) + 96
                _11243 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10009 + (32 * _10142) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10009 + (32 * _10142) + 128 len 32 * _11243] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11243]
                return memory
                  from mem[64]
                   len _10009 + (32 * _10142) + (32 * _11243) + -mem[64] + 128
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9521 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9521] = 3
            mem[_9521 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10139 = mem[64]
            mem[mem[64]] = 64
            _10244 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10244:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10139 + 32] = (32 * _10244) + 96
            _11240 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10139 + (32 * _10244) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10139 + (32 * _10244) + 128 len 32 * _11240] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11240]
            return memory
              from mem[64]
               len _10139 + (32 * _10244) + (32 * _11240) + -mem[64] + 128
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _6176 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6176] = 30
        mem[_6176 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6791 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6791] = 3
            mem[_6791 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5294:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7622 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7622] = 30
                mem[_7622 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8483 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8483] = 3
                    mem[_8483 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9145 = mem[64]
                    mem[mem[64]] = 64
                    _9292 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9292:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9145 + 32] = (32 * _9292) + 96
                    _11219 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9145 + (32 * _9292) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9145 + (32 * _9292) + 128 len 32 * _11219] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11219]
                    return memory
                      from mem[64]
                       len _9145 + (32 * _9292) + (32 * _11219) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8589 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8589] = 3
                mem[_8589 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9289 = mem[64]
                mem[mem[64]] = 64
                _9416 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9416:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9289 + 32] = (32 * _9416) + 96
                _11216 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9289 + (32 * _9416) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9289 + (32 * _9416) + 128 len 32 * _11216] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11216]
                return memory
                  from mem[64]
                   len _9289 + (32 * _9416) + (32 * _11216) + -mem[64] + 128
            _7194 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7194] = 26
            mem[_7194 + 32] = 'SafeMath: division by zero'
            if not _5294:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8315 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8315] = 30
            mem[_8315 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9418 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9418] = 3
                mem[_9418 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10005 = mem[64]
                mem[mem[64]] = 64
                _10137 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10137:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10005 + 32] = (32 * _10137) + 96
                _11225 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10005 + (32 * _10137) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10005 + (32 * _10137) + 128 len 32 * _11225] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11225]
                return memory
                  from mem[64]
                   len _10005 + (32 * _10137) + (32 * _11225) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9519 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9519] = 3
            mem[_9519 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10134 = mem[64]
            mem[mem[64]] = 64
            _10241 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10241:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10134 + 32] = (32 * _10241) + 96
            _11222 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10134 + (32 * _10241) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10134 + (32 * _10241) + 128 len 32 * _11222] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11222]
            return memory
              from mem[64]
               len _10134 + (32 * _10241) + (32 * _11222) + -mem[64] + 128
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        _6854 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6854] = 3
        mem[_6854 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5294:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _7724 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7724] = 30
            mem[_7724 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _8585 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8585] = 3
                mem[_8585 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9287 = mem[64]
                mem[mem[64]] = 64
                _9413 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9413:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9287 + 32] = (32 * _9413) + 96
                _11203 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9287 + (32 * _9413) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9287 + (32 * _9413) + 128 len 32 * _11203] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11203]
                return memory
                  from mem[64]
                   len _9287 + (32 * _9413) + (32 * _11203) + -mem[64] + 128
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _8706 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8706] = 3
            mem[_8706 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _9410 = mem[64]
            mem[mem[64]] = 64
            _9515 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9515:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9410 + 32] = (32 * _9515) + 96
            _11200 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9410 + (32 * _9515) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9410 + (32 * _9515) + 128 len 32 * _11200] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11200]
            return memory
              from mem[64]
               len _9410 + (32 * _9515) + (32 * _11200) + -mem[64] + 128
        _7315 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7315] = 26
        mem[_7315 + 32] = 'SafeMath: division by zero'
        if not _5294:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _8391 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8391] = 30
        mem[_8391 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _9517 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9517] = 3
            mem[_9517 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _10132 = mem[64]
            mem[mem[64]] = 64
            _10239 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10239:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10132 + 32] = (32 * _10239) + 96
            _11209 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10132 + (32 * _10239) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10132 + (32 * _10239) + 128 len 32 * _11209] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11209]
            return memory
              from mem[64]
               len _10132 + (32 * _10239) + (32 * _11209) + -mem[64] + 128
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _9627 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9627] = 3
        mem[_9627 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5294 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _10236 = mem[64]
        mem[mem[64]] = 64
        _10306 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10306:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10236 + 32] = (32 * _10306) + 96
        _11206 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10236 + (32 * _10306) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10236 + (32 * _10306) + 128 len 32 * _11206] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11206]
        return memory
          from mem[64]
           len _10236 + (32 * _10306) + (32 * _11206) + -mem[64] + 128
    mem[ceil32(return_data.size) + 128 len 32 * stor362.length + 1] = call.data[calldata.size len 32 * stor362.length + 1]
    require stor362.length + 1 <= test266151307()
    mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128] = stor362.length + 1
    mem[64] = ceil32(return_data.size) + (64 * stor362.length + 1) + 160
    if not stor362.length + 1:
        idx = 0
        while idx < stor362.length:
            require idx < mem[ceil32(return_data.size) + 96]
            mem[(32 * idx) + ceil32(return_data.size) + 128] = address(stor362[idx].field_0)
            require idx < mem[ceil32(return_data.size) + 96]
            mem[0] = address(stor362[idx].field_0)
            mem[32] = 367
            _5326 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5326] = 30
            mem[_5326 + 32] = 'SafeMath: subtraction overflow'
            if sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] > sub_b32b53ab[address(stor362[idx].field_0)]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _5326 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)]:
                _5460 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5460] = 3
                mem[_5460 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                idx = idx + 1
                continue 
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5475 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5475] = 3
            mem[_5475 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 >= 500 * 10^6:
                require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                idx = idx + 1
                continue 
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 3
            mem[mem[64] + 68] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            idx = 32
            while idx < 3:
                mem[idx + mem[64] + 68] = mem[idx + _5475 + 32]
                idx = idx + 32
                continue 
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + 96]
        mem[(32 * stor362.length) + ceil32(return_data.size) + 128] = sub_5d830fbeAddress
        require ext_code.size(sub_23bf2705Address)
        staticcall sub_23bf2705Address.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _5288 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _5296 = mem[_5288]
        _5316 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5316] = 30
        mem[_5316 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber > lastBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        _5378 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5378] = 26
        mem[_5378 + 32] = 'SafeMath: division by zero'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        _5472 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5472] = 30
        mem[_5472 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        _5558 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5558] = 26
        mem[_5558 + 32] = 'SafeMath: division by zero'
        if not sub_2730bcb7:
            revert with 0, 'SafeMath: division by zero'
        if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            _5628 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5628] = 30
            mem[_5628 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - lastBlockNumber:
                _5724 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5724] = 3
                mem[_5724 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if not _5296:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _5996 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5996] = 30
                    mem[_5996 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _6366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6366] = 3
                        mem[_6366 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _6629 = mem[64]
                        mem[mem[64]] = 64
                        _6689 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _6689:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_6629 + 32] = (32 * _6689) + 96
                        _11371 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6629 + (32 * _6689) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_6629 + (32 * _6689) + 128 len 32 * _11371] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11371]
                        return memory
                          from mem[64]
                           len _6629 + (32 * _6689) + (32 * _11371) + -mem[64] + 128
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _6422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6422] = 3
                    mem[_6422 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _6686 = mem[64]
                    mem[mem[64]] = 64
                    _6750 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6750:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6686 + 32] = (32 * _6750) + 96
                    _11368 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6686 + (32 * _6750) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6686 + (32 * _6750) + 128 len 32 * _11368] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11368]
                    return memory
                      from mem[64]
                       len _6686 + (32 * _6750) + (32 * _11368) + -mem[64] + 128
                _5848 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5848] = 26
                mem[_5848 + 32] = 'SafeMath: division by zero'
                if not _5296:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _5296) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6272 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6272] = 30
                mem[_6272 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _5296) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6752 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6752] = 3
                    mem[_6752 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _7109 = mem[64]
                    mem[mem[64]] = 64
                    _7222 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _7222:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_7109 + 32] = (32 * _7222) + 96
                    _11377 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7109 + (32 * _7222) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_7109 + (32 * _7222) + 128 len 32 * _11377] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11377]
                    return memory
                      from mem[64]
                       len _7109 + (32 * _7222) + (32 * _11377) + -mem[64] + 128
                if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6804 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6804] = 3
                mem[_6804 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _7219 = mem[64]
                mem[mem[64]] = 64
                _7344 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7344:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7219 + 32] = (32 * _7344) + 96
                _11374 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7219 + (32 * _7344) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7219 + (32 * _7344) + 128 len 32 * _11374] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11374]
                return memory
                  from mem[64]
                   len _7219 + (32 * _7344) + (32 * _11374) + -mem[64] + 128
            if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5742 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5742] = 3
            mem[_5742 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5296:
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6028 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6028] = 30
                mem[_6028 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6418 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6418] = 3
                    mem[_6418 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _6684 = mem[64]
                    mem[mem[64]] = 64
                    _6747 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6747:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6684 + 32] = (32 * _6747) + 96
                    _11355 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6684 + (32 * _6747) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6684 + (32 * _6747) + 128 len 32 * _11355] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11355]
                    return memory
                      from mem[64]
                       len _6684 + (32 * _6747) + (32 * _11355) + -mem[64] + 128
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6470 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6470] = 3
                mem[_6470 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _6744 = mem[64]
                mem[mem[64]] = 64
                _6800 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _6800:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_6744 + 32] = (32 * _6800) + 96
                _11352 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6744 + (32 * _6800) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6744 + (32 * _6800) + 128 len 32 * _11352] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11352]
                return memory
                  from mem[64]
                   len _6744 + (32 * _6800) + (32 * _11352) + -mem[64] + 128
            _5884 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5884] = 26
            mem[_5884 + 32] = 'SafeMath: division by zero'
            if not _5296:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _6315 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6315] = 30
            mem[_6315 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _6802 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6802] = 3
                mem[_6802 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _7217 = mem[64]
                mem[mem[64]] = 64
                _7342 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7342:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7217 + 32] = (32 * _7342) + 96
                _11361 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7217 + (32 * _7342) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7217 + (32 * _7342) + 128 len 32 * _11361] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11361]
                return memory
                  from mem[64]
                   len _7217 + (32 * _7342) + (32 * _11361) + -mem[64] + 128
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6867 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6867] = 3
            mem[_6867 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _7339 = mem[64]
            mem[mem[64]] = 64
            _7451 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _7451:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_7339 + 32] = (32 * _7451) + 96
            _11358 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7339 + (32 * _7451) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7339 + (32 * _7451) + 128 len 32 * _11358] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11358]
            return memory
              from mem[64]
               len _7339 + (32 * _7451) + (32 * _11358) + -mem[64] + 128
        if not block.number - initialBlockNumber / sub_2730bcb7:
            if initialBlockNumber < 0:
                revert with 0, 'SafeMath: addition overflow'
            _5701 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5701] = 30
            mem[_5701 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _5791 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5791] = 30
            mem[_5791 + 32] = 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number + -initialBlockNumber - 1:
                _6119 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6119] = 30
                mem[_6119 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    _6698 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6698] = 3
                    mem[_6698 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if not _5296:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = address(arg1)
                        mem[32] = 371
                        _7472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7472] = 30
                        mem[_7472 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8345 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8345] = 3
                            mem[_8345 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                            _8914 = mem[64]
                            mem[mem[64]] = 64
                            _9060 = mem[ceil32(return_data.size) + 96]
                            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                            idx = 0
                            s = ceil32(return_data.size) + 128
                            t = mem[64] + 96
                            while idx < _9060:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_8914 + 32] = (32 * _9060) + 96
                            _11507 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8914 + (32 * _9060) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                            mem[_8914 + (32 * _9060) + 128 len 32 * _11507] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11507]
                            return memory
                              from mem[64]
                               len _8914 + (32 * _9060) + (32 * _11507) + -mem[64] + 128
                        if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _8432 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8432] = 3
                        mem[_8432 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, ''
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _9057 = mem[64]
                        mem[mem[64]] = 64
                        _9211 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9211:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9057 + 32] = (32 * _9211) + 96
                        _11504 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9057 + (32 * _9211) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9057 + (32 * _9211) + 128 len 32 * _11504] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11504]
                        return memory
                          from mem[64]
                           len _9057 + (32 * _9211) + (32 * _11504) + -mem[64] + 128
                    _7032 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7032] = 26
                    mem[_7032 + 32] = 'SafeMath: division by zero'
                    if not _5296:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / _5296) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _8195 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8195] = 30
                    mem[_8195 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (0 / _5296) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _9213 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9213] = 3
                        mem[_9213 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9805 = mem[64]
                        mem[mem[64]] = 64
                        _9931 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9931:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9805 + 32] = (32 * _9931) + 96
                        _11513 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9805 + (32 * _9931) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9805 + (32 * _9931) + 128 len 32 * _11513] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11513]
                        return memory
                          from mem[64]
                           len _9805 + (32 * _9931) + (32 * _11513) + -mem[64] + 128
                    if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _9350 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9350] = 3
                    mem[_9350 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9928 = mem[64]
                    mem[mem[64]] = 64
                    _10064 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10064:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9928 + 32] = (32 * _10064) + 96
                    _11510 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9928 + (32 * _10064) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9928 + (32 * _10064) + 128 len 32 * _11510] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11510]
                    return memory
                      from mem[64]
                       len _9928 + (32 * _10064) + (32 * _11510) + -mem[64] + 128
                if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6757 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6757] = 3
                mem[_6757 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5296:
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7564 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7564] = 30
                    mem[_7564 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8428] = 3
                        mem[_8428 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9055 = mem[64]
                        mem[mem[64]] = 64
                        _9208 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9208:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9055 + 32] = (32 * _9208) + 96
                        _11491 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9055 + (32 * _9208) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9055 + (32 * _9208) + 128 len 32 * _11491] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11491]
                        return memory
                          from mem[64]
                           len _9055 + (32 * _9208) + (32 * _11491) + -mem[64] + 128
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8524 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8524] = 3
                    mem[_8524 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9205 = mem[64]
                    mem[mem[64]] = 64
                    _9346 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9346:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9205 + 32] = (32 * _9346) + 96
                    _11488 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9205 + (32 * _9346) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9205 + (32 * _9346) + 128 len 32 * _11488] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11488]
                    return memory
                      from mem[64]
                       len _9205 + (32 * _9346) + (32 * _11488) + -mem[64] + 128
                _7122 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7122] = 26
                mem[_7122 + 32] = 'SafeMath: division by zero'
                if not _5296:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8270 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8270] = 30
                mem[_8270 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9348 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9348] = 3
                    mem[_9348 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9926 = mem[64]
                    mem[mem[64]] = 64
                    _10062 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10062:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9926 + 32] = (32 * _10062) + 96
                    _11497 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9926 + (32 * _10062) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9926 + (32 * _10062) + 128 len 32 * _11497] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11497]
                    return memory
                      from mem[64]
                       len _9926 + (32 * _10062) + (32 * _11497) + -mem[64] + 128
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9456 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9456] = 3
                mem[_9456 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10059 = mem[64]
                mem[mem[64]] = 64
                _10184 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10184:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10059 + 32] = (32 * _10184) + 96
                _11494 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10059 + (32 * _10184) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10059 + (32 * _10184) + 128 len 32 * _11494] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11494]
                return memory
                  from mem[64]
                   len _10059 + (32 * _10184) + (32 * _11494) + -mem[64] + 128
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6155 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6155] = 30
            mem[_6155 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber - lastBlockNumber:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                _6756 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6756] = 3
                mem[_6756 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, ''
                if not _5296:
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7561 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7561] = 30
                    mem[_7561 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8424] = 3
                        mem[_8424 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9051 = mem[64]
                        mem[mem[64]] = 64
                        _9202 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9202:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9051 + 32] = (32 * _9202) + 96
                        _11473 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9051 + (32 * _9202) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9051 + (32 * _9202) + 128 len 32 * _11473] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11473]
                        return memory
                          from mem[64]
                           len _9051 + (32 * _9202) + (32 * _11473) + -mem[64] + 128
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8522 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8522] = 3
                    mem[_8522 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9199 = mem[64]
                    mem[mem[64]] = 64
                    _9343 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9343:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9199 + 32] = (32 * _9343) + 96
                    _11470 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9199 + (32 * _9343) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9199 + (32 * _9343) + 128 len 32 * _11470] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11470]
                    return memory
                      from mem[64]
                       len _9199 + (32 * _9343) + (32 * _11470) + -mem[64] + 128
                _7119 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7119] = 26
                mem[_7119 + 32] = 'SafeMath: division by zero'
                if not _5296:
                    revert with 0, 'SafeMath: division by zero'
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8268 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8268] = 30
                mem[_8268 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9345 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9345] = 3
                    mem[_9345 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9922 = mem[64]
                    mem[mem[64]] = 64
                    _10057 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10057:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9922 + 32] = (32 * _10057) + 96
                    _11479 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9922 + (32 * _10057) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9922 + (32 * _10057) + 128 len 32 * _11479] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11479]
                    return memory
                      from mem[64]
                       len _9922 + (32 * _10057) + (32 * _11479) + -mem[64] + 128
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9454 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9454] = 3
                mem[_9454 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10054 = mem[64]
                mem[mem[64]] = 64
                _10181 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10181:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10054 + 32] = (32 * _10181) + 96
                _11476 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10054 + (32 * _10181) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10054 + (32 * _10181) + 128 len 32 * _11476] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11476]
                return memory
                  from mem[64]
                   len _10054 + (32 * _10181) + (32 * _11476) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6807 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6807] = 3
            mem[_6807 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5296:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7655 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7655] = 30
                mem[_7655 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8518 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8518] = 3
                    mem[_8518 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9197 = mem[64]
                    mem[mem[64]] = 64
                    _9340 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9340:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9197 + 32] = (32 * _9340) + 96
                    _11457 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9197 + (32 * _9340) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9197 + (32 * _9340) + 128 len 32 * _11457] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11457]
                    return memory
                      from mem[64]
                       len _9197 + (32 * _9340) + (32 * _11457) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8627 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8627] = 3
                mem[_8627 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9337 = mem[64]
                mem[mem[64]] = 64
                _9450 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9450:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9337 + 32] = (32 * _9450) + 96
                _11454 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9337 + (32 * _9450) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9337 + (32 * _9450) + 128 len 32 * _11454] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11454]
                return memory
                  from mem[64]
                   len _9337 + (32 * _9450) + (32 * _11454) + -mem[64] + 128
            _7233 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7233] = 26
            mem[_7233 + 32] = 'SafeMath: division by zero'
            if not _5296:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8340 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8340] = 30
            mem[_8340 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9452 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9452] = 3
                mem[_9452 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10052 = mem[64]
                mem[mem[64]] = 64
                _10179 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10179:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10052 + 32] = (32 * _10179) + 96
                _11463 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10052 + (32 * _10179) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10052 + (32 * _10179) + 128 len 32 * _11463] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11463]
                return memory
                  from mem[64]
                   len _10052 + (32 * _10179) + (32 * _11463) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9555 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9555] = 3
            mem[_9555 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10176 = mem[64]
            mem[mem[64]] = 64
            _10267 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10267:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10176 + 32] = (32 * _10267) + 96
            _11460 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10176 + (32 * _10267) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10176 + (32 * _10267) + 128 len 32 * _11460] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11460]
            return memory
              from mem[64]
               len _10176 + (32 * _10267) + (32 * _11460) + -mem[64] + 128
        if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 'SafeMath: addition overflow'
        _5712 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5712] = 30
        mem[_5712 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        _5816 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5816] = 30
        mem[_5816 + 32] = 'SafeMath: subtraction overflow'
        if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
            _6154 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6154] = 30
            mem[_6154 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                _6755 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6755] = 3
                mem[_6755 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if not _5296:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7556] = 30
                    mem[_7556 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8418] = 3
                        mem[_8418 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _9042 = mem[64]
                        mem[mem[64]] = 64
                        _9192 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9192:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9042 + 32] = (32 * _9192) + 96
                        _11437 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9042 + (32 * _9192) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_9042 + (32 * _9192) + 128 len 32 * _11437] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11437]
                        return memory
                          from mem[64]
                           len _9042 + (32 * _9192) + (32 * _11437) + -mem[64] + 128
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8516] = 3
                    mem[_8516 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9189 = mem[64]
                    mem[mem[64]] = 64
                    _9334 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9334:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9189 + 32] = (32 * _9334) + 96
                    _11434 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9189 + (32 * _9334) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9189 + (32 * _9334) + 128 len 32 * _11434] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11434]
                    return memory
                      from mem[64]
                       len _9189 + (32 * _9334) + (32 * _11434) + -mem[64] + 128
                _7116 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7116] = 26
                mem[_7116 + 32] = 'SafeMath: division by zero'
                if not _5296:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _5296) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8263 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8263] = 30
                mem[_8263 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _5296) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9336] = 3
                    mem[_9336 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9914 = mem[64]
                    mem[mem[64]] = 64
                    _10048 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _10048:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9914 + 32] = (32 * _10048) + 96
                    _11443 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9914 + (32 * _10048) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9914 + (32 * _10048) + 128 len 32 * _11443] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11443]
                    return memory
                      from mem[64]
                       len _9914 + (32 * _10048) + (32 * _11443) + -mem[64] + 128
                if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9449 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9449] = 3
                mem[_9449 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _10045 = mem[64]
                mem[mem[64]] = 64
                _10173 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10173:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10045 + 32] = (32 * _10173) + 96
                _11440 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10045 + (32 * _10173) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10045 + (32 * _10173) + 128 len 32 * _11440] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11440]
                return memory
                  from mem[64]
                   len _10045 + (32 * _10173) + (32 * _11440) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6806 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6806] = 3
            mem[_6806 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5296:
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7650 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7650] = 30
                mem[_7650 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8512 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8512] = 3
                    mem[_8512 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9187 = mem[64]
                    mem[mem[64]] = 64
                    _9331 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9331:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9187 + 32] = (32 * _9331) + 96
                    _11421 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9187 + (32 * _9331) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9187 + (32 * _9331) + 128 len 32 * _11421] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11421]
                    return memory
                      from mem[64]
                       len _9187 + (32 * _9331) + (32 * _11421) + -mem[64] + 128
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8620 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8620] = 3
                mem[_8620 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9328 = mem[64]
                mem[mem[64]] = 64
                _9445 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9445:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9328 + 32] = (32 * _9445) + 96
                _11418 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9328 + (32 * _9445) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9328 + (32 * _9445) + 128 len 32 * _11418] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11418]
                return memory
                  from mem[64]
                   len _9328 + (32 * _9445) + (32 * _11418) + -mem[64] + 128
            _7228 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7228] = 26
            mem[_7228 + 32] = 'SafeMath: division by zero'
            if not _5296:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8336 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8336] = 30
            mem[_8336 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9447 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9447] = 3
                mem[_9447 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10043 = mem[64]
                mem[mem[64]] = 64
                _10171 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10171:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10043 + 32] = (32 * _10171) + 96
                _11427 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10043 + (32 * _10171) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10043 + (32 * _10171) + 128 len 32 * _11427] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11427]
                return memory
                  from mem[64]
                   len _10043 + (32 * _10171) + (32 * _11427) + -mem[64] + 128
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9548 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9548] = 3
            mem[_9548 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10168 = mem[64]
            mem[mem[64]] = 64
            _10263 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10263:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10168 + 32] = (32 * _10263) + 96
            _11424 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10168 + (32 * _10263) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10168 + (32 * _10263) + 128 len 32 * _11424] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11424]
            return memory
              from mem[64]
               len _10168 + (32 * _10263) + (32 * _11424) + -mem[64] + 128
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _6184 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6184] = 30
        mem[_6184 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6805 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6805] = 3
            mem[_6805 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5296:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7647 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7647] = 30
                mem[_7647 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8508 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8508] = 3
                    mem[_8508 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9183 = mem[64]
                    mem[mem[64]] = 64
                    _9325 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9325:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9183 + 32] = (32 * _9325) + 96
                    _11403 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9183 + (32 * _9325) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9183 + (32 * _9325) + 128 len 32 * _11403] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11403]
                    return memory
                      from mem[64]
                       len _9183 + (32 * _9325) + (32 * _11403) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8618 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8618] = 3
                mem[_8618 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9322 = mem[64]
                mem[mem[64]] = 64
                _9442 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9442:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9322 + 32] = (32 * _9442) + 96
                _11400 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9322 + (32 * _9442) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9322 + (32 * _9442) + 128 len 32 * _11400] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11400]
                return memory
                  from mem[64]
                   len _9322 + (32 * _9442) + (32 * _11400) + -mem[64] + 128
            _7225 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7225] = 26
            mem[_7225 + 32] = 'SafeMath: division by zero'
            if not _5296:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8334 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8334] = 30
            mem[_8334 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9444 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9444] = 3
                mem[_9444 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _10039 = mem[64]
                mem[mem[64]] = 64
                _10166 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10166:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_10039 + 32] = (32 * _10166) + 96
                _11409 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10039 + (32 * _10166) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_10039 + (32 * _10166) + 128 len 32 * _11409] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11409]
                return memory
                  from mem[64]
                   len _10039 + (32 * _10166) + (32 * _11409) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9546 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9546] = 3
            mem[_9546 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10163 = mem[64]
            mem[mem[64]] = 64
            _10260 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10260:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10163 + 32] = (32 * _10260) + 96
            _11406 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10163 + (32 * _10260) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10163 + (32 * _10260) + 128 len 32 * _11406] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11406]
            return memory
              from mem[64]
               len _10163 + (32 * _10260) + (32 * _11406) + -mem[64] + 128
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        _6873 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6873] = 3
        mem[_6873 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5296:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _7754 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7754] = 30
            mem[_7754 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _8614 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8614] = 3
                mem[_8614 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9320 = mem[64]
                mem[mem[64]] = 64
                _9439 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9439:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9320 + 32] = (32 * _9439) + 96
                _11387 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9320 + (32 * _9439) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9320 + (32 * _9439) + 128 len 32 * _11387] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11387]
                return memory
                  from mem[64]
                   len _9320 + (32 * _9439) + (32 * _11387) + -mem[64] + 128
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _8740 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8740] = 3
            mem[_8740 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _9436 = mem[64]
            mem[mem[64]] = 64
            _9542 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9542:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9436 + 32] = (32 * _9542) + 96
            _11384 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9436 + (32 * _9542) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9436 + (32 * _9542) + 128 len 32 * _11384] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11384]
            return memory
              from mem[64]
               len _9436 + (32 * _9542) + (32 * _11384) + -mem[64] + 128
        _7346 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7346] = 26
        mem[_7346 + 32] = 'SafeMath: division by zero'
        if not _5296:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _8413 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8413] = 30
        mem[_8413 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _9544 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9544] = 3
            mem[_9544 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _10161 = mem[64]
            mem[mem[64]] = 64
            _10258 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10258:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10161 + 32] = (32 * _10258) + 96
            _11393 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10161 + (32 * _10258) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10161 + (32 * _10258) + 128 len 32 * _11393] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11393]
            return memory
              from mem[64]
               len _10161 + (32 * _10258) + (32 * _11393) + -mem[64] + 128
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _9657 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9657] = 3
        mem[_9657 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5296 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _10255 = mem[64]
        mem[mem[64]] = 64
        _10319 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10319:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10255 + 32] = (32 * _10319) + 96
        _11390 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10255 + (32 * _10319) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10255 + (32 * _10319) + 128 len 32 * _11390] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11390]
        return memory
          from mem[64]
           len _10255 + (32 * _10319) + (32 * _11390) + -mem[64] + 128
    mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * stor362.length + 1] = call.data[calldata.size len 32 * stor362.length + 1]
    idx = 0
    while idx < stor362.length:
        require idx < mem[ceil32(return_data.size) + 96]
        mem[(32 * idx) + ceil32(return_data.size) + 128] = address(stor362[idx].field_0)
        require idx < mem[ceil32(return_data.size) + 96]
        mem[0] = address(stor362[idx].field_0)
        mem[32] = 367
        _5327 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5327] = 30
        mem[_5327 + 32] = 'SafeMath: subtraction overflow'
        if sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] > sub_b32b53ab[address(stor362[idx].field_0)]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _5327 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)]:
            _5463 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5463] = 3
            mem[_5463 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            idx = idx + 1
            continue 
        if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5479 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5479] = 3
        mem[_5479 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 >= 500 * 10^6:
            require idx < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * idx) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            idx = idx + 1
            continue 
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 3
        mem[mem[64] + 68] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        idx = 32
        while idx < 3:
            mem[idx + mem[64] + 68] = mem[idx + _5479 + 32]
            idx = idx + 32
            continue 
        revert with 0, ''
    require stor362.length < mem[ceil32(return_data.size) + 96]
    mem[(32 * stor362.length) + ceil32(return_data.size) + 128] = sub_5d830fbeAddress
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _5290 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _5298 = mem[_5290]
    _5320 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5320] = 30
    mem[_5320 + 32] = 'SafeMath: subtraction overflow'
    if initialBlockNumber > lastBlockNumber:
        revert with 0, 'SafeMath: subtraction overflow'
    _5383 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5383] = 26
    mem[_5383 + 32] = 'SafeMath: division by zero'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    _5476 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5476] = 30
    mem[_5476 + 32] = 'SafeMath: subtraction overflow'
    if initialBlockNumber > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    _5563 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5563] = 26
    mem[_5563 + 32] = 'SafeMath: division by zero'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        _5630 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5630] = 30
        mem[_5630 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - lastBlockNumber:
            _5728 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5728] = 3
            mem[_5728 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if not _5298:
                if sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _6005 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6005] = 30
                mem[_6005 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _6380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6380] = 3
                    mem[_6380 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _6642 = mem[64]
                    mem[mem[64]] = 64
                    _6706 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _6706:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_6642 + 32] = (32 * _6706) + 96
                    _11555 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6642 + (32 * _6706) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_6642 + (32 * _6706) + 128 len 32 * _11555] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11555]
                    return memory
                      from mem[64]
                       len _6642 + (32 * _6706) + (32 * _11555) + -mem[64] + 128
                if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _6435 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6435] = 3
                mem[_6435 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _6703 = mem[64]
                mem[mem[64]] = 64
                _6764 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _6764:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_6703 + 32] = (32 * _6764) + 96
                _11552 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6703 + (32 * _6764) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6703 + (32 * _6764) + 128 len 32 * _11552] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11552]
                return memory
                  from mem[64]
                   len _6703 + (32 * _6764) + (32 * _11552) + -mem[64] + 128
            _5857 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5857] = 26
            mem[_5857 + 32] = 'SafeMath: division by zero'
            if not _5298:
                revert with 0, 'SafeMath: division by zero'
            if (0 / _5298) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _6284 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6284] = 30
            mem[_6284 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (0 / _5298) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _6766 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6766] = 3
                mem[_6766 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _7134 = mem[64]
                mem[mem[64]] = 64
                _7253 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _7253:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_7134 + 32] = (32 * _7253) + 96
                _11561 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7134 + (32 * _7253) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_7134 + (32 * _7253) + 128 len 32 * _11561] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11561]
                return memory
                  from mem[64]
                   len _7134 + (32 * _7253) + (32 * _11561) + -mem[64] + 128
            if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6818 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6818] = 3
            mem[_6818 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _7250 = mem[64]
            mem[mem[64]] = 64
            _7375 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _7375:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_7250 + 32] = (32 * _7375) + 96
            _11558 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7250 + (32 * _7375) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7250 + (32 * _7375) + 128 len 32 * _11558] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11558]
            return memory
              from mem[64]
               len _7250 + (32 * _7375) + (32 * _11558) + -mem[64] + 128
        if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5747 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5747] = 3
        mem[_5747 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5298:
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _6036 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6036] = 30
            mem[_6036 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _6431 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6431] = 3
                mem[_6431 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _6701 = mem[64]
                mem[mem[64]] = 64
                _6761 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _6761:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_6701 + 32] = (32 * _6761) + 96
                _11539 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6701 + (32 * _6761) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_6701 + (32 * _6761) + 128 len 32 * _11539] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11539]
                return memory
                  from mem[64]
                   len _6701 + (32 * _6761) + (32 * _11539) + -mem[64] + 128
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6483 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6483] = 3
            mem[_6483 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _6758 = mem[64]
            mem[mem[64]] = 64
            _6814 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _6814:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_6758 + 32] = (32 * _6814) + 96
            _11536 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_6758 + (32 * _6814) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_6758 + (32 * _6814) + 128 len 32 * _11536] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11536]
            return memory
              from mem[64]
               len _6758 + (32 * _6814) + (32 * _11536) + -mem[64] + 128
        _5894 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5894] = 26
        mem[_5894 + 32] = 'SafeMath: division by zero'
        if not _5298:
            revert with 0, 'SafeMath: division by zero'
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _6326 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6326] = 30
        mem[_6326 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _6816 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6816] = 3
            mem[_6816 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _7248 = mem[64]
            mem[mem[64]] = 64
            _7373 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _7373:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_7248 + 32] = (32 * _7373) + 96
            _11545 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7248 + (32 * _7373) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_7248 + (32 * _7373) + 128 len 32 * _11545] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11545]
            return memory
              from mem[64]
               len _7248 + (32 * _7373) + (32 * _11545) + -mem[64] + 128
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _6886 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6886] = 3
        mem[_6886 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _7370 = mem[64]
        mem[mem[64]] = 64
        _7476 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _7476:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_7370 + 32] = (32 * _7476) + 96
        _11542 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_7370 + (32 * _7476) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_7370 + (32 * _7476) + 128 len 32 * _11542] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11542]
        return memory
          from mem[64]
           len _7370 + (32 * _7476) + (32 * _11542) + -mem[64] + 128
    if not block.number - initialBlockNumber / sub_2730bcb7:
        if initialBlockNumber < 0:
            revert with 0, 'SafeMath: addition overflow'
        _5703 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5703] = 30
        mem[_5703 + 32] = 'SafeMath: subtraction overflow'
        if initialBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        _5797 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5797] = 30
        mem[_5797 + 32] = 'SafeMath: subtraction overflow'
        if 1 > block.number - initialBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number + -initialBlockNumber - 1:
            _6131 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6131] = 30
            mem[_6131 + 32] = 'SafeMath: subtraction overflow'
            if lastBlockNumber > initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if not initialBlockNumber - lastBlockNumber:
                _6715 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6715] = 3
                mem[_6715 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                if not _5298:
                    if sub_a57f309a < sub_a57f309a:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = address(arg1)
                    mem[32] = 371
                    _7497 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7497] = 30
                    mem[_7497 + 32] = 'SafeMath: subtraction overflow'
                    if sub_3acf4148[address(arg1)] > sub_a57f309a:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                        _8364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8364] = 3
                        mem[_8364 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                        _8950 = mem[64]
                        mem[mem[64]] = 64
                        _9097 = mem[ceil32(return_data.size) + 96]
                        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                        idx = 0
                        s = ceil32(return_data.size) + 128
                        t = mem[64] + 96
                        while idx < _9097:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_8950 + 32] = (32 * _9097) + 96
                        _11691 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_8950 + (32 * _9097) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                        mem[_8950 + (32 * _9097) + 128 len 32 * _11691] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11691]
                        return memory
                          from mem[64]
                           len _8950 + (32 * _9097) + (32 * _11691) + -mem[64] + 128
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _8454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8454] = 3
                    mem[_8454 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                    _9094 = mem[64]
                    mem[mem[64]] = 64
                    _9249 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9249:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9094 + 32] = (32 * _9249) + 96
                    _11688 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9094 + (32 * _9249) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9094 + (32 * _9249) + 128 len 32 * _11688] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11688]
                    return memory
                      from mem[64]
                       len _9094 + (32 * _9249) + (32 * _11688) + -mem[64] + 128
                _7051 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7051] = 26
                mem[_7051 + 32] = 'SafeMath: division by zero'
                if not _5298:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _5298) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _8215 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8215] = 30
                mem[_8215 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _5298) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _9251 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9251] = 3
                    mem[_9251 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9835 = mem[64]
                    mem[mem[64]] = 64
                    _9963 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9963:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9835 + 32] = (32 * _9963) + 96
                    _11697 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9835 + (32 * _9963) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9835 + (32 * _9963) + 128 len 32 * _11697] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11697]
                    return memory
                      from mem[64]
                       len _9835 + (32 * _9963) + (32 * _11697) + -mem[64] + 128
                if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _9383 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9383] = 3
                mem[_9383 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9960 = mem[64]
                mem[mem[64]] = 64
                _10098 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10098:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9960 + 32] = (32 * _10098) + 96
                _11694 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9960 + (32 * _10098) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9960 + (32 * _10098) + 128 len 32 * _11694] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11694]
                return memory
                  from mem[64]
                   len _9960 + (32 * _10098) + (32 * _11694) + -mem[64] + 128
            if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _6771 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6771] = 3
            mem[_6771 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5298:
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7587 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7587] = 30
                mem[_7587 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8450 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8450] = 3
                    mem[_8450 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9092 = mem[64]
                    mem[mem[64]] = 64
                    _9246 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9246:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9092 + 32] = (32 * _9246) + 96
                    _11675 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9092 + (32 * _9246) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9092 + (32 * _9246) + 128 len 32 * _11675] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11675]
                    return memory
                      from mem[64]
                       len _9092 + (32 * _9246) + (32 * _11675) + -mem[64] + 128
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8549 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8549] = 3
                mem[_8549 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9243 = mem[64]
                mem[mem[64]] = 64
                _9379 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9379:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9243 + 32] = (32 * _9379) + 96
                _11672 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9243 + (32 * _9379) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9243 + (32 * _9379) + 128 len 32 * _11672] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11672]
                return memory
                  from mem[64]
                   len _9243 + (32 * _9379) + (32 * _11672) + -mem[64] + 128
            _7147 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7147] = 26
            mem[_7147 + 32] = 'SafeMath: division by zero'
            if not _5298:
                revert with 0, 'SafeMath: division by zero'
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8289 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8289] = 30
            mem[_8289 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9381 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9381] = 3
                mem[_9381 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9958 = mem[64]
                mem[mem[64]] = 64
                _10096 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10096:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9958 + 32] = (32 * _10096) + 96
                _11681 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9958 + (32 * _10096) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9958 + (32 * _10096) + 128 len 32 * _11681] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11681]
                return memory
                  from mem[64]
                   len _9958 + (32 * _10096) + (32 * _11681) + -mem[64] + 128
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9482 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9482] = 3
            mem[_9482 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10093 = mem[64]
            mem[mem[64]] = 64
            _10213 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10213:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10093 + 32] = (32 * _10213) + 96
            _11678 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10093 + (32 * _10213) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10093 + (32 * _10213) + 128 len 32 * _11678] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11678]
            return memory
              from mem[64]
               len _10093 + (32 * _10213) + (32 * _11678) + -mem[64] + 128
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _6163 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6163] = 30
        mem[_6163 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > initialBlockNumber:
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber - lastBlockNumber:
            if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                revert with 0, 'SafeMath: addition overflow'
            _6770 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6770] = 3
            mem[_6770 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _5298:
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7584 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7584] = 30
                mem[_7584 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8446 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8446] = 3
                    mem[_8446 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9088 = mem[64]
                    mem[mem[64]] = 64
                    _9240 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9240:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9088 + 32] = (32 * _9240) + 96
                    _11657 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9088 + (32 * _9240) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9088 + (32 * _9240) + 128 len 32 * _11657] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11657]
                    return memory
                      from mem[64]
                       len _9088 + (32 * _9240) + (32 * _11657) + -mem[64] + 128
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8547 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8547] = 3
                mem[_8547 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9237 = mem[64]
                mem[mem[64]] = 64
                _9376 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9376:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9237 + 32] = (32 * _9376) + 96
                _11654 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9237 + (32 * _9376) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9237 + (32 * _9376) + 128 len 32 * _11654] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11654]
                return memory
                  from mem[64]
                   len _9237 + (32 * _9376) + (32 * _11654) + -mem[64] + 128
            _7144 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7144] = 26
            mem[_7144 + 32] = 'SafeMath: division by zero'
            if not _5298:
                revert with 0, 'SafeMath: division by zero'
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8287 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8287] = 30
            mem[_8287 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9378] = 3
                mem[_9378 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9954 = mem[64]
                mem[mem[64]] = 64
                _10091 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10091:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9954 + 32] = (32 * _10091) + 96
                _11663 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9954 + (32 * _10091) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9954 + (32 * _10091) + 128 len 32 * _11663] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11663]
                return memory
                  from mem[64]
                   len _9954 + (32 * _10091) + (32 * _11663) + -mem[64] + 128
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9480 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9480] = 3
            mem[_9480 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10088 = mem[64]
            mem[mem[64]] = 64
            _10210 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10210:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10088 + 32] = (32 * _10210) + 96
            _11660 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10088 + (32 * _10210) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10088 + (32 * _10210) + 128 len 32 * _11660] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11660]
            return memory
              from mem[64]
               len _10088 + (32 * _10210) + (32 * _11660) + -mem[64] + 128
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        _6821 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6821] = 3
        mem[_6821 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5298:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _7680 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7680] = 30
            mem[_7680 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _8543 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8543] = 3
                mem[_8543 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9235 = mem[64]
                mem[mem[64]] = 64
                _9373 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9373:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9235 + 32] = (32 * _9373) + 96
                _11641 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9235 + (32 * _9373) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9235 + (32 * _9373) + 128 len 32 * _11641] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11641]
                return memory
                  from mem[64]
                   len _9235 + (32 * _9373) + (32 * _11641) + -mem[64] + 128
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _8656 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8656] = 3
            mem[_8656 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _9370 = mem[64]
            mem[mem[64]] = 64
            _9476 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9476:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9370 + 32] = (32 * _9476) + 96
            _11638 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9370 + (32 * _9476) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9370 + (32 * _9476) + 128 len 32 * _11638] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11638]
            return memory
              from mem[64]
               len _9370 + (32 * _9476) + (32 * _11638) + -mem[64] + 128
        _7264 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7264] = 26
        mem[_7264 + 32] = 'SafeMath: division by zero'
        if not _5298:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _8359 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8359] = 30
        mem[_8359 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _9478 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9478] = 3
            mem[_9478 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _10086 = mem[64]
            mem[mem[64]] = 64
            _10208 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10208:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10086 + 32] = (32 * _10208) + 96
            _11647 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10086 + (32 * _10208) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10086 + (32 * _10208) + 128 len 32 * _11647] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11647]
            return memory
              from mem[64]
               len _10086 + (32 * _10208) + (32 * _11647) + -mem[64] + 128
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _9582 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9582] = 3
        mem[_9582 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _10205 = mem[64]
        mem[mem[64]] = 64
        _10286 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10286:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10205 + 32] = (32 * _10286) + 96
        _11644 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10205 + (32 * _10286) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10205 + (32 * _10286) + 128 len 32 * _11644] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11644]
        return memory
          from mem[64]
           len _10205 + (32 * _10286) + (32 * _11644) + -mem[64] + 128
    if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
        revert with 0, 'SafeMath: addition overflow'
    _5715 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5715] = 30
    mem[_5715 + 32] = 'SafeMath: subtraction overflow'
    if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    _5823 = mem[64]
    mem[64] = mem[64] + 64
    mem[_5823] = 30
    mem[_5823 + 32] = 'SafeMath: subtraction overflow'
    if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
        _6162 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6162] = 30
        mem[_6162 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, 'SafeMath: subtraction overflow'
        if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
            _6769 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6769] = 3
            mem[_6769 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if not _5298:
                if sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = address(arg1)
                mem[32] = 371
                _7579 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7579] = 30
                mem[_7579 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _8440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8440] = 3
                    mem[_8440 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                    _9079 = mem[64]
                    mem[mem[64]] = 64
                    _9230 = mem[ceil32(return_data.size) + 96]
                    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                    idx = 0
                    s = ceil32(return_data.size) + 128
                    t = mem[64] + 96
                    while idx < _9230:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_9079 + 32] = (32 * _9230) + 96
                    _11621 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9079 + (32 * _9230) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                    mem[_9079 + (32 * _9230) + 128 len 32 * _11621] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11621]
                    return memory
                      from mem[64]
                       len _9079 + (32 * _9230) + (32 * _11621) + -mem[64] + 128
                if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _8541 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8541] = 3
                mem[_8541 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                    revert with 0, ''
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                _9227 = mem[64]
                mem[mem[64]] = 64
                _9367 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9367:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9227 + 32] = (32 * _9367) + 96
                _11618 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9227 + (32 * _9367) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9227 + (32 * _9367) + 128 len 32 * _11618] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11618]
                return memory
                  from mem[64]
                   len _9227 + (32 * _9367) + (32 * _11618) + -mem[64] + 128
            _7141 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7141] = 26
            mem[_7141 + 32] = 'SafeMath: division by zero'
            if not _5298:
                revert with 0, 'SafeMath: division by zero'
            if (0 / _5298) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _8282 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8282] = 30
            mem[_8282 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (0 / _5298) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _9369 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9369] = 3
                mem[_9369 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9946 = mem[64]
                mem[mem[64]] = 64
                _10082 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _10082:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9946 + 32] = (32 * _10082) + 96
                _11627 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9946 + (32 * _10082) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9946 + (32 * _10082) + 128 len 32 * _11627] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11627]
                return memory
                  from mem[64]
                   len _9946 + (32 * _10082) + (32 * _11627) + -mem[64] + 128
            if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _9475 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9475] = 3
            mem[_9475 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (0 / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _10079 = mem[64]
            mem[mem[64]] = 64
            _10202 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10202:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10079 + 32] = (32 * _10202) + 96
            _11624 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10079 + (32 * _10202) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10079 + (32 * _10202) + 128 len 32 * _11624] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11624]
            return memory
              from mem[64]
               len _10079 + (32 * _10202) + (32 * _11624) + -mem[64] + 128
        if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _6820 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6820] = 3
        mem[_6820 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5298:
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _7675 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7675] = 30
            mem[_7675 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _8537 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8537] = 3
                mem[_8537 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9225 = mem[64]
                mem[mem[64]] = 64
                _9364 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9364:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9225 + 32] = (32 * _9364) + 96
                _11605 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9225 + (32 * _9364) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9225 + (32 * _9364) + 128 len 32 * _11605] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11605]
                return memory
                  from mem[64]
                   len _9225 + (32 * _9364) + (32 * _11605) + -mem[64] + 128
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _8649 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8649] = 3
            mem[_8649 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _9361 = mem[64]
            mem[mem[64]] = 64
            _9471 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9471:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9361 + 32] = (32 * _9471) + 96
            _11602 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9361 + (32 * _9471) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9361 + (32 * _9471) + 128 len 32 * _11602] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11602]
            return memory
              from mem[64]
               len _9361 + (32 * _9471) + (32 * _11602) + -mem[64] + 128
        _7259 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7259] = 26
        mem[_7259 + 32] = 'SafeMath: division by zero'
        if not _5298:
            revert with 0, 'SafeMath: division by zero'
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _8355 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8355] = 30
        mem[_8355 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _9473 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9473] = 3
            mem[_9473 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _10077 = mem[64]
            mem[mem[64]] = 64
            _10200 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10200:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10077 + 32] = (32 * _10200) + 96
            _11611 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10077 + (32 * _10200) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10077 + (32 * _10200) + 128 len 32 * _11611] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11611]
            return memory
              from mem[64]
               len _10077 + (32 * _10200) + (32 * _11611) + -mem[64] + 128
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _9575 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9575] = 3
        mem[_9575 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _10197 = mem[64]
        mem[mem[64]] = 64
        _10282 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10282:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10197 + 32] = (32 * _10282) + 96
        _11608 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10197 + (32 * _10282) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10197 + (32 * _10282) + 128 len 32 * _11608] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11608]
        return memory
          from mem[64]
           len _10197 + (32 * _10282) + (32 * _11608) + -mem[64] + 128
    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    _6192 = mem[64]
    mem[64] = mem[64] + 64
    mem[_6192] = 30
    mem[_6192 + 32] = 'SafeMath: subtraction overflow'
    if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
        revert with 0, 'SafeMath: subtraction overflow'
    if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
        if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
            revert with 0, 'SafeMath: addition overflow'
        _6819 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6819] = 3
        mem[_6819 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
            revert with 0, ''
        if not _5298:
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(arg1)
            mem[32] = 371
            _7672 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7672] = 30
            mem[_7672 + 32] = 'SafeMath: subtraction overflow'
            if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                revert with 0, 'SafeMath: subtraction overflow'
            if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                _8533 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8533] = 3
                mem[_8533 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
                _9221 = mem[64]
                mem[mem[64]] = 64
                _9358 = mem[ceil32(return_data.size) + 96]
                mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
                idx = 0
                s = ceil32(return_data.size) + 128
                t = mem[64] + 96
                while idx < _9358:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_9221 + 32] = (32 * _9358) + 96
                _11587 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9221 + (32 * _9358) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
                mem[_9221 + (32 * _9358) + 128 len 32 * _11587] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11587]
                return memory
                  from mem[64]
                   len _9221 + (32 * _9358) + (32 * _11587) + -mem[64] + 128
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _8647 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8647] = 3
            mem[_8647 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                revert with 0, ''
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _9355 = mem[64]
            mem[mem[64]] = 64
            _9468 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9468:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9355 + 32] = (32 * _9468) + 96
            _11584 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9355 + (32 * _9468) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9355 + (32 * _9468) + 128 len 32 * _11584] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11584]
            return memory
              from mem[64]
               len _9355 + (32 * _9468) + (32 * _11584) + -mem[64] + 128
        _7256 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7256] = 26
        mem[_7256 + 32] = 'SafeMath: division by zero'
        if not _5298:
            revert with 0, 'SafeMath: division by zero'
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _8353 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8353] = 30
        mem[_8353 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _9470 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9470] = 3
            mem[_9470 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _10073 = mem[64]
            mem[mem[64]] = 64
            _10195 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _10195:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_10073 + 32] = (32 * _10195) + 96
            _11593 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10073 + (32 * _10195) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_10073 + (32 * _10195) + 128 len 32 * _11593] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11593]
            return memory
              from mem[64]
               len _10073 + (32 * _10195) + (32 * _11593) + -mem[64] + 128
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _9573 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9573] = 3
        mem[_9573 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _10192 = mem[64]
        mem[mem[64]] = 64
        _10279 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10279:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10192 + 32] = (32 * _10279) + 96
        _11590 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10192 + (32 * _10279) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10192 + (32 * _10279) + 128 len 32 * _11590] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11590]
        return memory
          from mem[64]
           len _10192 + (32 * _10279) + (32 * _11590) + -mem[64] + 128
    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
        revert with 0, 'SafeMath: addition overflow'
    _6892 = mem[64]
    mem[64] = mem[64] + 64
    mem[_6892] = 3
    mem[_6892 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
        revert with 0, ''
    if not _5298:
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
            revert with 0, 'SafeMath: addition overflow'
        mem[0] = address(arg1)
        mem[32] = 371
        _7784 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7784] = 30
        mem[_7784 + 32] = 'SafeMath: subtraction overflow'
        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
            revert with 0, 'SafeMath: subtraction overflow'
        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
            _8643 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8643] = 3
            mem[_8643 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
            _9353 = mem[64]
            mem[mem[64]] = 64
            _9465 = mem[ceil32(return_data.size) + 96]
            mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
            idx = 0
            s = ceil32(return_data.size) + 128
            t = mem[64] + 96
            while idx < _9465:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_9353 + 32] = (32 * _9465) + 96
            _11571 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9353 + (32 * _9465) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
            mem[_9353 + (32 * _9465) + 128 len 32 * _11571] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11571]
            return memory
              from mem[64]
               len _9353 + (32 * _9465) + (32 * _11571) + -mem[64] + 128
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _8774 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8774] = 3
        mem[_8774 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
            revert with 0, ''
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
        _9462 = mem[64]
        mem[mem[64]] = 64
        _9569 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _9569:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_9462 + 32] = (32 * _9569) + 96
        _11568 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_9462 + (32 * _9569) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_9462 + (32 * _9569) + 128 len 32 * _11568] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11568]
        return memory
          from mem[64]
           len _9462 + (32 * _9569) + (32 * _11568) + -mem[64] + 128
    _7377 = mem[64]
    mem[64] = mem[64] + 64
    mem[_7377] = 26
    mem[_7377 + 32] = 'SafeMath: division by zero'
    if not _5298:
        revert with 0, 'SafeMath: division by zero'
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a < sub_a57f309a:
        revert with 0, 'SafeMath: addition overflow'
    mem[0] = address(arg1)
    mem[32] = 371
    _8435 = mem[64]
    mem[64] = mem[64] + 64
    mem[_8435] = 30
    mem[_8435 + 32] = 'SafeMath: subtraction overflow'
    if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a:
        revert with 0, 'SafeMath: subtraction overflow'
    if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)]:
        _9571 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9571] = 3
        mem[_9571 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
        require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = 0
        _10190 = mem[64]
        mem[mem[64]] = 64
        _10277 = mem[ceil32(return_data.size) + 96]
        mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
        idx = 0
        s = ceil32(return_data.size) + 128
        t = mem[64] + 96
        while idx < _10277:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_10190 + 32] = (32 * _10277) + 96
        _11577 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10190 + (32 * _10277) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
        mem[_10190 + (32 * _10277) + 128 len 32 * _11577] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11577]
        return memory
          from mem[64]
           len _10190 + (32 * _10277) + (32 * _11577) + -mem[64] + 128
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    _9687 = mem[64]
    mem[64] = mem[64] + 64
    mem[_9687] = 3
    mem[_9687 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
    if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
        revert with 0, ''
    require stor362.length < mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
    mem[(32 * stor362.length) + ceil32(return_data.size) + (32 * stor362.length + 1) + 160] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _5298 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
    _10274 = mem[64]
    mem[mem[64]] = 64
    _10332 = mem[ceil32(return_data.size) + 96]
    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 96]
    idx = 0
    s = ceil32(return_data.size) + 128
    t = mem[64] + 96
    while idx < _10332:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_10274 + 32] = (32 * _10332) + 96
    _11574 = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
    mem[_10274 + (32 * _10332) + 96] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 128]
    mem[_10274 + (32 * _10332) + 128 len 32 * _11574] = mem[ceil32(return_data.size) + (32 * stor362.length + 1) + 160 len 32 * _11574]
    return memory
      from mem[64]
       len _10274 + (32 * _10332) + (32 * _11574) + -mem[64] + 128
}

function claimAll(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[100] = arg1
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = 0
    while idx < stor362.length:
        mem[0] = address(stor362[idx].field_0)
        mem[32] = 367
        _7455 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7455] = 30
        mem[_7455 + 32] = 'SafeMath: subtraction overflow'
        if sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] > sub_b32b53ab[address(stor362[idx].field_0)]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _7455 + 32]
                idx = idx + 32
                continue 
        else:
            if not sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)]:
                _7487 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7487] = 3
                mem[_7487 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                idx = idx + 1
                s = uint256(stor362[idx].field_0)
                continue 
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) - (sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) / sub_b32b53ab[address(stor362[idx].field_0)] - sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _7490 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7490] = 3
            mem[_7490 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
            if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 3
                mem[mem[64] + 68] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                idx = 32
                while idx < 3:
                    mem[idx + mem[64] + 68] = mem[idx + _7490 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, ''
            if not (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9:
                idx = idx + 1
                s = uint256(stor362[idx].field_0)
                continue 
            sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] = sub_b32b53ab[address(stor362[idx].field_0)]
            if ((sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9) + sub_603f2f0c[address(stor362[idx].field_0)] < sub_603f2f0c[address(stor362[idx].field_0)]:
                revert with 0, 'SafeMath: addition overflow'
            mem[0] = address(stor362[idx].field_0)
            mem[32] = 369
            sub_603f2f0c[address(stor362[idx].field_0)] += (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _7528 = mem[64]
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
            _7529 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_7529 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_7529 + 36 len 28]
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(stor362[idx].field_0)):
                revert with 0, 'SafeERC20: call to non-contract'
            if not ext_code.hash(address(stor362[idx].field_0)):
                revert with 0, 'SafeERC20: call to non-contract'
            _7543 = mem[_7529]
            t = _7529 + 32
            u = mem[64]
            s = mem[_7529]
            while s >= 32:
                mem[u] = mem[t]
                t = t + 32
                u = u + 32
                s = s - 32
                continue 
            mem[mem[64] + floor32(mem[_7529])] = mem[_7529 + floor32(mem[_7529]) + -(mem[_7529] % 32) + 64 len mem[_7529] % 32] or Mask(8 * -(mem[_7529] % 32) + 32, -(8 * -(mem[_7529] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_7529])])
            call address(stor362[idx].field_0).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _7543 + _7528 + -mem[64] + 96]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    mem[0] = address(stor362[idx].field_0)
                    mem[32] = 366
                    _15956 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15956] = 30
                    mem[_15956 + 32] = 'SafeMath: subtraction overflow'
                    if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 <= balances[address(stor362[idx].field_0)]:
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        balances[address(stor362[idx].field_0)] -= (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        idx = idx + 1
                        s = uint256(stor362[idx].field_0)
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _15956 + 32]
                        idx = idx + 32
                        continue 
                else:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                    mem[0] = address(stor362[idx].field_0)
                    mem[32] = 366
                    _16043 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16043] = 30
                    mem[_16043 + 32] = 'SafeMath: subtraction overflow'
                    if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 <= balances[address(stor362[idx].field_0)]:
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        balances[address(stor362[idx].field_0)] -= (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        idx = idx + 1
                        s = uint256(stor362[idx].field_0)
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _16043 + 32]
                        idx = idx + 32
                        continue 
            else:
                _15303 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_15303] = return_data.size
                mem[_15303 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[0] = address(stor362[idx].field_0)
                    mem[32] = 366
                    _15957 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15957] = 30
                    mem[_15957 + 32] = 'SafeMath: subtraction overflow'
                    if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 <= balances[address(stor362[idx].field_0)]:
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        balances[address(stor362[idx].field_0)] -= (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        idx = idx + 1
                        s = uint256(stor362[idx].field_0)
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _15957 + 32]
                        idx = idx + 32
                        continue 
                else:
                    require return_data.size >= 32
                    if not mem[_15303 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                    mem[0] = address(stor362[idx].field_0)
                    mem[32] = 366
                    _16047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16047] = 30
                    mem[_16047 + 32] = 'SafeMath: subtraction overflow'
                    if (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 <= balances[address(stor362[idx].field_0)]:
                        mem[0] = address(stor362[idx].field_0)
                        mem[32] = 366
                        balances[address(stor362[idx].field_0)] -= (sub_b32b53ab[address(stor362[idx].field_0)] * ext_call.return_data[0]) + (-1 * sub_c4ccc25d[address(stor362[idx].field_0)][address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        idx = idx + 1
                        s = uint256(stor362[idx].field_0)
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _16047 + 32]
                        idx = idx + 32
                        continue 
        revert with 0, 'SafeMath: subtraction overflow'
    require ext_code.size(sub_23bf2705Address)
    staticcall sub_23bf2705Address.0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _7448 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _7450 = mem[_7448]
    _7454 = mem[64]
    mem[64] = mem[64] + 64
    mem[_7454] = 30
    mem[_7454 + 32] = 'SafeMath: subtraction overflow'
    if initialBlockNumber > lastBlockNumber:
        revert with 0, 'SafeMath: subtraction overflow'
    _7468 = mem[64]
    mem[64] = mem[64] + 64
    mem[_7468] = 26
    mem[_7468 + 32] = 'SafeMath: division by zero'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    _7491 = mem[64]
    mem[64] = mem[64] + 64
    mem[_7491] = 30
    mem[_7491 + 32] = 'SafeMath: subtraction overflow'
    if initialBlockNumber > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    _7515 = mem[64]
    mem[64] = mem[64] + 64
    mem[_7515] = 26
    mem[_7515 + 32] = 'SafeMath: division by zero'
    if not sub_2730bcb7:
        revert with 0, 'SafeMath: division by zero'
    if block.number - initialBlockNumber / sub_2730bcb7 <= lastBlockNumber - initialBlockNumber / sub_2730bcb7:
        _7538 = mem[64]
        mem[64] = mem[64] + 64
        mem[_7538] = 30
        mem[_7538 + 32] = 'SafeMath: subtraction overflow'
        if lastBlockNumber > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - lastBlockNumber:
            _7588 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7588] = 3
            mem[_7588 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if _7450:
                _7644 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7644] = 26
                mem[_7644 + 32] = 'SafeMath: division by zero'
                if not _7450:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / _7450) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 371
                _7778 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7778] = 30
                mem[_7778 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (0 / _7450) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _7898 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7898] = 3
                    mem[_7898 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8046 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if 0 > mem[_8046]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8424 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8424] == mem[_8424 + 12 len 20]
                            require ext_code.size(mem[_8424 + 12 len 20])
                            staticcall mem[_8424 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8867 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8867] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8867]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8867] / mem[_8867] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8867]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8867] / sub_6cbe28ea * mem[_8867] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8867] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8867] / sub_846374b8
                        else:
                            _8480 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8575 = mem[_8480]
                            require mem[_8480] == mem[_8480 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8575))
                            staticcall address(_8575).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9032 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9137 = mem[_9032]
                            if mem[_9032] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9434] = 30
                                mem[_9434 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _9137 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _9137:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_9137 * sub_6cbe28ea) / sub_846374b8 - _9137 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_9137 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9137 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_9137 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9137 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9137 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                        _8220 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = 0
                        _8221 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8221 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8428 = mem[_8221]
                        mem[_8220 + 100 len floor32(mem[_8221])] = mem[_8221 + 32 len floor32(mem[_8221])]
                        mem[_8220 + floor32(mem[_8221]) + -(mem[_8221] % 32) + 132 len mem[_8221] % 32] = mem[_8221 + -(mem[_8221] % 32) + floor32(mem[_8221]) + 64 len mem[_8221] % 32]
                        call sub_5d830fbeAddress.mem[_8220 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_8220 + 104 len _8428 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8220 + 210 len 22]
                            sub_a57f309a += 0 / _7450
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8220 + (2 * ceil32(return_data.size)) + 201 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8220 + (2 * ceil32(return_data.size)) + 201 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8220 + (2 * ceil32(return_data.size)) + 265 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8220 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            mem[_8220 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_8220 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8220 + ceil32(return_data.size) + 211 len 22]
                            sub_a57f309a += 0 / _7450
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8220 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8220 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8220 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8220 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7908 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7908] = 3
                    mem[_7908 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8076 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8076]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8473] == mem[_8473 + 12 len 20]
                            require ext_code.size(mem[_8473 + 12 len 20])
                            staticcall mem[_8473 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8926 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8926] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8926]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8926] / mem[_8926] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8926]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8926] / sub_6cbe28ea * mem[_8926] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8926] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8926] / sub_846374b8
                        else:
                            _8525 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8619 = mem[_8525]
                            require mem[_8525] == mem[_8525 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8619))
                            staticcall address(_8619).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9083 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9202 = mem[_9083]
                            if mem[_9083] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9501 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9501] = 30
                                mem[_9501 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _9202 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _9202:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_9202 * sub_6cbe28ea) / sub_846374b8 - _9202 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_9202 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9202 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_9202 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9202 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9202 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                        _8271 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _8272 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8272 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8477 = mem[_8272]
                        mem[_8271 + 100 len floor32(mem[_8272])] = mem[_8272 + 32 len floor32(mem[_8272])]
                        mem[_8271 + floor32(mem[_8272]) + -(mem[_8272] % 32) + 132 len mem[_8272] % 32] = mem[_8272 + -(mem[_8272] % 32) + floor32(mem[_8272]) + 64 len mem[_8272] % 32]
                        call sub_5d830fbeAddress.mem[_8271 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_8271 + 104 len _8477 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8271 + 210 len 22]
                            sub_a57f309a += 0 / _7450
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8271 + (2 * ceil32(return_data.size)) + 201 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8271 + (2 * ceil32(return_data.size)) + 201 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8271 + (2 * ceil32(return_data.size)) + 265 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8271 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            mem[_8271 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_8271 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8271 + ceil32(return_data.size) + 211 len 22]
                            sub_a57f309a += 0 / _7450
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8271 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8271 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8271 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8271 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
            else:
                if sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 371
                _7707 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7707] = 30
                mem[_7707 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _7799 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7799] = 3
                    mem[_7799 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7897 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if 0 > mem[_7897]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8128 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8128] == mem[_8128 + 12 len 20]
                            require ext_code.size(mem[_8128 + 12 len 20])
                            staticcall mem[_8128 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8468 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8468] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8468]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8468] / mem[_8468] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8468]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8468] / sub_6cbe28ea * mem[_8468] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8468] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8468] / sub_846374b8
                        else:
                            _8174 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8269 = mem[_8174]
                            require mem[_8174] == mem[_8174 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8269))
                            staticcall address(_8269).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8616 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8721 = mem[_8616]
                            if mem[_8616] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _8976 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8976] = 30
                                mem[_8976 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _8721 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _8721:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_8721 * sub_6cbe28ea) / sub_846374b8 - _8721 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_8721 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8721 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_8721 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8721 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8721 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = sub_a57f309a
                        _7977 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = 0
                        _7978 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_7978 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8132 = mem[_7978]
                        mem[_7977 + 100 len floor32(mem[_7978])] = mem[_7978 + 32 len floor32(mem[_7978])]
                        mem[_7977 + floor32(mem[_7978]) + -(mem[_7978] % 32) + 132 len mem[_7978] % 32] = mem[_7978 + -(mem[_7978] % 32) + floor32(mem[_7978]) + 64 len mem[_7978] % 32]
                        call sub_5d830fbeAddress.mem[_7977 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_7977 + 104 len _8132 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_7977 + 210 len 22]
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7977 + (2 * ceil32(return_data.size)) + 201 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7977 + (2 * ceil32(return_data.size)) + 201 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7977 + (2 * ceil32(return_data.size)) + 265 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7977 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            mem[_7977 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_7977 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_7977 + ceil32(return_data.size) + 211 len 22]
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_7977 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7977 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_7977 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_7977 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7815 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7815] = 3
                    mem[_7815 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7907 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_7907]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8167 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8167] == mem[_8167 + 12 len 20]
                            require ext_code.size(mem[_8167 + 12 len 20])
                            staticcall mem[_8167 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8519 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8519] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8519]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8519] / mem[_8519] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8519]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8519] / sub_6cbe28ea * mem[_8519] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8519] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8519] / sub_846374b8
                        else:
                            _8213 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8311 = mem[_8213]
                            require mem[_8213] == mem[_8213 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8311))
                            staticcall address(_8311).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8661 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8789 = mem[_8661]
                            if mem[_8661] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9022] = 30
                                mem[_9022 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _8789 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _8789:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_8789 * sub_6cbe28ea) / sub_846374b8 - _8789 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_8789 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8789 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_8789 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8789 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8789 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = sub_a57f309a
                        _8007 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _8008 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8008 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8171 = mem[_8008]
                        mem[mem[64] len floor32(mem[_8008])] = mem[_8008 + 32 len floor32(mem[_8008])]
                        mem[mem[64] + floor32(mem[_8008]) + -(mem[_8008] % 32) + 32 len mem[_8008] % 32] = mem[_8008 + floor32(mem[_8008]) + -(mem[_8008] % 32) + 64 len mem[_8008] % 32]
                        call sub_5d830fbeAddress with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _8171 + _8007 + -mem[64] + 96]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16484 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16484] == mem[_16484 + 12 len 20]
                                    require ext_code.size(mem[_16484 + 12 len 20])
                                    staticcall mem[_16484 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17554 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17554] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17554]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17554] / mem[_17554] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17554]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17554] / sub_6cbe28ea * mem[_17554] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17554] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17554] / sub_846374b8
                                else:
                                    _16654 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16984 = mem[_16654]
                                    require mem[_16654] == mem[_16654 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16984))
                                    staticcall address(_16984).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18106 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18346 = mem[_18106]
                                    if mem[_18106] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18596 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18596] = 30
                                        mem[_18596 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18346 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18346:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18346 * sub_6cbe28ea) / sub_846374b8 - _18346 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18346 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18346 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18346 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18346 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18346 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16821 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16821] == mem[_16821 + 12 len 20]
                                    require ext_code.size(mem[_16821 + 12 len 20])
                                    staticcall mem[_16821 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17947 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17947] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17947]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17947] / mem[_17947] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17947]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17947] / sub_6cbe28ea * mem[_17947] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17947] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17947] / sub_846374b8
                                else:
                                    _16985 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17218 = mem[_16985]
                                    require mem[_16985] == mem[_16985 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17218))
                                    staticcall address(_17218).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18347 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18498 = mem[_18347]
                                    if mem[_18347] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18836] = 30
                                        mem[_18836 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18498 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18498:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18498 * sub_6cbe28ea) / sub_846374b8 - _18498 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18498 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18498 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18498 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18498 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18498 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            _15139 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_15139] = return_data.size
                            mem[_15139 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16486 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16486] == mem[_16486 + 12 len 20]
                                    require ext_code.size(mem[_16486 + 12 len 20])
                                    staticcall mem[_16486 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17557 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17557] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17557]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17557] / mem[_17557] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17557]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17557] / sub_6cbe28ea * mem[_17557] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17557] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17557] / sub_846374b8
                                else:
                                    _16656 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16986 = mem[_16656]
                                    require mem[_16656] == mem[_16656 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16986))
                                    staticcall address(_16986).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18108 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18348 = mem[_18108]
                                    if mem[_18108] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18599 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18599] = 30
                                        mem[_18599 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18348 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18348:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18348 * sub_6cbe28ea) / sub_846374b8 - _18348 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18348 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18348 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18348 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18348 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18348 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require return_data.size >= 32
                                if not mem[_15139 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16823 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16823] == mem[_16823 + 12 len 20]
                                    require ext_code.size(mem[_16823 + 12 len 20])
                                    staticcall mem[_16823 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17949 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17949] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17949]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17949] / mem[_17949] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17949]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17949] / sub_6cbe28ea * mem[_17949] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17949] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17949] / sub_846374b8
                                else:
                                    _16987 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17219 = mem[_16987]
                                    require mem[_16987] == mem[_16987 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17219))
                                    staticcall address(_17219).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18499 = mem[_18349]
                                    if mem[_18349] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18839 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18839] = 30
                                        mem[_18839 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18499 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18499:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18499 * sub_6cbe28ea) / sub_846374b8 - _18499 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18499 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18499 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18499 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18499 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18499 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
        else:
            if (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number - lastBlockNumber != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _7594 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7594] = 3
            mem[_7594 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
            if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, ''
            if not _7450:
                if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 371
                _7716 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7716] = 30
                mem[_7716 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _7811 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7811] = 3
                    mem[_7811 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7905 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if 0 > mem[_7905]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8159 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8159] == mem[_8159 + 12 len 20]
                            require ext_code.size(mem[_8159 + 12 len 20])
                            staticcall mem[_8159 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8506 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8506] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8506]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8506] / mem[_8506] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8506]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8506] / sub_6cbe28ea * mem[_8506] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8506] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8506] / sub_846374b8
                        else:
                            _8211 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8305 = mem[_8211]
                            require mem[_8211] == mem[_8211 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8305))
                            staticcall address(_8305).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8656 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8774 = mem[_8656]
                            if mem[_8656] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9013 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9013] = 30
                                mem[_9013 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _8774 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _8774:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_8774 * sub_6cbe28ea) / sub_846374b8 - _8774 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_8774 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8774 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_8774 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8774 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8774 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                        _8001 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = 0
                        _8002 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8002 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8163 = mem[_8002]
                        mem[_8001 + 100 len floor32(mem[_8002])] = mem[_8002 + 32 len floor32(mem[_8002])]
                        mem[_8001 + floor32(mem[_8002]) + -(mem[_8002] % 32) + 132 len mem[_8002] % 32] = mem[_8002 + -(mem[_8002] % 32) + floor32(mem[_8002]) + 64 len mem[_8002] % 32]
                        call sub_5d830fbeAddress.mem[_8001 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_8001 + 104 len _8163 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8001 + 210 len 22]
                            sub_a57f309a = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8001 + (2 * ceil32(return_data.size)) + 201 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8001 + (2 * ceil32(return_data.size)) + 201 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8001 + (2 * ceil32(return_data.size)) + 265 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8001 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            mem[_8001 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_8001 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8001 + ceil32(return_data.size) + 211 len 22]
                            sub_a57f309a = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8001 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8001 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8001 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8001 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7824 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7824] = 3
                    mem[_7824 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7918 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_7918]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8204 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8204] == mem[_8204 + 12 len 20]
                            require ext_code.size(mem[_8204 + 12 len 20])
                            staticcall mem[_8204 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8556 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8556] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8556]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8556] / mem[_8556] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8556]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8556] / sub_6cbe28ea * mem[_8556] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8556] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8556] / sub_846374b8
                        else:
                            _8254 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8334 = mem[_8254]
                            require mem[_8254] == mem[_8254 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8334))
                            staticcall address(_8334).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8708 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8840 = mem[_8708]
                            if mem[_8708] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9064] = 30
                                mem[_9064 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _8840 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _8840:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_8840 * sub_6cbe28ea) / sub_846374b8 - _8840 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_8840 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8840 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_8840 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8840 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_8840 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                        _8036 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _8037 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8037 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8208 = mem[_8037]
                        mem[_8036 + 100 len floor32(mem[_8037])] = mem[_8037 + 32 len floor32(mem[_8037])]
                        mem[_8036 + floor32(mem[_8037]) + -(mem[_8037] % 32) + 132 len mem[_8037] % 32] = mem[_8037 + -(mem[_8037] % 32) + floor32(mem[_8037]) + 64 len mem[_8037] % 32]
                        call sub_5d830fbeAddress.mem[_8036 + 100 len 4] with:
                             gas gas_remaining wei
                            args mem[_8036 + 104 len _8208 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8036 + 210 len 22]
                            sub_a57f309a = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8036 + (2 * ceil32(return_data.size)) + 201 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8036 + (2 * ceil32(return_data.size)) + 201 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8036 + (2 * ceil32(return_data.size)) + 265 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8036 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            mem[_8036 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_8036 + 132]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_8036 + ceil32(return_data.size) + 211 len 22]
                            sub_a57f309a = (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                            lastBlockNumber = block.number
                            require ext_code.size(sub_e56b22baAddress)
                            staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                    gas gas_remaining wei
                                   args 0x574f570000000000000000000000000000000000000000000000000000000000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            require ext_code.size(address(ext_call.return_data[0]))
                            if sub_2fee582f != 56:
                                staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[_8036 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                        if not sub_6cbe28ea * ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8036 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                            else:
                                staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                        gas gas_remaining wei
                                       args sub_7dc65830Address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > sub_846374b8:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if sub_846374b8 - ext_call.return_data[0] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not sub_846374b8 - ext_call.return_data[0]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[_8036 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                            if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_8036 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                    sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
            else:
                _7657 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7657] = 26
                mem[_7657 + 32] = 'SafeMath: division by zero'
                if not _7450:
                    revert with 0, 'SafeMath: division by zero'
                if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 371
                _7787 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7787] = 30
                mem[_7787 + 32] = 'SafeMath: subtraction overflow'
                if sub_3acf4148[address(arg1)] > ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                    _7906 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7906] = 3
                    mem[_7906 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8073 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if 0 > mem[_8073]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8458 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8458] == mem[_8458 + 12 len 20]
                            require ext_code.size(mem[_8458 + 12 len 20])
                            staticcall mem[_8458 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8913 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8913] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8913]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8913] / mem[_8913] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8913]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8913] / sub_6cbe28ea * mem[_8913] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8913] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8913] / sub_846374b8
                        else:
                            _8518 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8613 = mem[_8518]
                            require mem[_8518] == mem[_8518 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8613))
                            staticcall address(_8613).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9074 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9191 = mem[_9074]
                            if mem[_9074] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9486 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9486] = 30
                                mem[_9486 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _9191 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _9191:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_9191 * sub_6cbe28ea) / sub_846374b8 - _9191 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_9191 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9191 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_9191 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9191 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9191 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                        _8261 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = 0
                        _8262 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8262 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8462 = mem[_8262]
                        mem[mem[64] len floor32(mem[_8262])] = mem[_8262 + 32 len floor32(mem[_8262])]
                        mem[mem[64] + floor32(mem[_8262]) + -(mem[_8262] % 32) + 32 len mem[_8262] % 32] = mem[_8262 + floor32(mem[_8262]) + -(mem[_8262] % 32) + 64 len mem[_8262] % 32]
                        call sub_5d830fbeAddress with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _8462 + _8261 + -mem[64] + 96]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16480 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16480] == mem[_16480 + 12 len 20]
                                    require ext_code.size(mem[_16480 + 12 len 20])
                                    staticcall mem[_16480 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17548 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17548] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17548]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17548] / mem[_17548] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17548]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17548] / sub_6cbe28ea * mem[_17548] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17548] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17548] / sub_846374b8
                                else:
                                    _16650 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16980 = mem[_16650]
                                    require mem[_16650] == mem[_16650 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16980))
                                    staticcall address(_16980).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18102 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18342 = mem[_18102]
                                    if mem[_18102] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18590] = 30
                                        mem[_18590 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18342 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18342:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18342 * sub_6cbe28ea) / sub_846374b8 - _18342 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18342 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18342 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18342 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18342 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18342 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16817 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16817] == mem[_16817 + 12 len 20]
                                    require ext_code.size(mem[_16817 + 12 len 20])
                                    staticcall mem[_16817 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17943 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17943] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17943]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17943] / mem[_17943] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17943]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17943] / sub_6cbe28ea * mem[_17943] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17943] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17943] / sub_846374b8
                                else:
                                    _16981 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17216 = mem[_16981]
                                    require mem[_16981] == mem[_16981 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17216))
                                    staticcall address(_17216).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18343 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18496 = mem[_18343]
                                    if mem[_18343] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18830] = 30
                                        mem[_18830 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18496 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18496:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18496 * sub_6cbe28ea) / sub_846374b8 - _18496 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18496 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18496 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18496 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18496 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18496 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            _15132 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_15132] = return_data.size
                            mem[_15132 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16482 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16482] == mem[_16482 + 12 len 20]
                                    require ext_code.size(mem[_16482 + 12 len 20])
                                    staticcall mem[_16482 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17551 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17551] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17551]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17551] / mem[_17551] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17551]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17551] / sub_6cbe28ea * mem[_17551] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17551] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17551] / sub_846374b8
                                else:
                                    _16652 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16982 = mem[_16652]
                                    require mem[_16652] == mem[_16652 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16982))
                                    staticcall address(_16982).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18104 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18344 = mem[_18104]
                                    if mem[_18104] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18593 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18593] = 30
                                        mem[_18593 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18344 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18344:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18344 * sub_6cbe28ea) / sub_846374b8 - _18344 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18344 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18344 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18344 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18344 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18344 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require return_data.size >= 32
                                if not mem[_15132 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16819 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16819] == mem[_16819 + 12 len 20]
                                    require ext_code.size(mem[_16819 + 12 len 20])
                                    staticcall mem[_16819 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17945 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17945] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17945]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17945] / mem[_17945] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17945]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17945] / sub_6cbe28ea * mem[_17945] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17945] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17945] / sub_846374b8
                                else:
                                    _16983 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17217 = mem[_16983]
                                    require mem[_16983] == mem[_16983 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17217))
                                    staticcall address(_17217).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18345 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18497 = mem[_18345]
                                    if mem[_18345] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18833] = 30
                                        mem[_18833 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18497 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18497:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18497 * sub_6cbe28ea) / sub_846374b8 - _18497 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18497 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18497 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18497 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18497 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18497 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7919 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7919] = 3
                    mem[_7919 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                    if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, ''
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(sub_5d830fbeAddress)
                    staticcall sub_5d830fbeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8100 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8100]:
                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                        require ext_code.size(sub_e56b22baAddress)
                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                gas gas_remaining wei
                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if sub_2fee582f != 56:
                            _8511 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8511] == mem[_8511 + 12 len 20]
                            require ext_code.size(mem[_8511 + 12 len 20])
                            staticcall mem[_8511 + 12 len 20].0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8964 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_8964] <= 0:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                if not mem[_8964]:
                                    require sub_846374b8
                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                        sub_bb5b5a6a = 0 / sub_846374b8
                                else:
                                    if sub_6cbe28ea * mem[_8964] / mem[_8964] != sub_6cbe28ea:
                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not sub_6cbe28ea * mem[_8964]:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_8964] / sub_6cbe28ea * mem[_8964] != sub_5c7cdf12:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require sub_846374b8
                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_8964] / sub_846374b8:
                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_8964] / sub_846374b8
                        else:
                            _8562 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8659 = mem[_8562]
                            require mem[_8562] == mem[_8562 + 12 len 20]
                            mem[mem[64] + 4] = sub_7dc65830Address
                            require ext_code.size(address(_8659))
                            staticcall address(_8659).0x70a08231 with:
                                    gas gas_remaining wei
                                   args sub_7dc65830Address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9267 = mem[_9126]
                            if mem[_9126] > sub_846374b8:
                                if sub_bb5b5a6a:
                                    sub_bb5b5a6a = 0
                            else:
                                _9568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9568] = 30
                                mem[_9568 + 32] = 'SafeMath: subtraction overflow'
                                if sub_846374b8 - _9267 <= 0:
                                    if sub_bb5b5a6a:
                                        sub_bb5b5a6a = 0
                                else:
                                    if not sub_846374b8 - _9267:
                                        require sub_846374b8
                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                            sub_bb5b5a6a = 0 / sub_846374b8
                                    else:
                                        if (sub_846374b8 * sub_6cbe28ea) - (_9267 * sub_6cbe28ea) / sub_846374b8 - _9267 != sub_6cbe28ea:
                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (sub_846374b8 * sub_6cbe28ea) - (_9267 * sub_6cbe28ea):
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9267 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_9267 * sub_6cbe28ea) != sub_5c7cdf12:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require sub_846374b8
                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9267 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_9267 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        mem[0] = arg1
                        mem[32] = 371
                        sub_3acf4148[address(arg1)] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                        _8307 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = ((10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                        _8308 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_8308 + 32 len 4] = unknown_0xa9059cbb(?????)
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        if not ext_code.hash(sub_5d830fbeAddress):
                            revert with 0, 'SafeERC20: call to non-contract'
                        _8515 = mem[_8308]
                        mem[mem[64] len floor32(mem[_8308])] = mem[_8308 + 32 len floor32(mem[_8308])]
                        mem[mem[64] + floor32(mem[_8308]) + -(mem[_8308] % 32) + 32 len mem[_8308] % 32] = mem[_8308 + floor32(mem[_8308]) + -(mem[_8308] % 32) + 64 len mem[_8308] % 32]
                        call sub_5d830fbeAddress with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _8515 + _8307 + -mem[64] + 96]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not mem[96]:
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16476 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16476] == mem[_16476 + 12 len 20]
                                    require ext_code.size(mem[_16476 + 12 len 20])
                                    staticcall mem[_16476 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17542 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17542] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17542]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17542] / mem[_17542] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17542]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17542] / sub_6cbe28ea * mem[_17542] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17542] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17542] / sub_846374b8
                                else:
                                    _16646 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16976 = mem[_16646]
                                    require mem[_16646] == mem[_16646 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16976))
                                    staticcall address(_16976).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18098 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18338 = mem[_18098]
                                    if mem[_18098] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18584 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18584] = 30
                                        mem[_18584 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18338 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18338:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18338 * sub_6cbe28ea) / sub_846374b8 - _18338 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18338 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18338 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18338 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18338 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18338 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16813 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16813] == mem[_16813 + 12 len 20]
                                    require ext_code.size(mem[_16813 + 12 len 20])
                                    staticcall mem[_16813 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17939 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17939] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17939]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17939] / mem[_17939] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17939]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17939] / sub_6cbe28ea * mem[_17939] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17939] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17939] / sub_846374b8
                                else:
                                    _16977 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17214 = mem[_16977]
                                    require mem[_16977] == mem[_16977 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17214))
                                    staticcall address(_17214).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18339 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18494 = mem[_18339]
                                    if mem[_18339] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18824] = 30
                                        mem[_18824 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18494 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18494:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18494 * sub_6cbe28ea) / sub_846374b8 - _18494 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18494 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18494 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18494 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18494 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18494 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            _15129 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_15129] = return_data.size
                            mem[_15129 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'SafeERC20: low-level call failed'
                            if not return_data.size:
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16478 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16478] == mem[_16478 + 12 len 20]
                                    require ext_code.size(mem[_16478 + 12 len 20])
                                    staticcall mem[_16478 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17545 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17545] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17545]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17545] / mem[_17545] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17545]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17545] / sub_6cbe28ea * mem[_17545] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17545] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17545] / sub_846374b8
                                else:
                                    _16648 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16978 = mem[_16648]
                                    require mem[_16648] == mem[_16648 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_16978))
                                    staticcall address(_16978).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18100 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18340 = mem[_18100]
                                    if mem[_18100] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18587 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18587] = 30
                                        mem[_18587 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18340 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18340:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18340 * sub_6cbe28ea) / sub_846374b8 - _18340 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18340 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18340 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18340 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18340 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18340 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                require return_data.size >= 32
                                if not mem[_15129 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                                sub_a57f309a += (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                lastBlockNumber = block.number
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _16815 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_16815] == mem[_16815 + 12 len 20]
                                    require ext_code.size(mem[_16815 + 12 len 20])
                                    staticcall mem[_16815 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17941 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_17941] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_17941]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_17941] / mem[_17941] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_17941]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_17941] / sub_6cbe28ea * mem[_17941] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17941] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17941] / sub_846374b8
                                else:
                                    _16979 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _17215 = mem[_16979]
                                    require mem[_16979] == mem[_16979 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_17215))
                                    staticcall address(_17215).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _18341 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _18495 = mem[_18341]
                                    if mem[_18341] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _18827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18827] = 30
                                        mem[_18827 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _18495 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _18495:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_18495 * sub_6cbe28ea) / sub_846374b8 - _18495 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_18495 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18495 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18495 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18495 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18495 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
    else:
        if block.number - initialBlockNumber / sub_2730bcb7:
            if sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 / block.number - initialBlockNumber / sub_2730bcb7 != sub_2730bcb7:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) < sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7:
                revert with 0, 'SafeMath: addition overflow'
            _7581 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7581] = 30
            mem[_7581 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _7625 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7625] = 30
            mem[_7625 + 32] = 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                revert with 0, 'SafeMath: subtraction overflow'
            if block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber + (-1 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _7758 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7758] = 30
                mem[_7758 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _7909 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7909] = 3
                    mem[_7909 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _7450:
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8138 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8138] = 30
                        mem[_8138 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8533] = 3
                            mem[_8533 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8938 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8938]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9595 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9595] == mem[_9595 + 12 len 20]
                                    require ext_code.size(mem[_9595 + 12 len 20])
                                    staticcall mem[_9595 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10464 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10464] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10464]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10464] / mem[_10464] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10464]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10464] / sub_6cbe28ea * mem[_10464] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10464] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10464] / sub_846374b8
                                else:
                                    _9698 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9902 = mem[_9698]
                                    require mem[_9698] == mem[_9698 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9902))
                                    staticcall address(_9902).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10777 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10991 = mem[_10777]
                                    if mem[_10777] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11548] = 30
                                        mem[_11548 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10991 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10991:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10991 * sub_6cbe28ea) / sub_846374b8 - _10991 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10991 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10991 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10991 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10991 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10991 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9216 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9217 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9217 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9599 = mem[_9217]
                                mem[_9216 + 100 len floor32(mem[_9217])] = mem[_9217 + 32 len floor32(mem[_9217])]
                                mem[_9216 + floor32(mem[_9217]) + -(mem[_9217] % 32) + 132 len mem[_9217] % 32] = mem[_9217 + -(mem[_9217] % 32) + floor32(mem[_9217]) + 64 len mem[_9217] % 32]
                                call sub_5d830fbeAddress.mem[_9216 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9216 + 104 len _9599 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9216 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9216 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9216 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9216 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9216 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9216 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9216 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9216 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9216 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9216 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9216 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9216 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8581] = 3
                            mem[_8581 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8986 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8986]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9691 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9691] == mem[_9691 + 12 len 20]
                                    require ext_code.size(mem[_9691 + 12 len 20])
                                    staticcall mem[_9691 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10598 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10598] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10598]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10598] / mem[_10598] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10598]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10598] / sub_6cbe28ea * mem[_10598] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10598] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10598] / sub_846374b8
                                else:
                                    _9792 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9987 = mem[_9792]
                                    require mem[_9792] == mem[_9792 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9987))
                                    staticcall address(_9987).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10862 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11143 = mem[_10862]
                                    if mem[_10862] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11664 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11664] = 30
                                        mem[_11664 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11143 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11143:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11143 * sub_6cbe28ea) / sub_846374b8 - _11143 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11143 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11143 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11143 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11143 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11143 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9299 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9300 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9300 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9695 = mem[_9300]
                                mem[_9299 + 100 len floor32(mem[_9300])] = mem[_9300 + 32 len floor32(mem[_9300])]
                                mem[_9299 + floor32(mem[_9300]) + -(mem[_9300] % 32) + 132 len mem[_9300] % 32] = mem[_9300 + -(mem[_9300] % 32) + floor32(mem[_9300]) + 64 len mem[_9300] % 32]
                                call sub_5d830fbeAddress.mem[_9299 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9299 + 104 len _9695 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9299 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9299 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9299 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9299 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9299 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9299 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9299 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9299 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9299 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9299 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9299 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9299 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        _8016 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8016] = 26
                        mem[_8016 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8435 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8435] = 30
                        mem[_8435 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8939 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8939] = 3
                            mem[_8939 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9379 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9379]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10319 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10319] == mem[_10319 + 12 len 20]
                                    require ext_code.size(mem[_10319 + 12 len 20])
                                    staticcall mem[_10319 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11300 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11300] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11300]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11300] / mem[_11300] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11300]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11300] / sub_6cbe28ea * mem[_11300] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11300] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11300] / sub_846374b8
                                else:
                                    _10476 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10706 = mem[_10476]
                                    require mem[_10476] == mem[_10476 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10706))
                                    staticcall address(_10706).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11674 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11896 = mem[_11674]
                                    if mem[_11674] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12470 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12470] = 30
                                        mem[_12470 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11896 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11896:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11896 * sub_6cbe28ea) / sub_846374b8 - _11896 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11896 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11896 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11896 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11896 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11896 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9799 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9800 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9800 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10323 = mem[_9800]
                                mem[_9799 + 100 len floor32(mem[_9800])] = mem[_9800 + 32 len floor32(mem[_9800])]
                                mem[_9799 + floor32(mem[_9800]) + -(mem[_9800] % 32) + 132 len mem[_9800] % 32] = mem[_9800 + -(mem[_9800] % 32) + floor32(mem[_9800]) + 64 len mem[_9800] % 32]
                                call sub_5d830fbeAddress.mem[_9799 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9799 + 104 len _10323 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9799 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9799 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9799 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9799 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9799 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9799 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9799 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9799 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9799 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9799 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9799 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9799 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8987] = 3
                            mem[_8987 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9445 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9445]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10469 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10469] == mem[_10469 + 12 len 20]
                                    require ext_code.size(mem[_10469 + 12 len 20])
                                    staticcall mem[_10469 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11430 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11430] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11430]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11430] / mem[_11430] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11430]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11430] / sub_6cbe28ea * mem[_11430] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11430] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11430] / sub_846374b8
                                else:
                                    _10604 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10780 = mem[_10604]
                                    require mem[_10604] == mem[_10604 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10780))
                                    staticcall address(_10780).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11788 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _12013 = mem[_11788]
                                    if mem[_11788] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12635] = 30
                                        mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _12013 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _12013:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_12013 * sub_6cbe28ea) / sub_846374b8 - _12013 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_12013 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12013 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_12013 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12013 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12013 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9904 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9905 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9905 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10473 = mem[_9905]
                                mem[_9904 + 100 len floor32(mem[_9905])] = mem[_9905 + 32 len floor32(mem[_9905])]
                                mem[_9904 + floor32(mem[_9905]) + -(mem[_9905] % 32) + 132 len mem[_9905] % 32] = mem[_9905 + -(mem[_9905] % 32) + floor32(mem[_9905]) + 64 len mem[_9905] % 32]
                                call sub_5d830fbeAddress.mem[_9904 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9904 + 104 len _10473 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9904 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9904 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9904 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9904 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9904 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9904 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9904 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9904 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9904 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9904 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9904 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9904 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _7924 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7924] = 3
                    mem[_7924 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _7450:
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8176 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8176] = 30
                        mem[_8176 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8577] = 3
                            mem[_8577 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8984 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8984]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9683 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9683] == mem[_9683 + 12 len 20]
                                    require ext_code.size(mem[_9683 + 12 len 20])
                                    staticcall mem[_9683 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10585] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10585]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10585] / mem[_10585] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10585]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10585] / sub_6cbe28ea * mem[_10585] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10585] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10585] / sub_846374b8
                                else:
                                    _9790 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9981 = mem[_9790]
                                    require mem[_9790] == mem[_9790 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9981))
                                    staticcall address(_9981).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10857 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11128 = mem[_10857]
                                    if mem[_10857] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11655] = 30
                                        mem[_11655 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11128 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11128:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11128 * sub_6cbe28ea) / sub_846374b8 - _11128 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11128 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11128 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11128 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11128 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11128 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9293 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9294 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9294 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9687 = mem[_9294]
                                mem[_9293 + 100 len floor32(mem[_9294])] = mem[_9294 + 32 len floor32(mem[_9294])]
                                mem[_9293 + floor32(mem[_9294]) + -(mem[_9294] % 32) + 132 len mem[_9294] % 32] = mem[_9294 + -(mem[_9294] % 32) + floor32(mem[_9294]) + 64 len mem[_9294] % 32]
                                call sub_5d830fbeAddress.mem[_9293 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9293 + 104 len _9687 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9293 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9293 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9293 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9293 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9293 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9293 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9293 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9293 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9293 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9293 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9293 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9293 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8621 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8621] = 3
                            mem[_8621 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9035 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9035]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9783 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9783] == mem[_9783 + 12 len 20]
                                    require ext_code.size(mem[_9783 + 12 len 20])
                                    staticcall mem[_9783 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10687 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10687] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10687]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10687] / mem[_10687] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10687]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10687] / sub_6cbe28ea * mem[_10687] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10687] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10687] / sub_846374b8
                                else:
                                    _9887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10059 = mem[_9887]
                                    require mem[_9887] == mem[_9887 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10059))
                                    staticcall address(_10059).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10978 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11273 = mem[_10978]
                                    if mem[_10978] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11769] = 30
                                        mem[_11769 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11273 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11273:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11273 * sub_6cbe28ea) / sub_846374b8 - _11273 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11273 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11273 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11273 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11273 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11273 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9369 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9370 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9370 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9787 = mem[_9370]
                                mem[_9369 + 100 len floor32(mem[_9370])] = mem[_9370 + 32 len floor32(mem[_9370])]
                                mem[_9369 + floor32(mem[_9370]) + -(mem[_9370] % 32) + 132 len mem[_9370] % 32] = mem[_9370 + -(mem[_9370] % 32) + floor32(mem[_9370]) + 64 len mem[_9370] % 32]
                                call sub_5d830fbeAddress.mem[_9369 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9369 + 104 len _9787 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9369 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9369 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9369 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9369 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9369 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9369 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9369 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9369 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9369 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9369 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9369 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9369 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        _8047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8047] = 26
                        mem[_8047 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8482 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8482] = 30
                        mem[_8482 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8985] = 3
                            mem[_8985 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9442 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9442]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10454 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10454] == mem[_10454 + 12 len 20]
                                    require ext_code.size(mem[_10454 + 12 len 20])
                                    staticcall mem[_10454 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11417 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11417] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11417]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11417] / mem[_11417] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11417]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11417] / sub_6cbe28ea * mem[_11417] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11417] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11417] / sub_846374b8
                                else:
                                    _10597 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10774 = mem[_10597]
                                    require mem[_10597] == mem[_10597 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10774))
                                    staticcall address(_10774).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11779 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _12002 = mem[_11779]
                                    if mem[_11779] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12620 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12620] = 30
                                        mem[_12620 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _12002 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _12002:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_12002 * sub_6cbe28ea) / sub_846374b8 - _12002 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_12002 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12002 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_12002 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12002 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12002 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9894 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9895 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9895 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10458 = mem[_9895]
                                mem[_9894 + 100 len floor32(mem[_9895])] = mem[_9895 + 32 len floor32(mem[_9895])]
                                mem[_9894 + floor32(mem[_9895]) + -(mem[_9895] % 32) + 132 len mem[_9895] % 32] = mem[_9895 + -(mem[_9895] % 32) + floor32(mem[_9895]) + 64 len mem[_9895] % 32]
                                call sub_5d830fbeAddress.mem[_9894 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9894 + 104 len _10458 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9894 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9894 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9894 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9894 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9894 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9894 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9894 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9894 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9894 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9894 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9894 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9894 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _9036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9036] = 3
                            mem[_9036 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9512 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9512]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == mem[_10590 + 12 len 20]
                                    require ext_code.size(mem[_10590 + 12 len 20])
                                    staticcall mem[_10590 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11536 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11536] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11536]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11536] / mem[_11536] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11536]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11536] / sub_6cbe28ea * mem[_11536] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11536] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11536] / sub_846374b8
                                else:
                                    _10693 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10860 = mem[_10693]
                                    require mem[_10693] == mem[_10693 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10860))
                                    staticcall address(_10860).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _12132 = mem[_11885]
                                    if mem[_11885] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12756] = 30
                                        mem[_12756 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _12132 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _12132:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_12132 * sub_6cbe28ea) / sub_846374b8 - _12132 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_12132 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12132 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_12132 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12132 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12132 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9983 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9984 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9984 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10594 = mem[_9984]
                                mem[_9983 + 100 len floor32(mem[_9984])] = mem[_9984 + 32 len floor32(mem[_9984])]
                                mem[_9983 + floor32(mem[_9984]) + -(mem[_9984] % 32) + 132 len mem[_9984] % 32] = mem[_9984 + -(mem[_9984] % 32) + floor32(mem[_9984]) + 64 len mem[_9984] % 32]
                                call sub_5d830fbeAddress.mem[_9983 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9983 + 104 len _10594 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9983 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9983 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9983 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9983 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9983 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9983 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9983 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9983 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9983 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9983 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9983 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9983 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
            else:
                _7752 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7752] = 30
                mem[_7752 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7):
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber:
                    _7901 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7901] = 3
                    mem[_7901 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if _7450:
                        _7989 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7989] = 26
                        mem[_7989 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8394] = 30
                        mem[_8394 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (0 / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8888 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8888] = 3
                            mem[_8888 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9316 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9316]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10204 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10204] == mem[_10204 + 12 len 20]
                                    require ext_code.size(mem[_10204 + 12 len 20])
                                    staticcall mem[_10204 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11186 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11186] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11186]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11186] / mem[_11186] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11186]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11186] / sub_6cbe28ea * mem[_11186] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11186] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11186] / sub_846374b8
                                else:
                                    _10356 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10629 = mem[_10356]
                                    require mem[_10356] == mem[_10356 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10629))
                                    staticcall address(_10629).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11810 = mem[_11580]
                                    if mem[_11580] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12340] = 30
                                        mem[_12340 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11810 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11810:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11810 * sub_6cbe28ea) / sub_846374b8 - _11810 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11810 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11810 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11810 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11810 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11810 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                                _9716 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9717 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9717 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10208 = mem[_9717]
                                mem[_9716 + 100 len floor32(mem[_9717])] = mem[_9717 + 32 len floor32(mem[_9717])]
                                mem[_9716 + floor32(mem[_9717]) + -(mem[_9717] % 32) + 132 len mem[_9717] % 32] = mem[_9717 + -(mem[_9717] % 32) + floor32(mem[_9717]) + 64 len mem[_9717] % 32]
                                call sub_5d830fbeAddress.mem[_9716 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9716 + 104 len _10208 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9716 + 210 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9716 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9716 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9716 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9716 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9716 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9716 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9716 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9716 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9716 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9716 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9716 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8944] = 3
                            mem[_8944 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9386 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9386]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10349] == mem[_10349 + 12 len 20]
                                    require ext_code.size(mem[_10349 + 12 len 20])
                                    staticcall mem[_10349 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11329 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11329] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11329]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11329] / mem[_11329] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11329]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11329] / sub_6cbe28ea * mem[_11329] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11329] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11329] / sub_846374b8
                                else:
                                    _10499 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10721 = mem[_10499]
                                    require mem[_10499] == mem[_10499 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10721))
                                    staticcall address(_10721).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11698 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11918 = mem[_11698]
                                    if mem[_11698] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12506 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12506] = 30
                                        mem[_12506 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11918 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11918:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11918 * sub_6cbe28ea) / sub_846374b8 - _11918 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11918 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11918 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11918 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11918 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11918 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                                _9819 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9820 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9820 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10353 = mem[_9820]
                                mem[_9819 + 100 len floor32(mem[_9820])] = mem[_9820 + 32 len floor32(mem[_9820])]
                                mem[_9819 + floor32(mem[_9820]) + -(mem[_9820] % 32) + 132 len mem[_9820] % 32] = mem[_9820 + -(mem[_9820] % 32) + floor32(mem[_9820]) + 64 len mem[_9820] % 32]
                                call sub_5d830fbeAddress.mem[_9819 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9819 + 104 len _10353 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9819 + 210 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9819 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9819 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9819 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9819 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9819 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9819 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9819 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9819 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9819 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9819 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9819 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8111] = 30
                        mem[_8111 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_a57f309a - sub_3acf4148[address(arg1)]:
                            if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8541] = 3
                            mem[_8541 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8943 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8943]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9612 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9612] == mem[_9612 + 12 len 20]
                                    require ext_code.size(mem[_9612 + 12 len 20])
                                    staticcall mem[_9612 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10493 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10493] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10493]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10493] / mem[_10493] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10493]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10493] / sub_6cbe28ea * mem[_10493] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10493] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10493] / sub_846374b8
                                else:
                                    _9709 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9919 = mem[_9709]
                                    require mem[_9709] == mem[_9709 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9919))
                                    staticcall address(_9919).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10788 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11023 = mem[_10788]
                                    if mem[_10788] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11570] = 30
                                        mem[_11570 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11023 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11023:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11023 * sub_6cbe28ea) / sub_846374b8 - _11023 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11023 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11023 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11023 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11023 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11023 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = sub_a57f309a
                                _9229 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9230 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9230 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9616 = mem[_9230]
                                mem[_9229 + 100 len floor32(mem[_9230])] = mem[_9230 + 32 len floor32(mem[_9230])]
                                mem[_9229 + floor32(mem[_9230]) + -(mem[_9230] % 32) + 132 len mem[_9230] % 32] = mem[_9230 + -(mem[_9230] % 32) + floor32(mem[_9230]) + 64 len mem[_9230] % 32]
                                call sub_5d830fbeAddress.mem[_9229 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9229 + 104 len _9616 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9229 + 210 len 22]
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9229 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9229 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9229 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9229 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9229 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9229 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9229 + ceil32(return_data.size) + 211 len 22]
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9229 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9229 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9229 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9229 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            _8487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8487] = 3
                            mem[_8487 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8887 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8887]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9520 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9520] == mem[_9520 + 12 len 20]
                                    require ext_code.size(mem[_9520 + 12 len 20])
                                    staticcall mem[_9520 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10344 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10344] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10344]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10344] / mem[_10344] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10344]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10344] / sub_6cbe28ea * mem[_10344] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10344] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10344] / sub_846374b8
                                else:
                                    _9619 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9817 = mem[_9619]
                                    require mem[_9619] == mem[_9619 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9817))
                                    staticcall address(_9817).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10718 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10886 = mem[_10718]
                                    if mem[_10718] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11456] = 30
                                        mem[_11456 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10886 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10886:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10886 * sub_6cbe28ea) / sub_846374b8 - _10886 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10886 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10886 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10886 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10886 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10886 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = sub_a57f309a
                                _9154 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9155 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9155 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9524 = mem[_9155]
                                mem[mem[64] len floor32(mem[_9155])] = mem[_9155 + 32 len floor32(mem[_9155])]
                                mem[mem[64] + floor32(mem[_9155]) + -(mem[_9155] % 32) + 32 len mem[_9155] % 32] = mem[_9155 + floor32(mem[_9155]) + -(mem[_9155] % 32) + 64 len mem[_9155] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9524 + _9154 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16552 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16552] == mem[_16552 + 12 len 20]
                                            require ext_code.size(mem[_16552 + 12 len 20])
                                            staticcall mem[_16552 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17656 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17656] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17656]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17656] / mem[_17656] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17656]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17656] / sub_6cbe28ea * mem[_17656] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17656] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17656] / sub_846374b8
                                        else:
                                            _16722 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17052 = mem[_16722]
                                            require mem[_16722] == mem[_16722 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17052))
                                            staticcall address(_17052).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18174 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18414 = mem[_18174]
                                            if mem[_18174] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18698 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18698] = 30
                                                mem[_18698 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18414 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18414:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18414 * sub_6cbe28ea) / sub_846374b8 - _18414 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18414 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18414 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18414 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18414 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18414 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16889 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16889] == mem[_16889 + 12 len 20]
                                            require ext_code.size(mem[_16889 + 12 len 20])
                                            staticcall mem[_16889 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18015 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18015] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18015]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18015] / mem[_18015] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18015]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18015] / sub_6cbe28ea * mem[_18015] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18015] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18015] / sub_846374b8
                                        else:
                                            _17053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17252 = mem[_17053]
                                            require mem[_17053] == mem[_17053 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17252))
                                            staticcall address(_17252).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18415 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18532 = mem[_18415]
                                            if mem[_18415] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18938 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18938] = 30
                                                mem[_18938 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18532 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18532:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18532 * sub_6cbe28ea) / sub_846374b8 - _18532 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18532 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18532 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18532 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18532 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18532 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15208 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15208] = return_data.size
                                    mem[_15208 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16554 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16554] == mem[_16554 + 12 len 20]
                                            require ext_code.size(mem[_16554 + 12 len 20])
                                            staticcall mem[_16554 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17659 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17659] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17659]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17659] / mem[_17659] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17659]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17659] / sub_6cbe28ea * mem[_17659] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17659] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17659] / sub_846374b8
                                        else:
                                            _16724 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17054 = mem[_16724]
                                            require mem[_16724] == mem[_16724 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17054))
                                            staticcall address(_17054).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18176 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18416 = mem[_18176]
                                            if mem[_18176] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18701 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18701] = 30
                                                mem[_18701 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18416 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18416:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18416 * sub_6cbe28ea) / sub_846374b8 - _18416 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18416 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18416 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18416 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18416 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18416 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15208 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16891 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16891] == mem[_16891 + 12 len 20]
                                            require ext_code.size(mem[_16891 + 12 len 20])
                                            staticcall mem[_16891 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18017 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18017] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18017]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18017] / mem[_18017] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18017]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18017] / sub_6cbe28ea * mem[_18017] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18017] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18017] / sub_846374b8
                                        else:
                                            _17055 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17253 = mem[_17055]
                                            require mem[_17055] == mem[_17055 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17253))
                                            staticcall address(_17253).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18417 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18533 = mem[_18417]
                                            if mem[_18417] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18941 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18941] = 30
                                                mem[_18941 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18533 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18533:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18533 * sub_6cbe28ea) / sub_846374b8 - _18533 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18533 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18533 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18533 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18533 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18533 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7) - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7910 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7910] = 3
                    mem[_7910 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if _7450:
                        _8019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8019] = 26
                        mem[_8019 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8437 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8437] = 30
                        mem[_8437 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8942] = 3
                            mem[_8942 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9383 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9383]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10334 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10334] == mem[_10334 + 12 len 20]
                                    require ext_code.size(mem[_10334 + 12 len 20])
                                    staticcall mem[_10334 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11316 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11316] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11316]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11316] / mem[_11316] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11316]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11316] / sub_6cbe28ea * mem[_11316] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11316] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11316] / sub_846374b8
                                else:
                                    _10492 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10715 = mem[_10492]
                                    require mem[_10492] == mem[_10492 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10715))
                                    staticcall address(_10715).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11689 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11907 = mem[_11689]
                                    if mem[_11689] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12491] = 30
                                        mem[_12491 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11907 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11907:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11907 * sub_6cbe28ea) / sub_846374b8 - _11907 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11907 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11907 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11907 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11907 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11907 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9809 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9810 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9810 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10338 = mem[_9810]
                                mem[_9809 + 100 len floor32(mem[_9810])] = mem[_9810 + 32 len floor32(mem[_9810])]
                                mem[_9809 + floor32(mem[_9810]) + -(mem[_9810] % 32) + 132 len mem[_9810] % 32] = mem[_9810 + -(mem[_9810] % 32) + floor32(mem[_9810]) + 64 len mem[_9810] % 32]
                                call sub_5d830fbeAddress.mem[_9809 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9809 + 104 len _10338 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9809 + 210 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9809 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9809 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9809 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9809 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9809 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9809 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9809 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9809 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9809 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9809 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9809 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8989] = 3
                            mem[_8989 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9448 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9448]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10485 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10485] == mem[_10485 + 12 len 20]
                                    require ext_code.size(mem[_10485 + 12 len 20])
                                    staticcall mem[_10485 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11444 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11444] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11444]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11444] / mem[_11444] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11444]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11444] / sub_6cbe28ea * mem[_11444] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11444] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11444] / sub_846374b8
                                else:
                                    _10616 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10786 = mem[_10616]
                                    require mem[_10616] == mem[_10616 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10786))
                                    staticcall address(_10786).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11799 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _12028 = mem[_11799]
                                    if mem[_11799] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12654 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12654] = 30
                                        mem[_12654 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _12028 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _12028:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_12028 * sub_6cbe28ea) / sub_846374b8 - _12028 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_12028 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12028 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_12028 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12028 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12028 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9915 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9916 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9916 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10489 = mem[_9916]
                                mem[_9915 + 100 len floor32(mem[_9916])] = mem[_9916 + 32 len floor32(mem[_9916])]
                                mem[_9915 + floor32(mem[_9916]) + -(mem[_9916] % 32) + 132 len mem[_9916] % 32] = mem[_9916 + -(mem[_9916] % 32) + floor32(mem[_9916]) + 64 len mem[_9916] % 32]
                                call sub_5d830fbeAddress.mem[_9915 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9915 + 104 len _10489 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9915 + 210 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9915 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9915 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9915 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9915 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9915 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9915 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9915 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9915 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9915 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9915 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9915 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8141 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8141] = 30
                        mem[_8141 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8537 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8537] = 3
                            mem[_8537 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8941 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8941]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9604 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9604] == mem[_9604 + 12 len 20]
                                    require ext_code.size(mem[_9604 + 12 len 20])
                                    staticcall mem[_9604 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10480 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10480] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10480]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10480] / mem[_10480] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10480]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10480] / sub_6cbe28ea * mem[_10480] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10480] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10480] / sub_846374b8
                                else:
                                    _9707 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9913 = mem[_9707]
                                    require mem[_9707] == mem[_9707 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9913))
                                    staticcall address(_9913).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10783 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11008 = mem[_10783]
                                    if mem[_10783] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11561 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11561] = 30
                                        mem[_11561 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11008 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11008:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11008 * sub_6cbe28ea) / sub_846374b8 - _11008 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11008 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11008 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11008 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11008 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11008 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9223 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9224 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9224 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9608 = mem[_9224]
                                mem[_9223 + 100 len floor32(mem[_9224])] = mem[_9224 + 32 len floor32(mem[_9224])]
                                mem[_9223 + floor32(mem[_9224]) + -(mem[_9224] % 32) + 132 len mem[_9224] % 32] = mem[_9224 + -(mem[_9224] % 32) + floor32(mem[_9224]) + 64 len mem[_9224] % 32]
                                call sub_5d830fbeAddress.mem[_9223 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9223 + 104 len _9608 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9223 + 210 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9223 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9223 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9223 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9223 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9223 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9223 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9223 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9223 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9223 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9223 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9223 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8583 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8583] = 3
                            mem[_8583 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8988 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8988]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9700 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9700] == mem[_9700 + 12 len 20]
                                    require ext_code.size(mem[_9700 + 12 len 20])
                                    staticcall mem[_9700 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10610 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10610] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10610]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10610] / mem[_10610] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10610]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10610] / sub_6cbe28ea * mem[_10610] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10610] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10610] / sub_846374b8
                                else:
                                    _9802 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9991 = mem[_9802]
                                    require mem[_9802] == mem[_9802 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9991))
                                    staticcall address(_9991).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10873 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11159 = mem[_10873]
                                    if mem[_10873] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11679 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11679] = 30
                                        mem[_11679 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11159 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11159:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11159 * sub_6cbe28ea) / sub_846374b8 - _11159 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11159 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11159 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11159 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11159 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11159 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9306 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9307 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9307 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9704 = mem[_9307]
                                mem[mem[64] len floor32(mem[_9307])] = mem[_9307 + 32 len floor32(mem[_9307])]
                                mem[mem[64] + floor32(mem[_9307]) + -(mem[_9307] % 32) + 32 len mem[_9307] % 32] = mem[_9307 + floor32(mem[_9307]) + -(mem[_9307] % 32) + 64 len mem[_9307] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9704 + _9306 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16532 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16532] == mem[_16532 + 12 len 20]
                                            require ext_code.size(mem[_16532 + 12 len 20])
                                            staticcall mem[_16532 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17626 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17626] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17626]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17626] / mem[_17626] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17626]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17626] / sub_6cbe28ea * mem[_17626] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17626] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17626] / sub_846374b8
                                        else:
                                            _16702 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17032 = mem[_16702]
                                            require mem[_16702] == mem[_16702 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17032))
                                            staticcall address(_17032).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18154 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18394 = mem[_18154]
                                            if mem[_18154] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18668 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18668] = 30
                                                mem[_18668 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18394 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18394:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18394 * sub_6cbe28ea) / sub_846374b8 - _18394 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18394 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18394 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18394 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18394 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18394 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16869 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16869] == mem[_16869 + 12 len 20]
                                            require ext_code.size(mem[_16869 + 12 len 20])
                                            staticcall mem[_16869 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17995 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17995] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17995]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17995] / mem[_17995] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17995]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17995] / sub_6cbe28ea * mem[_17995] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17995] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17995] / sub_846374b8
                                        else:
                                            _17033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17242 = mem[_17033]
                                            require mem[_17033] == mem[_17033 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17242))
                                            staticcall address(_17242).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18395 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18522 = mem[_18395]
                                            if mem[_18395] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18908] = 30
                                                mem[_18908 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18522 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18522:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18522 * sub_6cbe28ea) / sub_846374b8 - _18522 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18522 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18522 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18522 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18522 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18522 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15189 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15189] = return_data.size
                                    mem[_15189 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16534 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16534] == mem[_16534 + 12 len 20]
                                            require ext_code.size(mem[_16534 + 12 len 20])
                                            staticcall mem[_16534 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17629 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17629] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17629]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17629] / mem[_17629] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17629]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17629] / sub_6cbe28ea * mem[_17629] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17629] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17629] / sub_846374b8
                                        else:
                                            _16704 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17034 = mem[_16704]
                                            require mem[_16704] == mem[_16704 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17034))
                                            staticcall address(_17034).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18156 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18396 = mem[_18156]
                                            if mem[_18156] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18671 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18671] = 30
                                                mem[_18671 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18396 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18396:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18396 * sub_6cbe28ea) / sub_846374b8 - _18396 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18396 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18396 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18396 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18396 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18396 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15189 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + (10^9 * sub_2730bcb7 * block.number - initialBlockNumber / sub_2730bcb7 * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16871 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16871] == mem[_16871 + 12 len 20]
                                            require ext_code.size(mem[_16871 + 12 len 20])
                                            staticcall mem[_16871 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17997 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17997] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17997]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17997] / mem[_17997] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17997]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17997] / sub_6cbe28ea * mem[_17997] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17997] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17997] / sub_846374b8
                                        else:
                                            _17035 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17243 = mem[_17035]
                                            require mem[_17035] == mem[_17035 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17243))
                                            staticcall address(_17243).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18397 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18523 = mem[_18397]
                                            if mem[_18397] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18911 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18911] = 30
                                                mem[_18911 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18523 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18523:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18523 * sub_6cbe28ea) / sub_846374b8 - _18523 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18523 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18523 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18523 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18523 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18523 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
        else:
            if initialBlockNumber < 0:
                revert with 0, 'SafeMath: addition overflow'
            _7576 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7576] = 30
            mem[_7576 + 32] = 'SafeMath: subtraction overflow'
            if initialBlockNumber > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            _7618 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7618] = 30
            mem[_7618 + 32] = 'SafeMath: subtraction overflow'
            if 1 > block.number - initialBlockNumber:
                revert with 0, 'SafeMath: subtraction overflow'
            if block.number + -initialBlockNumber - 1:
                if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / block.number + -initialBlockNumber - 1 != Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _7753 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7753] = 30
                mem[_7753 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not initialBlockNumber - lastBlockNumber:
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _7902 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7902] = 3
                    mem[_7902 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _7450:
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8116] = 30
                        mem[_8116 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8493] = 3
                            mem[_8493 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8895 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8895]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9532 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9532] == mem[_9532 + 12 len 20]
                                    require ext_code.size(mem[_9532 + 12 len 20])
                                    staticcall mem[_9532 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10375 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10375] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10375]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10375] / mem[_10375] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10375]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10375] / sub_6cbe28ea * mem[_10375] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10375] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10375] / sub_846374b8
                                else:
                                    _9637 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9838 = mem[_9637]
                                    require mem[_9637] == mem[_9637 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9838))
                                    staticcall address(_9838).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10733 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10914 = mem[_10733]
                                    if mem[_10733] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11483] = 30
                                        mem[_11483 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10914 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10914:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10914 * sub_6cbe28ea) / sub_846374b8 - _10914 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10914 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10914 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10914 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10914 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10914 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9165 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9166 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9166 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9536 = mem[_9166]
                                mem[_9165 + 100 len floor32(mem[_9166])] = mem[_9166 + 32 len floor32(mem[_9166])]
                                mem[_9165 + floor32(mem[_9166]) + -(mem[_9166] % 32) + 132 len mem[_9166] % 32] = mem[_9166 + -(mem[_9166] % 32) + floor32(mem[_9166]) + 64 len mem[_9166] % 32]
                                call sub_5d830fbeAddress.mem[_9165 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9165 + 104 len _9536 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9165 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9165 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9165 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9165 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9165 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9165 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9165 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9165 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9165 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9165 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9165 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9165 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8547] = 3
                            mem[_8547 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8948 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8948]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9630 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9630] == mem[_9630 + 12 len 20]
                                    require ext_code.size(mem[_9630 + 12 len 20])
                                    staticcall mem[_9630 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10521 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10521] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10521]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10521] / mem[_10521] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10521]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10521] / sub_6cbe28ea * mem[_10521] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10521] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10521] / sub_846374b8
                                else:
                                    _9728 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9934 = mem[_9728]
                                    require mem[_9728] == mem[_9728 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9934))
                                    staticcall address(_9934).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10805 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11056 = mem[_10805]
                                    if mem[_10805] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11598 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11598] = 30
                                        mem[_11598 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11056 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11056:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11056 * sub_6cbe28ea) / sub_846374b8 - _11056 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11056 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11056 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11056 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11056 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11056 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9243 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9244 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9244 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9634 = mem[_9244]
                                mem[_9243 + 100 len floor32(mem[_9244])] = mem[_9244 + 32 len floor32(mem[_9244])]
                                mem[_9243 + floor32(mem[_9244]) + -(mem[_9244] % 32) + 132 len mem[_9244] % 32] = mem[_9244 + -(mem[_9244] % 32) + floor32(mem[_9244]) + 64 len mem[_9244] % 32]
                                call sub_5d830fbeAddress.mem[_9243 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9243 + 104 len _9634 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9243 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9243 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9243 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9243 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9243 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9243 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9243 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9243 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9243 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9243 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9243 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9243 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        _7992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7992] = 26
                        mem[_7992 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8399] = 30
                        mem[_8399 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8896] = 3
                            mem[_8896 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9327 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9327]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10231 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10231] == mem[_10231 + 12 len 20]
                                    require ext_code.size(mem[_10231 + 12 len 20])
                                    staticcall mem[_10231 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11218 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11218] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11218]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11218] / mem[_11218] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11218]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11218] / sub_6cbe28ea * mem[_11218] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11218] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11218] / sub_846374b8
                                else:
                                    _10387 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10650 = mem[_10387]
                                    require mem[_10387] == mem[_10387 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10650))
                                    staticcall address(_10650).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11608 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11832 = mem[_11608]
                                    if mem[_11608] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12379] = 30
                                        mem[_12379 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11832 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11832:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11832 * sub_6cbe28ea) / sub_846374b8 - _11832 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11832 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11832 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11832 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11832 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11832 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9735 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9736 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9736 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10235 = mem[_9736]
                                mem[_9735 + 100 len floor32(mem[_9736])] = mem[_9736 + 32 len floor32(mem[_9736])]
                                mem[_9735 + floor32(mem[_9736]) + -(mem[_9736] % 32) + 132 len mem[_9736] % 32] = mem[_9736 + -(mem[_9736] % 32) + floor32(mem[_9736]) + 64 len mem[_9736] % 32]
                                call sub_5d830fbeAddress.mem[_9735 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9735 + 104 len _10235 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9735 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9735 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9735 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9735 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9735 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9735 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9735 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9735 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9735 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9735 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9735 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9735 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8949 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8949] = 3
                            mem[_8949 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9393 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9393]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10380 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10380] == mem[_10380 + 12 len 20]
                                    require ext_code.size(mem[_10380 + 12 len 20])
                                    staticcall mem[_10380 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11359 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11359] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11359]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11359] / mem[_11359] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11359]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11359] / sub_6cbe28ea * mem[_11359] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11359] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11359] / sub_846374b8
                                else:
                                    _10527 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10736 = mem[_10527]
                                    require mem[_10527] == mem[_10527 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10736))
                                    staticcall address(_10736).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11724 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11944 = mem[_11724]
                                    if mem[_11724] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12546 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12546] = 30
                                        mem[_12546 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11944 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11944:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11944 * sub_6cbe28ea) / sub_846374b8 - _11944 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11944 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11944 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11944 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11944 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11944 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9840 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9841 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9841 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10384 = mem[_9841]
                                mem[_9840 + 100 len floor32(mem[_9841])] = mem[_9841 + 32 len floor32(mem[_9841])]
                                mem[_9840 + floor32(mem[_9841]) + -(mem[_9841] % 32) + 132 len mem[_9841] % 32] = mem[_9841 + -(mem[_9841] % 32) + floor32(mem[_9841]) + 64 len mem[_9841] % 32]
                                call sub_5d830fbeAddress.mem[_9840 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9840 + 104 len _10384 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9840 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9840 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9840 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9840 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9840 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9840 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9840 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9840 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9840 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9840 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9840 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9840 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _7911 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7911] = 3
                    mem[_7911 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != -(Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if _7450:
                        _8024 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8024] = 26
                        mem[_8024 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8441 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8441] = 30
                        mem[_8441 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8947] = 3
                            mem[_8947 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9390 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9390]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10365 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10365] == mem[_10365 + 12 len 20]
                                    require ext_code.size(mem[_10365 + 12 len 20])
                                    staticcall mem[_10365 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11346 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11346] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11346]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11346] / mem[_11346] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11346]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11346] / sub_6cbe28ea * mem[_11346] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11346] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11346] / sub_846374b8
                                else:
                                    _10520 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10730 = mem[_10520]
                                    require mem[_10520] == mem[_10520 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10730))
                                    staticcall address(_10730).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11715 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11933 = mem[_11715]
                                    if mem[_11715] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12531 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12531] = 30
                                        mem[_12531 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11933 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11933:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11933 * sub_6cbe28ea) / sub_846374b8 - _11933 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11933 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11933 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11933 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11933 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11933 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9830 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9831 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9831 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10369 = mem[_9831]
                                mem[_9830 + 100 len floor32(mem[_9831])] = mem[_9831 + 32 len floor32(mem[_9831])]
                                mem[_9830 + floor32(mem[_9831]) + -(mem[_9831] % 32) + 132 len mem[_9831] % 32] = mem[_9831 + -(mem[_9831] % 32) + floor32(mem[_9831]) + 64 len mem[_9831] % 32]
                                call sub_5d830fbeAddress.mem[_9830 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9830 + 104 len _10369 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9830 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9830 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9830 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9830 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9830 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9830 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9830 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9830 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9830 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9830 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9830 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9830 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8995] = 3
                            mem[_8995 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9454 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9454]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10513 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10513] == mem[_10513 + 12 len 20]
                                    require ext_code.size(mem[_10513 + 12 len 20])
                                    staticcall mem[_10513 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11471 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11471] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11471]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11471] / mem[_11471] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11471]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11471] / sub_6cbe28ea * mem[_11471] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11471] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11471] / sub_846374b8
                                else:
                                    _10637 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10803 = mem[_10637]
                                    require mem[_10637] == mem[_10637 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10803))
                                    staticcall address(_10803).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11821 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _12059 = mem[_11821]
                                    if mem[_11821] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12687] = 30
                                        mem[_12687 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _12059 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _12059:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_12059 * sub_6cbe28ea) / sub_846374b8 - _12059 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_12059 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12059 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_12059 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12059 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_12059 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9930 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9931 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9931 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10517 = mem[_9931]
                                mem[_9930 + 100 len floor32(mem[_9931])] = mem[_9931 + 32 len floor32(mem[_9931])]
                                mem[_9930 + floor32(mem[_9931]) + -(mem[_9931] % 32) + 132 len mem[_9931] % 32] = mem[_9931 + -(mem[_9931] % 32) + floor32(mem[_9931]) + 64 len mem[_9931] % 32]
                                call sub_5d830fbeAddress.mem[_9930 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9930 + 104 len _10517 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9930 + 210 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9930 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9930 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9930 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9930 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9930 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9930 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9930 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9930 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9930 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9930 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9930 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8146] = 30
                        mem[_8146 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8543] = 3
                            mem[_8543 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8946 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8946]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9622 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9622] == mem[_9622 + 12 len 20]
                                    require ext_code.size(mem[_9622 + 12 len 20])
                                    staticcall mem[_9622 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10508 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10508] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10508]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10508] / mem[_10508] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10508]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10508] / sub_6cbe28ea * mem[_10508] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10508] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10508] / sub_846374b8
                                else:
                                    _9726 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9928 = mem[_9726]
                                    require mem[_9726] == mem[_9726 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9928))
                                    staticcall address(_9928).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10800 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11041 = mem[_10800]
                                    if mem[_10800] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11589] = 30
                                        mem[_11589 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11041 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11041:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11041 * sub_6cbe28ea) / sub_846374b8 - _11041 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11041 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11041 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11041 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11041 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11041 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9237 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9238 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9238 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9626 = mem[_9238]
                                mem[_9237 + 100 len floor32(mem[_9238])] = mem[_9238 + 32 len floor32(mem[_9238])]
                                mem[_9237 + floor32(mem[_9238]) + -(mem[_9238] % 32) + 132 len mem[_9238] % 32] = mem[_9238 + -(mem[_9238] % 32) + floor32(mem[_9238]) + 64 len mem[_9238] % 32]
                                call sub_5d830fbeAddress.mem[_9237 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9237 + 104 len _9626 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9237 + 210 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9237 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9237 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9237 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9237 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9237 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9237 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9237 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9237 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9237 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9237 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9237 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8590] = 3
                            mem[_8590 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8994 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8994]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9719 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9719] == mem[_9719 + 12 len 20]
                                    require ext_code.size(mem[_9719 + 12 len 20])
                                    staticcall mem[_9719 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10631 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10631] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10631]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10631] / mem[_10631] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10631]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10631] / sub_6cbe28ea * mem[_10631] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10631] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10631] / sub_846374b8
                                else:
                                    _9823 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10003 = mem[_9823]
                                    require mem[_9823] == mem[_9823 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10003))
                                    staticcall address(_10003).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11191 = mem[_10901]
                                    if mem[_10901] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11705 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11705] = 30
                                        mem[_11705 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11191 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11191:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11191 * sub_6cbe28ea) / sub_846374b8 - _11191 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11191 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11191 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11191 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11191 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11191 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9317 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9318 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9318 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9723 = mem[_9318]
                                mem[mem[64] len floor32(mem[_9318])] = mem[_9318 + 32 len floor32(mem[_9318])]
                                mem[mem[64] + floor32(mem[_9318]) + -(mem[_9318] % 32) + 32 len mem[_9318] % 32] = mem[_9318 + floor32(mem[_9318]) + -(mem[_9318] % 32) + 64 len mem[_9318] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9723 + _9317 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16564 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16564] == mem[_16564 + 12 len 20]
                                            require ext_code.size(mem[_16564 + 12 len 20])
                                            staticcall mem[_16564 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17674 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17674] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17674]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17674] / mem[_17674] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17674]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17674] / sub_6cbe28ea * mem[_17674] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17674] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17674] / sub_846374b8
                                        else:
                                            _16734 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17064 = mem[_16734]
                                            require mem[_16734] == mem[_16734 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17064))
                                            staticcall address(_17064).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18186 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18426 = mem[_18186]
                                            if mem[_18186] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18716 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18716] = 30
                                                mem[_18716 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18426 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18426:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18426 * sub_6cbe28ea) / sub_846374b8 - _18426 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18426 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18426 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18426 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18426 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18426 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16901 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16901] == mem[_16901 + 12 len 20]
                                            require ext_code.size(mem[_16901 + 12 len 20])
                                            staticcall mem[_16901 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18027 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18027] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18027]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18027] / mem[_18027] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18027]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18027] / sub_6cbe28ea * mem[_18027] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18027] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18027] / sub_846374b8
                                        else:
                                            _17065 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17258 = mem[_17065]
                                            require mem[_17065] == mem[_17065 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17258))
                                            staticcall address(_17258).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18427 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18538 = mem[_18427]
                                            if mem[_18427] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18956 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18956] = 30
                                                mem[_18956 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18538 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18538:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18538 * sub_6cbe28ea) / sub_846374b8 - _18538 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18538 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18538 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18538 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18538 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18538 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15225 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15225] = return_data.size
                                    mem[_15225 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16566 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16566] == mem[_16566 + 12 len 20]
                                            require ext_code.size(mem[_16566 + 12 len 20])
                                            staticcall mem[_16566 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17677 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17677] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17677]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17677] / mem[_17677] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17677]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17677] / sub_6cbe28ea * mem[_17677] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17677] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17677] / sub_846374b8
                                        else:
                                            _16736 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17066 = mem[_16736]
                                            require mem[_16736] == mem[_16736 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17066))
                                            staticcall address(_17066).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18188 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18428 = mem[_18188]
                                            if mem[_18188] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18719 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18719] = 30
                                                mem[_18719 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18428 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18428:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18428 * sub_6cbe28ea) / sub_846374b8 - _18428 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18428 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18428 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18428 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18428 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18428 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15225 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a = (-1 * 10^9 * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * block.number * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) - (10^9 * initialBlockNumber * Mask(256, -block.number - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -block.number - initialBlockNumber / sub_2730bcb7) + (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16903 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16903] == mem[_16903 + 12 len 20]
                                            require ext_code.size(mem[_16903 + 12 len 20])
                                            staticcall mem[_16903 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18029 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18029] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18029]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18029] / mem[_18029] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18029]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18029] / sub_6cbe28ea * mem[_18029] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18029] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18029] / sub_846374b8
                                        else:
                                            _17067 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17259 = mem[_17067]
                                            require mem[_17067] == mem[_17067 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17259))
                                            staticcall address(_17259).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18429 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18539 = mem[_18429]
                                            if mem[_18429] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18959 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18959] = 30
                                                mem[_18959 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18539 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18539:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18539 * sub_6cbe28ea) / sub_846374b8 - _18539 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18539 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18539 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18539 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18539 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18539 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
            else:
                _7745 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7745] = 30
                mem[_7745 + 32] = 'SafeMath: subtraction overflow'
                if lastBlockNumber > initialBlockNumber:
                    revert with 0, 'SafeMath: subtraction overflow'
                if initialBlockNumber - lastBlockNumber:
                    if (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / initialBlockNumber - lastBlockNumber != Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _7903 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7903] = 3
                    mem[_7903 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / 10^9 != (initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7):
                        revert with 0, ''
                    if not _7450:
                        if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8119] = 30
                        mem[_8119 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8497 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8497] = 3
                            mem[_8497 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8898 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8898]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9541 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9541] == mem[_9541 + 12 len 20]
                                    require ext_code.size(mem[_9541 + 12 len 20])
                                    staticcall mem[_9541 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10391 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10391] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10391]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10391] / mem[_10391] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10391]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10391] / sub_6cbe28ea * mem[_10391] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10391] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10391] / sub_846374b8
                                else:
                                    _9646 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9849 = mem[_9646]
                                    require mem[_9646] == mem[_9646 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9849))
                                    staticcall address(_9849).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10739 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10931 = mem[_10739]
                                    if mem[_10739] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11496 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11496] = 30
                                        mem[_11496 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10931 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10931:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10931 * sub_6cbe28ea) / sub_846374b8 - _10931 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10931 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10931 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10931 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10931 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10931 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9172 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9173 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9173 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9545 = mem[_9173]
                                mem[_9172 + 100 len floor32(mem[_9173])] = mem[_9173 + 32 len floor32(mem[_9173])]
                                mem[_9172 + floor32(mem[_9173]) + -(mem[_9173] % 32) + 132 len mem[_9173] % 32] = mem[_9173 + -(mem[_9173] % 32) + floor32(mem[_9173]) + 64 len mem[_9173] % 32]
                                call sub_5d830fbeAddress.mem[_9172 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9172 + 104 len _9545 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9172 + 210 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9172 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9172 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9172 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9172 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9172 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9172 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9172 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9172 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9172 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9172 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9172 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8549] = 3
                            mem[_8549 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8950 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8950]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9639 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9639] == mem[_9639 + 12 len 20]
                                    require ext_code.size(mem[_9639 + 12 len 20])
                                    staticcall mem[_9639 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10533 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10533] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10533]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10533] / mem[_10533] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10533]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10533] / sub_6cbe28ea * mem[_10533] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10533] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10533] / sub_846374b8
                                else:
                                    _9738 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9938 = mem[_9738]
                                    require mem[_9738] == mem[_9738 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9938))
                                    staticcall address(_9938).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10816 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11072 = mem[_10816]
                                    if mem[_10816] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11613 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11613] = 30
                                        mem[_11613 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11072 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11072:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11072 * sub_6cbe28ea) / sub_846374b8 - _11072 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11072 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11072 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11072 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11072 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11072 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                _9250 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (-1 * 10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9251 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9251 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9643 = mem[_9251]
                                mem[_9250 + 100 len floor32(mem[_9251])] = mem[_9251 + 32 len floor32(mem[_9251])]
                                mem[_9250 + floor32(mem[_9251]) + -(mem[_9251] % 32) + 132 len mem[_9251] % 32] = mem[_9251 + -(mem[_9251] % 32) + floor32(mem[_9251]) + 64 len mem[_9251] % 32]
                                call sub_5d830fbeAddress.mem[_9250 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9250 + 104 len _9643 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9250 + 210 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9250 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9250 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9250 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9250 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9250 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9250 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9250 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a = (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) + sub_a57f309a
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9250 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9250 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9250 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9250 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        _7995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7995] = 26
                        mem[_7995 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8401 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8401] = 30
                        mem[_8401 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8951] = 3
                            mem[_8951 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9396 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9396]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10396 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10396] == mem[_10396 + 12 len 20]
                                    require ext_code.size(mem[_10396 + 12 len 20])
                                    staticcall mem[_10396 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11373 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11373] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11373]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11373] / mem[_11373] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11373]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11373] / sub_6cbe28ea * mem[_11373] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11373] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11373] / sub_846374b8
                                else:
                                    _10539 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10742 = mem[_10539]
                                    require mem[_10539] == mem[_10539 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10742))
                                    staticcall address(_10742).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11735 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11959 = mem[_11735]
                                    if mem[_11735] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12565] = 30
                                        mem[_12565 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11959 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11959:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11959 * sub_6cbe28ea) / sub_846374b8 - _11959 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11959 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11959 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11959 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11959 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11959 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9851 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9852 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9852 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10400 = mem[_9852]
                                mem[_9851 + 100 len floor32(mem[_9852])] = mem[_9852 + 32 len floor32(mem[_9852])]
                                mem[_9851 + floor32(mem[_9852]) + -(mem[_9852] % 32) + 132 len mem[_9852] % 32] = mem[_9852 + -(mem[_9852] % 32) + floor32(mem[_9852]) + 64 len mem[_9852] % 32]
                                call sub_5d830fbeAddress.mem[_9851 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9851 + 104 len _10400 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9851 + 210 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9851 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9851 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9851 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9851 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9851 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9851 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9851 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9851 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9851 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9851 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9851 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            _8899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8899] = 3
                            mem[_8899 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9331 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9331]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10246 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10246] == mem[_10246 + 12 len 20]
                                    require ext_code.size(mem[_10246 + 12 len 20])
                                    staticcall mem[_10246 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11234 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11234] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11234]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11234] / mem[_11234] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11234]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11234] / sub_6cbe28ea * mem[_11234] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11234] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11234] / sub_846374b8
                                else:
                                    _10403 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10659 = mem[_10403]
                                    require mem[_10403] == mem[_10403 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10659))
                                    staticcall address(_10659).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11623 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11843 = mem[_11623]
                                    if mem[_11623] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12400] = 30
                                        mem[_12400 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11843 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11843:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11843 * sub_6cbe28ea) / sub_846374b8 - _11843 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11843 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11843 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11843 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11843 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11843 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = ((10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450) + sub_a57f309a
                                _9745 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9746 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9746 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10250 = mem[_9746]
                                mem[mem[64] len floor32(mem[_9746])] = mem[_9746 + 32 len floor32(mem[_9746])]
                                mem[mem[64] + floor32(mem[_9746]) + -(mem[_9746] % 32) + 32 len mem[_9746] % 32] = mem[_9746 + floor32(mem[_9746]) + -(mem[_9746] % 32) + 64 len mem[_9746] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10250 + _9745 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16608 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16608] == mem[_16608 + 12 len 20]
                                            require ext_code.size(mem[_16608 + 12 len 20])
                                            staticcall mem[_16608 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17740 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17740] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17740]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17740] / mem[_17740] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17740]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17740] / sub_6cbe28ea * mem[_17740] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17740] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17740] / sub_846374b8
                                        else:
                                            _16778 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17108 = mem[_16778]
                                            require mem[_16778] == mem[_16778 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17108))
                                            staticcall address(_17108).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18230 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18470 = mem[_18230]
                                            if mem[_18230] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18782 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18782] = 30
                                                mem[_18782 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18470 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18470:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18470 * sub_6cbe28ea) / sub_846374b8 - _18470 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18470 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18470 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18470 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18470 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18470 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16945 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16945] == mem[_16945 + 12 len 20]
                                            require ext_code.size(mem[_16945 + 12 len 20])
                                            staticcall mem[_16945 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18071 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18071] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18071]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18071] / mem[_18071] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18071]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18071] / sub_6cbe28ea * mem[_18071] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18071] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18071] / sub_846374b8
                                        else:
                                            _17109 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17280 = mem[_17109]
                                            require mem[_17109] == mem[_17109 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17280))
                                            staticcall address(_17280).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18471 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18560 = mem[_18471]
                                            if mem[_18471] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19022 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19022] = 30
                                                mem[_19022 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18560 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18560:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18560 * sub_6cbe28ea) / sub_846374b8 - _18560 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18560 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18560 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18560 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18560 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18560 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15268 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15268] = return_data.size
                                    mem[_15268 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16610 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16610] == mem[_16610 + 12 len 20]
                                            require ext_code.size(mem[_16610 + 12 len 20])
                                            staticcall mem[_16610 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17743 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17743] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17743]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17743] / mem[_17743] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17743]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17743] / sub_6cbe28ea * mem[_17743] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17743] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17743] / sub_846374b8
                                        else:
                                            _16780 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17110 = mem[_16780]
                                            require mem[_16780] == mem[_16780 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17110))
                                            staticcall address(_17110).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18232 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18472 = mem[_18232]
                                            if mem[_18232] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18785 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18785] = 30
                                                mem[_18785 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18472 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18472:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18472 * sub_6cbe28ea) / sub_846374b8 - _18472 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18472 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18472 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18472 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18472 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18472 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15268 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a += (10^9 * initialBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) - (10^9 * lastBlockNumber * Mask(256, -lastBlockNumber - initialBlockNumber / sub_2730bcb7, sub_bb5b5a6a) << -lastBlockNumber - initialBlockNumber / sub_2730bcb7) / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16947] == mem[_16947 + 12 len 20]
                                            require ext_code.size(mem[_16947 + 12 len 20])
                                            staticcall mem[_16947 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18073 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18073] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18073]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18073] / mem[_18073] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18073]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18073] / sub_6cbe28ea * mem[_18073] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18073] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18073] / sub_846374b8
                                        else:
                                            _17111 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17281 = mem[_17111]
                                            require mem[_17111] == mem[_17111 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17281))
                                            staticcall address(_17281).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18473 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18561 = mem[_18473]
                                            if mem[_18473] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19025 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19025] = 30
                                                mem[_19025 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18561 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18561:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18561 * sub_6cbe28ea) / sub_846374b8 - _18561 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18561 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18561 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18561 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18561 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18561 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                else:
                    _7890 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7890] = 3
                    mem[_7890 + 32] = 0x4d4d4f0000000000000000000000000000000000000000000000000000000000
                    if not _7450:
                        if sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8095 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8095] = 30
                        mem[_8095 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8446] = 3
                            mem[_8446 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8838 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_8838]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9462 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9462] == mem[_9462 + 12 len 20]
                                    require ext_code.size(mem[_9462 + 12 len 20])
                                    staticcall mem[_9462 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10256 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10256] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10256]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10256] / mem[_10256] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10256]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10256] / sub_6cbe28ea * mem[_10256] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10256] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10256] / sub_846374b8
                                else:
                                    _9556 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9753 = mem[_9556]
                                    require mem[_9556] == mem[_9556 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9753))
                                    staticcall address(_9753).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10662 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10829 = mem[_10662]
                                    if mem[_10662] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11385] = 30
                                        mem[_11385 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10829 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10829:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10829 * sub_6cbe28ea) / sub_846374b8 - _10829 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10829 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10829 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10829 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10829 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10829 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = sub_a57f309a
                                _9114 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9115 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9115 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9466 = mem[_9115]
                                mem[_9114 + 100 len floor32(mem[_9115])] = mem[_9115 + 32 len floor32(mem[_9115])]
                                mem[_9114 + floor32(mem[_9115]) + -(mem[_9115] % 32) + 132 len mem[_9115] % 32] = mem[_9115 + -(mem[_9115] % 32) + floor32(mem[_9115]) + 64 len mem[_9115] % 32]
                                call sub_5d830fbeAddress.mem[_9114 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9114 + 104 len _9466 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9114 + 210 len 22]
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9114 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9114 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9114 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9114 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9114 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9114 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9114 + ceil32(return_data.size) + 211 len 22]
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9114 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9114 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9114 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9114 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8501] = 3
                            mem[_8501 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8900 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_8900]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _9549 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9549] == mem[_9549 + 12 len 20]
                                    require ext_code.size(mem[_9549 + 12 len 20])
                                    staticcall mem[_9549 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10404 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_10404] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_10404]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_10404] / mem[_10404] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_10404]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_10404] / sub_6cbe28ea * mem[_10404] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_10404] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_10404] / sub_846374b8
                                else:
                                    _9648 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9855 = mem[_9648]
                                    require mem[_9648] == mem[_9648 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_9855))
                                    staticcall address(_9855).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10744 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10946 = mem[_10744]
                                    if mem[_10744] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _11505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11505] = 30
                                        mem[_11505 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _10946 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _10946:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_10946 * sub_6cbe28ea) / sub_846374b8 - _10946 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_10946 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10946 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_10946 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10946 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_10946 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = sub_a57f309a
                                _9178 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9179 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9179 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _9553 = mem[_9179]
                                mem[mem[64] len floor32(mem[_9179])] = mem[_9179 + 32 len floor32(mem[_9179])]
                                mem[mem[64] + floor32(mem[_9179]) + -(mem[_9179] % 32) + 32 len mem[_9179] % 32] = mem[_9179 + floor32(mem[_9179]) + -(mem[_9179] % 32) + 64 len mem[_9179] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9553 + _9178 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16612 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16612] == mem[_16612 + 12 len 20]
                                            require ext_code.size(mem[_16612 + 12 len 20])
                                            staticcall mem[_16612 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17746 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17746] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17746]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17746] / mem[_17746] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17746]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17746] / sub_6cbe28ea * mem[_17746] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17746] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17746] / sub_846374b8
                                        else:
                                            _16782 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17112 = mem[_16782]
                                            require mem[_16782] == mem[_16782 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17112))
                                            staticcall address(_17112).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18234 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18474 = mem[_18234]
                                            if mem[_18234] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18788 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18788] = 30
                                                mem[_18788 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18474 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18474:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18474 * sub_6cbe28ea) / sub_846374b8 - _18474 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18474 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18474 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18474 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18474 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18474 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16949 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16949] == mem[_16949 + 12 len 20]
                                            require ext_code.size(mem[_16949 + 12 len 20])
                                            staticcall mem[_16949 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18075 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18075] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18075]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18075] / mem[_18075] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18075]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18075] / sub_6cbe28ea * mem[_18075] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18075] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18075] / sub_846374b8
                                        else:
                                            _17113 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17282 = mem[_17113]
                                            require mem[_17113] == mem[_17113 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17282))
                                            staticcall address(_17282).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18475 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18562 = mem[_18475]
                                            if mem[_18475] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19028 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19028] = 30
                                                mem[_19028 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18562 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18562:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18562 * sub_6cbe28ea) / sub_846374b8 - _18562 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18562 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18562 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18562 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18562 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18562 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15275 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15275] = return_data.size
                                    mem[_15275 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16614 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16614] == mem[_16614 + 12 len 20]
                                            require ext_code.size(mem[_16614 + 12 len 20])
                                            staticcall mem[_16614 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17749] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17749]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17749] / mem[_17749] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17749]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17749] / sub_6cbe28ea * mem[_17749] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17749] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17749] / sub_846374b8
                                        else:
                                            _16784 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17114 = mem[_16784]
                                            require mem[_16784] == mem[_16784 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17114))
                                            staticcall address(_17114).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18236 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18476 = mem[_18236]
                                            if mem[_18236] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18791 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18791] = 30
                                                mem[_18791 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18476 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18476:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18476 * sub_6cbe28ea) / sub_846374b8 - _18476 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18476 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18476 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18476 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18476 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18476 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15275 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16951] == mem[_16951 + 12 len 20]
                                            require ext_code.size(mem[_16951 + 12 len 20])
                                            staticcall mem[_16951 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18077 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18077] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18077]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18077] / mem[_18077] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18077]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18077] / sub_6cbe28ea * mem[_18077] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18077] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18077] / sub_846374b8
                                        else:
                                            _17115 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17283 = mem[_17115]
                                            require mem[_17115] == mem[_17115 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17283))
                                            staticcall address(_17283).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18477 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18563 = mem[_18477]
                                            if mem[_18477] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19031 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19031] = 30
                                                mem[_19031 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18563 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18563:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18563 * sub_6cbe28ea) / sub_846374b8 - _18563 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18563 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18563 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18563 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18563 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18563 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                    else:
                        _7971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7971] = 26
                        mem[_7971 + 32] = 'SafeMath: division by zero'
                        if not _7450:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / _7450) + sub_a57f309a < sub_a57f309a:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 371
                        _8364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8364] = 30
                        mem[_8364 + 32] = 'SafeMath: subtraction overflow'
                        if sub_3acf4148[address(arg1)] > (0 / _7450) + sub_a57f309a:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)]:
                            _8839 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8839] = 3
                            mem[_8839 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9260 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if 0 > mem[_9260]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10131 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10131] == mem[_10131 + 12 len 20]
                                    require ext_code.size(mem[_10131 + 12 len 20])
                                    staticcall mem[_10131 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11099 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11099] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11099]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11099] / mem[_11099] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11099]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11099] / sub_6cbe28ea * mem[_11099] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11099] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11099] / sub_846374b8
                                else:
                                    _10268 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10552 = mem[_10268]
                                    require mem[_10268] == mem[_10268 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10552))
                                    staticcall address(_10552).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11515 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11746 = mem[_11515]
                                    if mem[_11515] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12259 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12259] = 30
                                        mem[_12259 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11746 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11746:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11746 * sub_6cbe28ea) / sub_846374b8 - _11746 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11746 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11746 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11746 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11746 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11746 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                                _9655 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = 0
                                _9656 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9656 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10135 = mem[_9656]
                                mem[_9655 + 100 len floor32(mem[_9656])] = mem[_9656 + 32 len floor32(mem[_9656])]
                                mem[_9655 + floor32(mem[_9656]) + -(mem[_9656] % 32) + 132 len mem[_9656] % 32] = mem[_9656 + -(mem[_9656] % 32) + floor32(mem[_9656]) + 64 len mem[_9656] % 32]
                                call sub_5d830fbeAddress.mem[_9655 + 100 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_9655 + 104 len _10135 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9655 + 210 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9655 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9655 + (2 * ceil32(return_data.size)) + 201 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9655 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9655 + (2 * ceil32(return_data.size)) + 265 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    mem[_9655 + 132 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9655 + 132]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_9655 + ceil32(return_data.size) + 211 len 22]
                                    sub_a57f309a += 0 / _7450
                                    lastBlockNumber = block.number
                                    require ext_code.size(sub_e56b22baAddress)
                                    staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                            gas gas_remaining wei
                                           args 0x574f570000000000000000000000000000000000000000000000000000000000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    if sub_2fee582f != 56:
                                        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not ext_call.return_data[0]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_6cbe28ea * ext_call.return_data[0] / ext_call.return_data[0] != sub_6cbe28ea:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[_9655 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                if not sub_6cbe28ea * ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_6cbe28ea * ext_call.return_data[0] != sub_5c7cdf12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9655 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 202 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8:
                                                        sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * ext_call.return_data[0] / sub_846374b8
                                    else:
                                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                                gas gas_remaining wei
                                               args sub_7dc65830Address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > sub_846374b8:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if sub_846374b8 - ext_call.return_data[0] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not sub_846374b8 - ext_call.return_data[0]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) / sub_846374b8 - ext_call.return_data[0] != sub_6cbe28ea:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[_9655 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                    if not (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea):
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (ext_call.return_data[0] * sub_6cbe28ea) != sub_5c7cdf12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[_9655 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 266 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                            sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (ext_call.return_data[0] * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                        else:
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) - (sub_3acf4148[address(arg1)] * ext_call.return_data[0]) / (0 / _7450) + sub_a57f309a - sub_3acf4148[address(arg1)] != ext_call.return_data[0]:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _8901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8901] = 3
                            mem[_8901 + 32] = 0x4d414f0000000000000000000000000000000000000000000000000000000000
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 < 500 * 10^6:
                                revert with 0, ''
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(sub_5d830fbeAddress)
                            staticcall sub_5d830fbeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9334 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9 > mem[_9334]:
                                mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                require ext_code.size(sub_e56b22baAddress)
                                staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                        gas gas_remaining wei
                                       args 0x574f570000000000000000000000000000000000000000000000000000000000
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if sub_2fee582f != 56:
                                    _10261 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10261] == mem[_10261 + 12 len 20]
                                    require ext_code.size(mem[_10261 + 12 len 20])
                                    staticcall mem[_10261 + 12 len 20].0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11247 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_11247] <= 0:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        if not mem[_11247]:
                                            require sub_846374b8
                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                sub_bb5b5a6a = 0 / sub_846374b8
                                        else:
                                            if sub_6cbe28ea * mem[_11247] / mem[_11247] != sub_6cbe28ea:
                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not sub_6cbe28ea * mem[_11247]:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if sub_5c7cdf12 * sub_6cbe28ea * mem[_11247] / sub_6cbe28ea * mem[_11247] != sub_5c7cdf12:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require sub_846374b8
                                                if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_11247] / sub_846374b8:
                                                    sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_11247] / sub_846374b8
                                else:
                                    _10410 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _10665 = mem[_10410]
                                    require mem[_10410] == mem[_10410 + 12 len 20]
                                    mem[mem[64] + 4] = sub_7dc65830Address
                                    require ext_code.size(address(_10665))
                                    staticcall address(_10665).0x70a08231 with:
                                            gas gas_remaining wei
                                           args sub_7dc65830Address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11632 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _11854 = mem[_11632]
                                    if mem[_11632] > sub_846374b8:
                                        if sub_bb5b5a6a:
                                            sub_bb5b5a6a = 0
                                    else:
                                        _12415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12415] = 30
                                        mem[_12415 + 32] = 'SafeMath: subtraction overflow'
                                        if sub_846374b8 - _11854 <= 0:
                                            if sub_bb5b5a6a:
                                                sub_bb5b5a6a = 0
                                        else:
                                            if not sub_846374b8 - _11854:
                                                require sub_846374b8
                                                if sub_bb5b5a6a != 0 / sub_846374b8:
                                                    sub_bb5b5a6a = 0 / sub_846374b8
                                            else:
                                                if (sub_846374b8 * sub_6cbe28ea) - (_11854 * sub_6cbe28ea) / sub_846374b8 - _11854 != sub_6cbe28ea:
                                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not (sub_846374b8 * sub_6cbe28ea) - (_11854 * sub_6cbe28ea):
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11854 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_11854 * sub_6cbe28ea) != sub_5c7cdf12:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11854 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                        sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_11854 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                            else:
                                mem[0] = arg1
                                mem[32] = 371
                                sub_3acf4148[address(arg1)] = (0 / _7450) + sub_a57f309a
                                _9755 = mem[64]
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = (0 / _7450 * ext_call.return_data[0]) + (sub_a57f309a * ext_call.return_data[0]) + (-1 * sub_3acf4148[address(arg1)] * ext_call.return_data[0]) + 500 * 10^6 / 10^9
                                _9756 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_9756 + 32 len 4] = unknown_0xa9059cbb(?????)
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                if not ext_code.hash(sub_5d830fbeAddress):
                                    revert with 0, 'SafeERC20: call to non-contract'
                                _10265 = mem[_9756]
                                mem[mem[64] len floor32(mem[_9756])] = mem[_9756 + 32 len floor32(mem[_9756])]
                                mem[mem[64] + floor32(mem[_9756]) + -(mem[_9756] % 32) + 32 len mem[_9756] % 32] = mem[_9756 + floor32(mem[_9756]) + -(mem[_9756] % 32) + 64 len mem[_9756] % 32]
                                call sub_5d830fbeAddress with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10265 + _9755 + -mem[64] + 96]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not mem[96]:
                                        sub_a57f309a += 0 / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16620 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16620] == mem[_16620 + 12 len 20]
                                            require ext_code.size(mem[_16620 + 12 len 20])
                                            staticcall mem[_16620 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17758 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17758] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17758]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17758] / mem[_17758] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17758]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17758] / sub_6cbe28ea * mem[_17758] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17758] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17758] / sub_846374b8
                                        else:
                                            _16790 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17120 = mem[_16790]
                                            require mem[_16790] == mem[_16790 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17120))
                                            staticcall address(_17120).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18242 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18482 = mem[_18242]
                                            if mem[_18242] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18800 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18800] = 30
                                                mem[_18800 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18482 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18482:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18482 * sub_6cbe28ea) / sub_846374b8 - _18482 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18482 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18482 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18482 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18482 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18482 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a += 0 / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16957 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16957] == mem[_16957 + 12 len 20]
                                            require ext_code.size(mem[_16957 + 12 len 20])
                                            staticcall mem[_16957 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18083 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18083] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18083]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18083] / mem[_18083] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18083]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18083] / sub_6cbe28ea * mem[_18083] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18083] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18083] / sub_846374b8
                                        else:
                                            _17121 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17286 = mem[_17121]
                                            require mem[_17121] == mem[_17121 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17286))
                                            staticcall address(_17286).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18483 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18566 = mem[_18483]
                                            if mem[_18483] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19040 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19040] = 30
                                                mem[_19040 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18566 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18566:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18566 * sub_6cbe28ea) / sub_846374b8 - _18566 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18566 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18566 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18566 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18566 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18566 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                else:
                                    _15281 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_15281] = return_data.size
                                    mem[_15281 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        sub_a57f309a += 0 / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16622 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16622] == mem[_16622 + 12 len 20]
                                            require ext_code.size(mem[_16622 + 12 len 20])
                                            staticcall mem[_16622 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17761 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_17761] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_17761]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_17761] / mem[_17761] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_17761]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_17761] / sub_6cbe28ea * mem[_17761] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_17761] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_17761] / sub_846374b8
                                        else:
                                            _16792 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17122 = mem[_16792]
                                            require mem[_16792] == mem[_16792 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17122))
                                            staticcall address(_17122).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18244 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18484 = mem[_18244]
                                            if mem[_18244] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _18803 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18803] = 30
                                                mem[_18803 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18484 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18484:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18484 * sub_6cbe28ea) / sub_846374b8 - _18484 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18484 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18484 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18484 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18484 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18484 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
                                    else:
                                        require return_data.size >= 32
                                        if not mem[_15281 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                        sub_a57f309a += 0 / _7450
                                        lastBlockNumber = block.number
                                        mem[mem[64] + 4] = 0x574f570000000000000000000000000000000000000000000000000000000000
                                        require ext_code.size(sub_e56b22baAddress)
                                        staticcall sub_e56b22baAddress.getAddress(bytes32 rg1) with:
                                                gas gas_remaining wei
                                               args 0x574f570000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if sub_2fee582f != 56:
                                            _16959 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_16959] == mem[_16959 + 12 len 20]
                                            require ext_code.size(mem[_16959 + 12 len 20])
                                            staticcall mem[_16959 + 12 len 20].0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18085 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if mem[_18085] <= 0:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                if not mem[_18085]:
                                                    require sub_846374b8
                                                    if sub_bb5b5a6a != 0 / sub_846374b8:
                                                        sub_bb5b5a6a = 0 / sub_846374b8
                                                else:
                                                    if sub_6cbe28ea * mem[_18085] / mem[_18085] != sub_6cbe28ea:
                                                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not sub_6cbe28ea * mem[_18085]:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if sub_5c7cdf12 * sub_6cbe28ea * mem[_18085] / sub_6cbe28ea * mem[_18085] != sub_5c7cdf12:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != sub_5c7cdf12 * sub_6cbe28ea * mem[_18085] / sub_846374b8:
                                                            sub_bb5b5a6a = sub_5c7cdf12 * sub_6cbe28ea * mem[_18085] / sub_846374b8
                                        else:
                                            _17123 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _17287 = mem[_17123]
                                            require mem[_17123] == mem[_17123 + 12 len 20]
                                            mem[mem[64] + 4] = sub_7dc65830Address
                                            require ext_code.size(address(_17287))
                                            staticcall address(_17287).0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args sub_7dc65830Address
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _18485 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _18567 = mem[_18485]
                                            if mem[_18485] > sub_846374b8:
                                                if sub_bb5b5a6a:
                                                    sub_bb5b5a6a = 0
                                            else:
                                                _19043 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19043] = 30
                                                mem[_19043 + 32] = 'SafeMath: subtraction overflow'
                                                if sub_846374b8 - _18567 <= 0:
                                                    if sub_bb5b5a6a:
                                                        sub_bb5b5a6a = 0
                                                else:
                                                    if not sub_846374b8 - _18567:
                                                        require sub_846374b8
                                                        if sub_bb5b5a6a != 0 / sub_846374b8:
                                                            sub_bb5b5a6a = 0 / sub_846374b8
                                                    else:
                                                        if (sub_846374b8 * sub_6cbe28ea) - (_18567 * sub_6cbe28ea) / sub_846374b8 - _18567 != sub_6cbe28ea:
                                                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not (sub_846374b8 * sub_6cbe28ea) - (_18567 * sub_6cbe28ea):
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != 0 / sub_846374b8:
                                                                sub_bb5b5a6a = 0 / sub_846374b8
                                                        else:
                                                            if (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18567 * sub_6cbe28ea * sub_5c7cdf12) / (sub_846374b8 * sub_6cbe28ea) - (_18567 * sub_6cbe28ea) != sub_5c7cdf12:
                                                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            require sub_846374b8
                                                            if sub_bb5b5a6a != (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18567 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8:
                                                                sub_bb5b5a6a = (sub_846374b8 * sub_6cbe28ea * sub_5c7cdf12) - (_18567 * sub_6cbe28ea * sub_5c7cdf12) / sub_846374b8
}



}

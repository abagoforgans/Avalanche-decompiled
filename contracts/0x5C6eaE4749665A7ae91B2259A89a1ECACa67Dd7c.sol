contract main {




// =====================  Runtime code  =====================


address stor0;
address stor1;
address stor3;
address stor4;

function _fallback() payable {
  stop
}

function sub_2180a542(?) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall 'console.log'.log(bytes32 arg1) with:
            gas gas_remaining wei
           args sha3(arg1)
    return sha3(arg1), 64, 32, arg1
}

function sub_8b79e06a(?) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + (32 * arg4.length) + 36 <= calldata.size
}

function sub_1940e0a2(?) {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require arg2 == address(arg2)
    require arg3 == arg3
    require 164 <= calldata.size
    require arg6 == arg6
    require arg7 == arg7
    if address(call.data[100]) == address(call.data[132]):
        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
    if address(call.data[100]) < address(call.data[132]):
        if not address(call.data[100]):
            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
        require ext_code.size(address(arg2))
        staticcall address(arg2).getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        if arg1 and 997 > -1 / arg1:
            revert with 'NH{q', 17
        if 997 * arg1 / 997 != arg1:
            revert with 0, 'ds-math-mul-overflow'
        if address(call.data[100]) == address(call.data[100]):
            if not ext_call.return_data[50 len 14]:
                if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)
            else:
                if 997 * arg1 and ext_call.return_data[50 len 14] > -1 / 997 * arg1:
                    revert with 'NH{q', 17
                if not ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * arg1:
                    revert with 0, 'ds-math-mul-overflow'
                if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)
        else:
            if not ext_call.return_data[18 len 14]:
                if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1)
            else:
                if 997 * arg1 and ext_call.return_data[18 len 14] > -1 / 997 * arg1:
                    revert with 'NH{q', 17
                if not ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * arg1:
                    revert with 0, 'ds-math-mul-overflow'
                if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1)
    else:
        if not address(call.data[132]):
            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
        require ext_code.size(address(arg2))
        staticcall address(arg2).getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        if arg1 and 997 > -1 / arg1:
            revert with 'NH{q', 17
        if 997 * arg1 / 997 != arg1:
            revert with 0, 'ds-math-mul-overflow'
        if address(call.data[100]) == address(call.data[132]):
            if not ext_call.return_data[50 len 14]:
                if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 0 / (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)
            else:
                if 997 * arg1 and ext_call.return_data[50 len 14] > -1 / 997 * arg1:
                    revert with 'NH{q', 17
                if not ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * arg1:
                    revert with 0, 'ds-math-mul-overflow'
                if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)
        else:
            if not ext_call.return_data[18 len 14]:
                if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 0 / (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1)
            else:
                if 997 * arg1 and ext_call.return_data[18 len 14] > -1 / 997 * arg1:
                    revert with 'NH{q', 17
                if not ext_call.return_data[18 len 14]:
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * arg1:
                    revert with 0, 'ds-math-mul-overflow'
                if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                    revert with 'NH{q', 17
                if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
                    revert with 'NH{q', 17
                if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
                    revert with 'NH{q', 18
                if 997 * arg1 * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < arg3:
                    revert with 0, 'DEXALOTOJ-01'
                require ext_code.size(stor1)
                call stor1.0x23b872dd with:
                     gas gas_remaining wei
                    args msg.sender, address(arg2), arg1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require arg4 == address(arg4)
                require arg5 == address(arg5)
                if address(arg4) == address(arg5):
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if address(arg4) < address(arg5):
                    if not address(arg4):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg4):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                else:
                    if not address(arg5):
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    require arg4 == address(arg4)
                    mem[ceil32(return_data.size) + 356 len 0] = None
                    require ext_code.size(address(arg2))
                    if address(arg4) == address(arg5):
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), address(this.address), 128, 0
                    else:
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor3)
                call stor3.0x68205ba0 with:
                     gas gas_remaining wei
                    args address(this.address), 'USDT.e', 997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 260] = arg7
    mem[ceil32(return_data.size) + 292] = 0
    mem[ceil32(return_data.size) + 324] = 1
    require ext_code.size(stor4)
    call stor4.0x45cd989b with:
         gas gas_remaining wei
        args 'AVAX/USDT.e', arg6, arg7, 0, 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(stor3)
    call stor3.getBalance(address arg1, bytes32 arg2) with:
         gas gas_remaining wei
        args address(this.address), 'AVAX'
    mem[ceil32(return_data.size) + 192 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_call.return_data[32] == ext_call.return_data[32]
    require ext_call.return_data[64] < 3
    if ext_call.return_data[32] < arg7:
        mem[(2 * ceil32(return_data.size)) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 196] = 32
        mem[(2 * ceil32(return_data.size)) + 228] = 12
        mem[(2 * ceil32(return_data.size)) + 260] = 'DEXALOTOJ-02'
        revert with memory
          from (2 * ceil32(return_data.size)) + 192
           len ceil32(return_data.size) + 100
    mem[(2 * ceil32(return_data.size)) + 196] = this.address
    mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[32]
    require ext_code.size(stor3)
    call stor3.withdrawNative(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args mem[(2 * ceil32(return_data.size)) + 196 len ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 192] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
    require ext_code.size(stor1)
    call stor1.deposit() with:
       value ext_call.return_data[32] wei
         gas gas_remaining wei
        args mem[(2 * ceil32(return_data.size)) + 196 len ceil32(return_data.size)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 196] = msg.sender
    mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[32]
    require ext_code.size(stor1)
    call stor1.0xa9059cbb with:
         gas gas_remaining wei
        args mem[(2 * ceil32(return_data.size)) + 196 len ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require msg.sender == stor0
}



}

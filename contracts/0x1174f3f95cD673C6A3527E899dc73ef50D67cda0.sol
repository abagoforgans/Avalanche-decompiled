contract main {




// =====================  Runtime code  =====================


#
#  - sub_1268c18d(?)
#
address owner;
array of address stor1;
address stor2;
array of address sub_0e3d474a;
array of struct stor5;
array of uint256 sub_4432e12b;
array of uint256 sub_20df060c;
uint256 sub_a733f691;
uint256 sub_297dc18c;
uint256 sub_74ee6d4f;
uint256 sub_aaf51b7e;
uint256 totalVolume;
uint256 totalSales;
uint256 sub_c99f2475;
uint256 sub_3fe1e117;
uint8 isMarketOpen;
uint8 sub_aca20f07; offset 8
array of uint8 stor1546678032441257452667456735582814959992782782816731922691272282333561699760;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699761;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699762;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699763;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699764;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699765;
array of uint256 stor1546678032441257452667456735582814959992782782816731922691272282333561699766;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699767;
array of struct stor1546678032441257452667456735582814959992782782816731922691272282333561699768;

function sub_0e3d474a(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_0e3d474a.length
    return sub_0e3d474a[arg1]
}

function sub_20df060c(?) {
    return sub_20df060c[msg.sender]
}

function sub_297dc18c(?) {
    return sub_297dc18c
}

function sub_3fe1e117(?) {
    return sub_3fe1e117
}

function sub_4432e12b(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_4432e12b.length
    return sub_4432e12b[arg1]
}

function sub_5f52cb53(?) {
    return sub_4432e12b.length
}

function totalVolume() {
    return totalVolume
}

function totalCollections() {
    return stor5.length
}

function totalSales() {
    return totalSales
}

function sub_74ee6d4f(?) {
    return sub_74ee6d4f
}

function owner() {
    return owner
}

function sub_a733f691(?) {
    return sub_a733f691
}

function sub_aaf51b7e(?) {
    return sub_aaf51b7e
}

function sub_aca20f07(?) {
    return bool(sub_aca20f07)
}

function supportedTokens(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < supportedTokens.length
    return address(supportedTokens[arg1].field_0)
}

function sub_c99f2475(?) {
    return sub_c99f2475
}

function isMarketOpen() {
    return bool(isMarketOpen)
}

function sub_f744a36d(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_20df060c[arg1]
    return sub_20df060c[arg1][arg2]
}

function _fallback() payable {
    revert
}

function openMarket() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    isMarketOpen = 1
}

function closeMarket() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    isMarketOpen = 0
}

function sub_607133a0(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_aca20f07 = 1
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_1ef1486a(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_a733f691 = arg1
}

function sub_03d2944c(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor2 = address(arg1)
}

function withdrawableBalance() {
    if eth.balance(this.address) <= sub_297dc18c:
        return 0
    if eth.balance(this.address) < sub_297dc18c:
        revert with 0, 17
    return (eth.balance(this.address) - sub_297dc18c)
}

function emergencyWithdraw() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function addSupportedToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    supportedTokens.length++
    address(supportedTokens[supportedTokens.length].field_0) = arg1
    sub_0e3d474a.length++
    sub_0e3d474a[sub_0e3d474a.length] = arg1
}

function sub_0dfd737a(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require eth.balance(this.address) >= sub_297dc18c
    sub_297dc18c = 0
    require ext_code.size(stor2)
    call stor2.0xd0e30db0 with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function sub_2e3e63a1(?) {
    require calldata.size - 4 >= 64
    if arg1 >= stor5.length:
        revert with 0, 'Invalid Collection'
    if not uint8(stor5[arg1].field_0):
        revert with 0, 'Collection no longer active'
    if arg1 >= stor5.length:
        revert with 0, 50
    if address(stor5[arg1].field_1792) != msg.sender:
        revert with 0, 'Invalid Owner'
    if arg1 >= stor5.length:
        revert with 0, 50
    stor5[arg1].field_1024 = arg2
}

function sub_b9d2326e(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 100:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Give a percentage value from 0 to 100'
    if arg2 > 100:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Give a percentage value from 0 to 100'
    sub_74ee6d4f = arg1
    sub_aaf51b7e = arg2
}

function withdrawBalance() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if eth.balance(this.address) <= sub_297dc18c:
        call msg.sender with:
             gas 2300 wei
    else:
        if eth.balance(this.address) < sub_297dc18c:
            revert with 0, 17
        call msg.sender with:
           value eth.balance(this.address) - sub_297dc18c wei
             gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_c1d3628e(?) {
    require calldata.size - 4 >= 64
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 <= supportedTokens.length:
        if arg2 > test266151307():
            revert with 0, 65
        mem[96] = arg2
        mem[64] = (32 * arg2) + 128
        if arg2:
            mem[128 len 32 * arg2] = call.data[calldata.size len 32 * arg2]
        idx = 0
        while idx < arg2:
            if arg1 > !idx:
                revert with 0, 17
            if arg1 + idx >= supportedTokens.length:
                revert with 0, 50
            mem[0] = 3
            if idx >= arg2:
                revert with 0, 50
            mem[(32 * idx) + 128] = address(stor[('name', 'supportedTokens', 3) + arg1 + idx].field_0)
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[(32 * arg2) + 128] = 32
        mem[(32 * arg2) + 160] = arg2
        idx = 0
        s = mem[64] + 64
        t = 128
        while idx < arg2:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len (64 * arg2) + -mem[64] + 192
    if supportedTokens.length < arg1:
        revert with 0, 17
    if supportedTokens.length - arg1 > test266151307():
        revert with 0, 65
    mem[96] = supportedTokens.length - arg1
    mem[64] = (32 * supportedTokens.length - arg1) + 128
    if supportedTokens.length - arg1:
        mem[128 len 32 * supportedTokens.length - arg1] = call.data[calldata.size len 32 * supportedTokens.length - arg1]
    idx = 0
    while idx < supportedTokens.length - arg1:
        if arg1 > !idx:
            revert with 0, 17
        if arg1 + idx >= supportedTokens.length:
            revert with 0, 50
        mem[0] = 3
        if idx >= mem[96]:
            revert with 0, 50
        mem[(32 * idx) + 128] = address(stor[('name', 'supportedTokens', 3) + arg1 + idx].field_0)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    mem[(32 * supportedTokens.length - arg1) + 128] = 32
    mem[(32 * supportedTokens.length - arg1) + 160] = mem[96]
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < mem[96]:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (32 * supportedTokens.length - arg1) + (32 * mem[96]) + -mem[64] + 192
}

function collections(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < stor5.length
    if bool(stor5[arg1].field_2048):
        if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
            revert with 0, 34
        if bool(stor5[arg1].field_2048):
            if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor5[arg1].field_2048):
                if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                    mem[128] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                else:
                    mem[128] = stor[sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_0
                    idx = 128
                    s = 0
                    while (uint255(stor5[arg1].field_2048) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor[s + sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                revert with 0, 34
            if stor5[arg1].field_2049 % 128:
                if 31 >= stor5[arg1].field_2049 % 128:
                    mem[128] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                else:
                    mem[128] = stor[sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_0
                    idx = 128
                    s = 0
                    while stor5[arg1].field_2049 % 128 + 96 > idx:
                        mem[idx + 32] = stor[s + sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        return bool(uint8(stor5[arg1].field_0)), 
               stor5[arg1].field_256,
               stor5[arg1].field_1024,
               stor5[arg1].field_1280,
               stor5[arg1].field_1536,
               address(stor5[arg1].field_1792),
               Array(len=2 * Mask(256, -1, stor5[arg1].field_2048), data=mem[128 len ceil32(uint255(stor5[arg1].field_2048) * 0.5)])
    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
        revert with 0, 34
    if bool(stor5[arg1].field_2048):
        if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor5[arg1].field_2048):
            if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                mem[128] = 256 * Mask(248, 0, stor5[arg1].field_2056)
            else:
                mem[128] = stor[sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_0
                idx = 128
                s = 0
                while (uint255(stor5[arg1].field_2048) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor[s + sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
            revert with 0, 34
        if stor5[arg1].field_2049 % 128:
            if 31 >= stor5[arg1].field_2049 % 128:
                mem[128] = 256 * Mask(248, 0, stor5[arg1].field_2056)
            else:
                mem[128] = stor[sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_0
                idx = 128
                s = 0
                while stor5[arg1].field_2049 % 128 + 96 > idx:
                    mem[idx + 32] = stor[s + sha3((9 * arg1) + ('name', 'stor5', 5) + 8)].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    return bool(uint8(stor5[arg1].field_0)), 
           stor5[arg1].field_256,
           stor5[arg1].field_1024,
           stor5[arg1].field_1280,
           stor5[arg1].field_1536,
           address(stor5[arg1].field_1792),
           Array(len=stor5[arg1].field_2048 % 128, data=mem[128 len ceil32(stor5[arg1].field_2049 % 128)])
}

function sub_142a3b45(?) {
    require calldata.size - 4 >= 128
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    idx = 0
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[100] <= test266151307()
    require calldata.size > cd[100] + 35
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(('cd', 100).length)) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 100).length
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len ('cd', 100).length] = call.data[cd[100] + 36 len ('cd', 100).length]
    if not isMarketOpen:
        revert with 0, 'Market is closed.'
    if ('cd', 4).length <= 1:
        revert with 0, 'Minimum 2 tokens must be present.'
    if ('cd', 4).length > sub_a733f691:
        revert with 0, 'It's more than the max tokens per collection.'
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 99] = 1
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 131] = stor5.length
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 163] = 96
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 195] = ceil32(32 * ('cd', 4).length) + 97
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 227] = cd[68]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 259] = sub_4432e12b.length
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 291] = sub_20df060c[msg.sender]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 323] = msg.sender
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 355] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98
    stor5.length++
    stor36B6[stor5.length] = 1
    stor36B6[stor5.length] = stor5.length
    stor36B6[stor5.length] = ('cd', 4).length
    if not ('cd', 4).length:
        idx = 0
        while stor36B6[stor5.length] > idx:
            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db2)] = 0
            idx = idx + 1
            continue 
        stor36B6[stor5.length] = ('cd', 36).length
        if not ('cd', 36).length:
            idx = 0
            while stor36B6[stor5.length] > idx:
                stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = 0
                idx = idx + 1
                continue 
            stor36B6[stor5.length] = cd[68]
            stor36B6[stor5.length] = sub_4432e12b.length
            stor36B6[stor5.length] = sub_20df060c[msg.sender]
            stor36B6[stor5.length] = msg.sender
            if bool(stor36B6[stor5.length].field_0):
                if bool(stor36B6[stor5.length].field_0) == uint255(stor36B6[stor5.length].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _3583 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _3657 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _3657
                            require ext_code.size(address(_3583))
                            call address(_3583).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _3657
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4586 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4668 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4668
                            require ext_code.size(address(_4586))
                            call address(_4586).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4668
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _3576 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _3652 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _3652
                                require ext_code.size(address(_3576))
                                call address(_3576).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _3652
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4580 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4662 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4662
                                require ext_code.size(address(_4580))
                                call address(_4580).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4662
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4138 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4226 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4226
                                require ext_code.size(address(_4138))
                                call address(_4138).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4226
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4934 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4998 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4998
                                require ext_code.size(address(_4934))
                                call address(_4934).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4998
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
            else:
                if bool(stor36B6[stor5.length].field_0) == stor36B6[stor5.length].field_1 % 128 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _3594 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _3666 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _3666
                            require ext_code.size(address(_3594))
                            call address(_3594).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _3666
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4596 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4678 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4678
                            require ext_code.size(address(_4596))
                            call address(_4596).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4678
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _3587 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _3661 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _3661
                                require ext_code.size(address(_3587))
                                call address(_3587).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _3661
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4590 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4672 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4672
                                require ext_code.size(address(_4590))
                                call address(_4590).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4672
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4148 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4236 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4236
                                require ext_code.size(address(_4148))
                                call address(_4148).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4236
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4936 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5000 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5000
                                require ext_code.size(address(_4936))
                                call address(_4936).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
        else:
            s = 0
            idx = ceil32(32 * ('cd', 4).length) + 129
            while ceil32(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 129 > idx:
                stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * ('cd', 36).length) + 31) >> 5
            while stor36B6[stor5.length] > idx:
                stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = 0
                idx = idx + 1
                continue 
            stor36B6[stor5.length] = cd[68]
            stor36B6[stor5.length] = sub_4432e12b.length
            stor36B6[stor5.length] = sub_20df060c[msg.sender]
            stor36B6[stor5.length] = msg.sender
            if bool(stor36B6[stor5.length].field_0):
                if bool(stor36B6[stor5.length].field_0) == uint255(stor36B6[stor5.length].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4163 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4249 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4249
                            require ext_code.size(address(_4163))
                            call address(_4163).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4249
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4946 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5010 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5010
                            require ext_code.size(address(_4946))
                            call address(_4946).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5010
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4156 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4244 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4244
                                require ext_code.size(address(_4156))
                                call address(_4156).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4244
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4940 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5004 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5004
                                require ext_code.size(address(_4940))
                                call address(_4940).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5004
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4602 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4684 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4684
                                require ext_code.size(address(_4602))
                                call address(_4602).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4684
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5170 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5198 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5198
                                require ext_code.size(address(_5170))
                                call address(_5170).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5198
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
            else:
                if bool(stor36B6[stor5.length].field_0) == stor36B6[stor5.length].field_1 % 128 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4174 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4258 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4258
                            require ext_code.size(address(_4174))
                            call address(_4174).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4258
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4956 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5020 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5020
                            require ext_code.size(address(_4956))
                            call address(_4956).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5020
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4167 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4253 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4253
                                require ext_code.size(address(_4167))
                                call address(_4167).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4253
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4950 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5014 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5014
                                require ext_code.size(address(_4950))
                                call address(_4950).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5014
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4612 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4694 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4694
                                require ext_code.size(address(_4612))
                                call address(_4612).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4694
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5172 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5200 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5200
                                require ext_code.size(address(_5172))
                                call address(_5172).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5200
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 4).length) + 128 > idx:
            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db2)] = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
        while stor36B6[stor5.length] > idx:
            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db2)] = 0
            idx = idx + 1
            continue 
        stor36B6[stor5.length] = ('cd', 36).length
        if not ('cd', 36).length:
            idx = 0
            while stor36B6[stor5.length] > idx:
                stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = 0
                idx = idx + 1
                continue 
            stor36B6[stor5.length] = cd[68]
            stor36B6[stor5.length] = sub_4432e12b.length
            stor36B6[stor5.length] = sub_20df060c[msg.sender]
            stor36B6[stor5.length] = msg.sender
            if bool(stor36B6[stor5.length].field_0):
                if bool(stor36B6[stor5.length].field_0) == uint255(stor36B6[stor5.length].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4185 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4267 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4267
                            require ext_code.size(address(_4185))
                            call address(_4185).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4267
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4966 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5030 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5030
                            require ext_code.size(address(_4966))
                            call address(_4966).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5030
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4178 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4262 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4262
                                require ext_code.size(address(_4178))
                                call address(_4178).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4262
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4960 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5024 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5024
                                require ext_code.size(address(_4960))
                                call address(_4960).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5024
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4622 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4704 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4704
                                require ext_code.size(address(_4622))
                                call address(_4622).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4704
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5174 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5202 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5202
                                require ext_code.size(address(_5174))
                                call address(_5174).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5202
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
            else:
                if bool(stor36B6[stor5.length].field_0) == stor36B6[stor5.length].field_1 % 128 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4196 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4276 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4276
                            require ext_code.size(address(_4196))
                            call address(_4196).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4276
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4976 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5040 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5040
                            require ext_code.size(address(_4976))
                            call address(_4976).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5040
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4189 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4271 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4271
                                require ext_code.size(address(_4189))
                                call address(_4189).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4271
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4970 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5034 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5034
                                require ext_code.size(address(_4970))
                                call address(_4970).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5034
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4632 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4714 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4714
                                require ext_code.size(address(_4632))
                                call address(_4632).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4714
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5176 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5204 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5204
                                require ext_code.size(address(_5176))
                                call address(_5176).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5204
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
        else:
            s = 0
            idx = ceil32(32 * ('cd', 4).length) + 129
            while ceil32(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 129 > idx:
                stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * ('cd', 36).length) + 31) >> 5
            while stor36B6[stor5.length] > idx:
                stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db3)] = 0
                idx = idx + 1
                continue 
            stor36B6[stor5.length] = cd[68]
            stor36B6[stor5.length] = sub_4432e12b.length
            stor36B6[stor5.length] = sub_20df060c[msg.sender]
            stor36B6[stor5.length] = msg.sender
            if bool(stor36B6[stor5.length].field_0):
                if bool(stor36B6[stor5.length].field_0) == uint255(stor36B6[stor5.length].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4647 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4727 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4727
                            require ext_code.size(address(_4647))
                            call address(_4647).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4727
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _5186 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5214 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5214
                            require ext_code.size(address(_5186))
                            call address(_5186).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5214
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4640 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4722 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4722
                                require ext_code.size(address(_4640))
                                call address(_4640).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4722
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5180 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5208 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5208
                                require ext_code.size(address(_5180))
                                call address(_5180).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5208
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while (uint255(stor36B6[stor5.length].field_0) * 0.5) + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4982 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5046 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5046
                                require ext_code.size(address(_4982))
                                call address(_4982).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5046
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5252 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5256 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5256
                                require ext_code.size(address(_5252))
                                call address(_5252).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5256
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
            else:
                if bool(stor36B6[stor5.length].field_0) == stor36B6[stor5.length].field_1 % 128 < 32:
                    revert with 0, 34
                if not ('cd', 100).length:
                    stor36B6[stor5.length].field_0 = 0
                    idx = 0
                    while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                        stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                        idx = idx + 1
                        continue 
                    sub_20df060c[msg.sender]++
                    sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                    sub_4432e12b.length++
                    sub_4432e12b[sub_4432e12b.length] = stor5.length
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                    if not supportedTokens.length:
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _4658 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _4736 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4736
                            require ext_code.size(address(_4658))
                            call address(_4658).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _4736
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                        s = 0
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                            mem[idx + 32] = address(supportedTokens[s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 36).length:
                                revert with 0, 50
                            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                revert with 0, 50
                            _5196 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            _5224 = mem[(32 * idx) + 128]
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5224
                            require ext_code.size(address(_5196))
                            call address(_5196).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), _5224
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                else:
                    stor36B6[stor5.length].field_0 = (2 * ('cd', 100).length) + 1
                    if ('cd', 100).length <= 0:
                        idx = 0
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4651 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _4731 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _4731
                                require ext_code.size(address(_4651))
                                call address(_4651).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _4731
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5190 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5218 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5218
                                require ext_code.size(address(_5190))
                                call address(_5190).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5218
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        stor[sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                        s = 1
                        idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 162
                        while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ('cd', 100).length + 130 > idx:
                            stor[s + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = (Mask(251, 0, ('cd', 100).length - 1) >> 5) + 1
                        while stor36B6[stor5.length].field_1 % 128 + 31 / 32 > idx:
                            stor[idx + sha3((9 * stor5.length) + 0x36b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db8)] = 0
                            idx = idx + 1
                            continue 
                        sub_20df060c[msg.sender]++
                        sub_20df060c[msg.sender][sub_20df060c[msg.sender]] = stor5.length
                        sub_4432e12b.length++
                        sub_4432e12b[sub_4432e12b.length] = stor5.length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 387] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _4992 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5056 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5056
                                require ext_code.size(address(_4992))
                                call address(_4992).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5056
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419] = address(supportedTokens.field_0)
                            idx = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419
                            s = 0
                            while ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 387 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 36).length:
                                    revert with 0, 50
                                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] >= supportedTokens.length:
                                    revert with 0, 50
                                _5254 = mem[(32 * mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + 419]
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                _5258 = mem[(32 * idx) + 128]
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 419] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 423] = msg.sender
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 455] = this.address
                                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(ceil32(('cd', 100).length)) + (32 * supportedTokens.length) + 487] = _5258
                                require ext_code.size(address(_5254))
                                call address(_5254).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), _5258
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
}

function sub_9e51ce60(?) {
    require calldata.size - 4 >= 64
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 <= sub_4432e12b.length:
        if arg2 > test266151307():
            revert with 0, 65
        mem[96] = arg2
        mem[64] = (32 * arg2) + 128
        if not arg2:
            idx = 0
            while idx < arg2:
                if arg1 > !idx:
                    revert with 0, 17
                if arg1 + idx >= sub_4432e12b.length:
                    revert with 0, 50
                if stor[('name', 'sub_4432e12b', 6) + arg1 + idx] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _200 = mem[64]
                mem[64] = mem[64] + 288
                mem[_200] = bool(uint8(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_0))
                mem[_200 + 32] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_256
                _201 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) + 32
                mem[_201] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512
                if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512:
                    mem[_200 + 64] = _201
                    _207 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_207] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_200 + 96] = _207
                        mem[_200 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_200 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_200 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_200 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _244 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_244] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_244 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_244 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _244 + 32
                                        t = sha3(mem[0])
                                        while _244 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_244 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_244 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _244 + 32
                                        t = sha3(mem[0])
                                        while _244 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_200 + 256] = _244
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _256 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_256] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_256 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_256 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _256 + 32
                                        t = sha3(mem[0])
                                        while _256 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_256 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_256 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _256 + 32
                                        t = sha3(mem[0])
                                        while _256 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_200 + 256] = _256
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_207 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _207 + 32
                        t = sha3(mem[0])
                        while _207 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_200 + 96] = _207
                        mem[_200 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_200 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_200 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_200 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _505 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_505] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_505 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_505 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _505 + 32
                                        t = sha3(mem[0])
                                        while _505 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_200 + 256] = _505
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_200 + 256] = _505
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_505 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_200 + 256] = _505
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_505 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _505 + 32
                            t = sha3(mem[0])
                            while _505 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_200 + 256] = _505
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _200
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _508 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_508] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_200 + 256] = _508
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_508 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_200 + 256] = _508
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_508 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _508 + 32
                            t = sha3(mem[0])
                            while _508 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_200 + 256] = _508
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _200
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_508 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_508 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _508 + 32
                                t = sha3(mem[0])
                                while _508 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_200 + 256] = _508
                else:
                    mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 2
                    mem[_201 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 2)].field_0
                    s = _201 + 32
                    t = sha3(mem[0])
                    while _201 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_200 + 64] = _201
                    _491 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_491] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_200 + 96] = _491
                        mem[_200 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_200 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_200 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_200 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _509 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_509] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_509 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_509 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _509 + 32
                                        t = sha3(mem[0])
                                        while _509 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_200 + 256] = _509
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_200 + 256] = _509
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_509 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_200 + 256] = _509
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_509 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _509 + 32
                            t = sha3(mem[0])
                            while _509 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_200 + 256] = _509
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _200
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _528 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_528] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_200 + 256] = _528
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_528 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_200 + 256] = _528
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _200
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_528 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _528 + 32
                            t = sha3(mem[0])
                            while _528 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_200 + 256] = _528
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _200
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_528 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_528 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _528 + 32
                                t = sha3(mem[0])
                                while _528 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_200 + 256] = _528
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_491 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _491 + 32
                        t = sha3(mem[0])
                        while _491 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_200 + 96] = _491
                        mem[_200 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_200 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_200 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_200 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _763 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_763] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_763 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_763 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _763 + 32
                                        t = sha3(mem[0])
                                        while _763 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_763 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_763 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _763 + 32
                                        t = sha3(mem[0])
                                        while _763 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_200 + 256] = _763
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _767 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_767] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_767 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_767 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _767 + 32
                                        t = sha3(mem[0])
                                        while _767 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_767 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_767 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _767 + 32
                                        t = sha3(mem[0])
                                        while _767 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_200 + 256] = _767
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _200
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _183 = mem[64]
            mem[mem[64]] = 32
            _185 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _185:
                mem[u] = t + -_183 - 64
                _361 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_361 + 32]
                _364 = mem[_361 + 64]
                mem[t + 64] = 288
                _370 = mem[_364]
                mem[t + 288] = mem[_364]
                v = 0
                w = _364 + 32
                x = t + 320
                while v < _370:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _497 = mem[_361 + 96]
                mem[t + 96] = (32 * _370) + 320
                _501 = mem[_497]
                mem[t + (32 * _370) + 320] = mem[_497]
                v = 0
                w = _497 + 32
                x = t + (32 * _370) + 352
                while v < _501:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_361 + 128]
                mem[t + 160] = mem[_361 + 160]
                mem[t + 192] = mem[_361 + 192]
                mem[t + 224] = mem[_361 + 236 len 20]
                _691 = mem[_361 + 256]
                mem[t + 256] = (32 * _370) + (32 * _501) + 352
                _725 = mem[_691]
                mem[t + (32 * _370) + (32 * _501) + 352] = mem[_691]
                v = 0
                while v < _725:
                    mem[v + t + (32 * _370) + (32 * _501) + 384] = mem[_691 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_725) > _725:
                    mem[t + (32 * _370) + (32 * _501) + _725 + 384] = 0
                v = ceil32(_725) + 1
                s = s + 32
                t = ceil32(_725) + t + (32 * _370) + (32 * _501) + 384
                u = u + 32
                continue 
        else:
            mem[64] = (32 * arg2) + 416
            mem[(32 * arg2) + 128] = 0
            mem[(32 * arg2) + 160] = 0
            mem[(32 * arg2) + 192] = 96
            mem[(32 * arg2) + 224] = 96
            mem[(32 * arg2) + 256] = 0
            mem[(32 * arg2) + 288] = 0
            mem[(32 * arg2) + 320] = 0
            mem[(32 * arg2) + 352] = 0
            mem[(32 * arg2) + 384] = 96
            mem[var16001] = (32 * arg2) + 128
            s = var16001
            idx = var16002
            while idx - 1:
                mem[64] = mem[64] + 288
                mem[(32 * arg2) + 128] = 0
                mem[(32 * arg2) + 160] = 0
                mem[(32 * arg2) + 192] = 96
                mem[(32 * arg2) + 224] = 96
                mem[(32 * arg2) + 256] = 0
                mem[(32 * arg2) + 288] = 0
                mem[(32 * arg2) + 320] = 0
                mem[(32 * arg2) + 352] = 0
                mem[(32 * arg2) + 384] = 96
                mem[s + 32] = (32 * arg2) + 128
                s = s + 32
                idx = idx - 1
                continue 
            idx = 0
            while idx < arg2:
                if arg1 > !idx:
                    revert with 0, 17
                if arg1 + idx >= sub_4432e12b.length:
                    revert with 0, 50
                if stor[('name', 'sub_4432e12b', 6) + arg1 + idx] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _532 = mem[64]
                mem[64] = mem[64] + 288
                mem[_532] = bool(uint8(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_0))
                mem[_532 + 32] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_256
                _533 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) + 32
                mem[_533] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512
                if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512:
                    mem[_532 + 64] = _533
                    _546 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_546] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_532 + 96] = _546
                        mem[_532 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_532 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_532 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_532 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _593 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_593] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_593 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_593 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _593 + 32
                                        t = sha3(mem[0])
                                        while _593 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_593 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_593 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _593 + 32
                                        t = sha3(mem[0])
                                        while _593 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_532 + 256] = _593
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _613 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_613] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_613 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_613 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _613 + 32
                                        t = sha3(mem[0])
                                        while _613 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_613 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_613 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _613 + 32
                                        t = sha3(mem[0])
                                        while _613 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_532 + 256] = _613
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_546 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _546 + 32
                        t = sha3(mem[0])
                        while _546 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_532 + 96] = _546
                        mem[_532 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_532 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_532 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_532 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _764 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_764] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_764 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_764 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _764 + 32
                                        t = sha3(mem[0])
                                        while _764 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_532 + 256] = _764
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_532 + 256] = _764
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_764 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_532 + 256] = _764
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_764 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _764 + 32
                            t = sha3(mem[0])
                            while _764 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_532 + 256] = _764
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _532
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _769 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_769] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_532 + 256] = _769
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_769 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_532 + 256] = _769
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_769 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _769 + 32
                            t = sha3(mem[0])
                            while _769 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_532 + 256] = _769
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _532
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_769 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_769 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _769 + 32
                                t = sha3(mem[0])
                                while _769 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_532 + 256] = _769
                else:
                    mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 2
                    mem[_533 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 2)].field_0
                    s = _533 + 32
                    t = sha3(mem[0])
                    while _533 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_532 + 64] = _533
                    _751 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_751] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_532 + 96] = _751
                        mem[_532 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_532 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_532 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_532 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _770 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_770] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_770 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_770 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _770 + 32
                                        t = sha3(mem[0])
                                        while _770 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_532 + 256] = _770
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_532 + 256] = _770
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_770 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_532 + 256] = _770
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_770 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _770 + 32
                            t = sha3(mem[0])
                            while _770 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_532 + 256] = _770
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _532
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _780 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_780] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_532 + 256] = _780
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_780 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_532 + 256] = _780
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _532
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_780 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _780 + 32
                            t = sha3(mem[0])
                            while _780 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_532 + 256] = _780
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _532
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_780 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_780 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _780 + 32
                                t = sha3(mem[0])
                                while _780 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_532 + 256] = _780
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_751 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _751 + 32
                        t = sha3(mem[0])
                        while _751 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_532 + 96] = _751
                        mem[_532 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_532 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_532 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_532 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _929 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_929] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_929 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_929 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _929 + 32
                                        t = sha3(mem[0])
                                        while _929 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_929 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_929 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _929 + 32
                                        t = sha3(mem[0])
                                        while _929 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_532 + 256] = _929
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _931 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_931] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_931 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_931 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _931 + 32
                                        t = sha3(mem[0])
                                        while _931 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_931 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_931 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _931 + 32
                                        t = sha3(mem[0])
                                        while _931 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_532 + 256] = _931
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _532
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _498 = mem[64]
            mem[mem[64]] = 32
            _502 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _502:
                mem[u] = t + -_498 - 64
                _678 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_678 + 32]
                _681 = mem[_678 + 64]
                mem[t + 64] = 288
                _701 = mem[_681]
                mem[t + 288] = mem[_681]
                v = 0
                w = _681 + 32
                x = t + 320
                while v < _701:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _759 = mem[_678 + 96]
                mem[t + 96] = (32 * _701) + 320
                _761 = mem[_759]
                mem[t + (32 * _701) + 320] = mem[_759]
                v = 0
                w = _759 + 32
                x = t + (32 * _701) + 352
                while v < _761:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_678 + 128]
                mem[t + 160] = mem[_678 + 160]
                mem[t + 192] = mem[_678 + 192]
                mem[t + 224] = mem[_678 + 236 len 20]
                _897 = mem[_678 + 256]
                mem[t + 256] = (32 * _701) + (32 * _761) + 352
                _923 = mem[_897]
                mem[t + (32 * _701) + (32 * _761) + 352] = mem[_897]
                v = 0
                while v < _923:
                    mem[v + t + (32 * _701) + (32 * _761) + 384] = mem[_897 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_923) > _923:
                    mem[t + (32 * _701) + (32 * _761) + _923 + 384] = 0
                v = ceil32(_923) + 1
                s = s + 32
                t = ceil32(_923) + t + (32 * _701) + (32 * _761) + 384
                u = u + 32
                continue 
    else:
        if sub_4432e12b.length < arg1:
            revert with 0, 17
        if sub_4432e12b.length - arg1 > test266151307():
            revert with 0, 65
        mem[96] = sub_4432e12b.length - arg1
        mem[64] = (32 * sub_4432e12b.length - arg1) + 128
        if not sub_4432e12b.length - arg1:
            idx = 0
            while idx < sub_4432e12b.length - arg1:
                if arg1 > !idx:
                    revert with 0, 17
                if arg1 + idx >= sub_4432e12b.length:
                    revert with 0, 50
                if stor[('name', 'sub_4432e12b', 6) + arg1 + idx] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _205 = mem[64]
                mem[64] = mem[64] + 288
                mem[_205] = bool(uint8(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_0))
                mem[_205 + 32] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_256
                _206 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) + 32
                mem[_206] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512
                if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512:
                    mem[_205 + 64] = _206
                    _210 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_210] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_205 + 96] = _210
                        mem[_205 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_205 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_205 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_205 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _248 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_248] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_248 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_248 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _248 + 32
                                        t = sha3(mem[0])
                                        while _248 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_248 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_248 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _248 + 32
                                        t = sha3(mem[0])
                                        while _248 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_205 + 256] = _248
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _264 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_264] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_264 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_264 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _264 + 32
                                        t = sha3(mem[0])
                                        while _264 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_264 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_264 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _264 + 32
                                        t = sha3(mem[0])
                                        while _264 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_205 + 256] = _264
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_210 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _210 + 32
                        t = sha3(mem[0])
                        while _210 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_205 + 96] = _210
                        mem[_205 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_205 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_205 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_205 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _506 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_506] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_506 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_506 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _506 + 32
                                        t = sha3(mem[0])
                                        while _506 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_205 + 256] = _506
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_205 + 256] = _506
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_506 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_205 + 256] = _506
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_506 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _506 + 32
                            t = sha3(mem[0])
                            while _506 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_205 + 256] = _506
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _205
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _516 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_516] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_205 + 256] = _516
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_516 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_205 + 256] = _516
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_516 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _516 + 32
                            t = sha3(mem[0])
                            while _516 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_205 + 256] = _516
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _205
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_516 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_516 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _516 + 32
                                t = sha3(mem[0])
                                while _516 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_205 + 256] = _516
                else:
                    mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 2
                    mem[_206 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 2)].field_0
                    s = _206 + 32
                    t = sha3(mem[0])
                    while _206 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_205 + 64] = _206
                    _492 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_492] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_205 + 96] = _492
                        mem[_205 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_205 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_205 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_205 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _517 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_517] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_517 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_517 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _517 + 32
                                        t = sha3(mem[0])
                                        while _517 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_205 + 256] = _517
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_205 + 256] = _517
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_517 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_205 + 256] = _517
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_517 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _517 + 32
                            t = sha3(mem[0])
                            while _517 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_205 + 256] = _517
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _205
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _539 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_539] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_205 + 256] = _539
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_539 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_205 + 256] = _539
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _205
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_539 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _539 + 32
                            t = sha3(mem[0])
                            while _539 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_205 + 256] = _539
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _205
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_539 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_539 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _539 + 32
                                t = sha3(mem[0])
                                while _539 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_205 + 256] = _539
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_492 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _492 + 32
                        t = sha3(mem[0])
                        while _492 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_205 + 96] = _492
                        mem[_205 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_205 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_205 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_205 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _765 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_765] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_765 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_765 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _765 + 32
                                        t = sha3(mem[0])
                                        while _765 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_765 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_765 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _765 + 32
                                        t = sha3(mem[0])
                                        while _765 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_205 + 256] = _765
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _771 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_771] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_771 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_771 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _771 + 32
                                        t = sha3(mem[0])
                                        while _771 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_771 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_771 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _771 + 32
                                        t = sha3(mem[0])
                                        while _771 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_205 + 256] = _771
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _205
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _184 = mem[64]
            mem[mem[64]] = 32
            _186 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _186:
                mem[u] = t + -_184 - 64
                _365 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_365 + 32]
                _368 = mem[_365 + 64]
                mem[t + 64] = 288
                _376 = mem[_368]
                mem[t + 288] = mem[_368]
                v = 0
                w = _368 + 32
                x = t + 320
                while v < _376:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _499 = mem[_365 + 96]
                mem[t + 96] = (32 * _376) + 320
                _503 = mem[_499]
                mem[t + (32 * _376) + 320] = mem[_499]
                v = 0
                w = _499 + 32
                x = t + (32 * _376) + 352
                while v < _503:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_365 + 128]
                mem[t + 160] = mem[_365 + 160]
                mem[t + 192] = mem[_365 + 192]
                mem[t + 224] = mem[_365 + 236 len 20]
                _710 = mem[_365 + 256]
                mem[t + 256] = (32 * _376) + (32 * _503) + 352
                _726 = mem[_710]
                mem[t + (32 * _376) + (32 * _503) + 352] = mem[_710]
                v = 0
                while v < _726:
                    mem[v + t + (32 * _376) + (32 * _503) + 384] = mem[_710 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_726) > _726:
                    mem[t + (32 * _376) + (32 * _503) + _726 + 384] = 0
                v = ceil32(_726) + 1
                s = s + 32
                t = ceil32(_726) + t + (32 * _376) + (32 * _503) + 384
                u = u + 32
                continue 
        else:
            mem[64] = (32 * sub_4432e12b.length - arg1) + 416
            mem[(32 * sub_4432e12b.length - arg1) + 128] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 160] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 192] = 96
            mem[(32 * sub_4432e12b.length - arg1) + 224] = 96
            mem[(32 * sub_4432e12b.length - arg1) + 256] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 288] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 320] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 352] = 0
            mem[(32 * sub_4432e12b.length - arg1) + 384] = 96
            mem[var20001] = (32 * sub_4432e12b.length - arg1) + 128
            s = var20001
            idx = var20002
            while idx - 1:
                mem[64] = mem[64] + 288
                mem[(32 * sub_4432e12b.length - arg1) + 128] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 160] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 192] = 96
                mem[(32 * sub_4432e12b.length - arg1) + 224] = 96
                mem[(32 * sub_4432e12b.length - arg1) + 256] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 288] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 320] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 352] = 0
                mem[(32 * sub_4432e12b.length - arg1) + 384] = 96
                mem[s + 32] = (32 * sub_4432e12b.length - arg1) + 128
                s = s + 32
                idx = idx - 1
                continue 
            idx = 0
            while idx < sub_4432e12b.length - arg1:
                if arg1 > !idx:
                    revert with 0, 17
                if arg1 + idx >= sub_4432e12b.length:
                    revert with 0, 50
                if stor[('name', 'sub_4432e12b', 6) + arg1 + idx] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _543 = mem[64]
                mem[64] = mem[64] + 288
                mem[_543] = bool(uint8(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_0))
                mem[_543 + 32] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_256
                _544 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) + 32
                mem[_544] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512
                if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512:
                    mem[_543 + 64] = _544
                    _549 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_549] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_543 + 96] = _549
                        mem[_543 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_543 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_543 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_543 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _602 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_602] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_602 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_602 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _602 + 32
                                        t = sha3(mem[0])
                                        while _602 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_602 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_602 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _602 + 32
                                        t = sha3(mem[0])
                                        while _602 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_543 + 256] = _602
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _624 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_624] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_624 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_624 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _624 + 32
                                        t = sha3(mem[0])
                                        while _624 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_624 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_624 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _624 + 32
                                        t = sha3(mem[0])
                                        while _624 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_543 + 256] = _624
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_549 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _549 + 32
                        t = sha3(mem[0])
                        while _549 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_543 + 96] = _549
                        mem[_543 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_543 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_543 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_543 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _766 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_766] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_766 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_766 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _766 + 32
                                        t = sha3(mem[0])
                                        while _766 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_543 + 256] = _766
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_543 + 256] = _766
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_766 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_543 + 256] = _766
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_766 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _766 + 32
                            t = sha3(mem[0])
                            while _766 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_543 + 256] = _766
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _543
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _773 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_773] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_543 + 256] = _773
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_773 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_543 + 256] = _773
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_773 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _773 + 32
                            t = sha3(mem[0])
                            while _773 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_543 + 256] = _773
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _543
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_773 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_773 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _773 + 32
                                t = sha3(mem[0])
                                while _773 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_543 + 256] = _773
                else:
                    mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 2
                    mem[_544 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 2)].field_0
                    s = _544 + 32
                    t = sha3(mem[0])
                    while _544 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_543 + 64] = _544
                    _752 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) + 32
                    mem[_752] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768
                    if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768:
                        mem[_543 + 96] = _752
                        mem[_543 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_543 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_543 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_543 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _774 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_774] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_774 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_774 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _774 + 32
                                        t = sha3(mem[0])
                                        while _774 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_543 + 256] = _774
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_543 + 256] = _774
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_774 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_543 + 256] = _774
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_774 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _774 + 32
                            t = sha3(mem[0])
                            while _774 + stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_543 + 256] = _774
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _543
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _786 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                        mem[_786] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                mem[_543 + 256] = _786
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                mem[_786 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                mem[_543 + 256] = _786
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _543
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                            mem[_786 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                            s = _786 + 32
                            t = sha3(mem[0])
                            while _786 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + s]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_543 + 256] = _786
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _543
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                            if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                mem[_786 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                mem[_786 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                s = _786 + 32
                                t = sha3(mem[0])
                                while _786 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_543 + 256] = _786
                    else:
                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 3
                        mem[_752 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 3)].field_0
                        s = _752 + 32
                        t = sha3(mem[0])
                        while _752 + (32 * stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_543 + 96] = _752
                        mem[_543 + 128] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1024
                        mem[_543 + 160] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1280
                        mem[_543 + 192] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1536
                        mem[_543 + 224] = address(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_1792)
                        if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _930 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) + 32
                            mem[_930] = uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_930 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_930 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _930 + 32
                                        t = sha3(mem[0])
                                        while _930 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_930 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_930 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _930 + 32
                                        t = sha3(mem[0])
                                        while _930 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_543 + 256] = _930
                        else:
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _932 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128) + 32
                            mem[_932] = stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128
                            if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048):
                                    if 31 >= uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5:
                                        mem[_932 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_932 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _932 + 32
                                        t = sha3(mem[0])
                                        while _932 + (uint255(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2048) == stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                    if 31 >= stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128:
                                        mem[_932 + 32] = 256 * Mask(248, 0, stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('name', 'sub_4432e12b', 6) + arg1 + idx]) + 8
                                        mem[_932 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('name', 'stor6', 6) + arg1 + idx]) + 8)].field_0
                                        s = _932 + 32
                                        t = sha3(mem[0])
                                        while _932 + stor5[stor[('name', 'stor6', 6) + arg1 + idx]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_543 + 256] = _932
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _543
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _500 = mem[64]
            mem[mem[64]] = 32
            _504 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _504:
                mem[u] = t + -_500 - 64
                _683 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_683 + 32]
                _686 = mem[_683 + 64]
                mem[t + 64] = 288
                _720 = mem[_686]
                mem[t + 288] = mem[_686]
                v = 0
                w = _686 + 32
                x = t + 320
                while v < _720:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _760 = mem[_683 + 96]
                mem[t + 96] = (32 * _720) + 320
                _762 = mem[_760]
                mem[t + (32 * _720) + 320] = mem[_760]
                v = 0
                w = _760 + 32
                x = t + (32 * _720) + 352
                while v < _762:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_683 + 128]
                mem[t + 160] = mem[_683 + 160]
                mem[t + 192] = mem[_683 + 192]
                mem[t + 224] = mem[_683 + 236 len 20]
                _914 = mem[_683 + 256]
                mem[t + 256] = (32 * _720) + (32 * _762) + 352
                _924 = mem[_914]
                mem[t + (32 * _720) + (32 * _762) + 352] = mem[_914]
                v = 0
                while v < _924:
                    mem[v + t + (32 * _720) + (32 * _762) + 384] = mem[_914 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_924) > _924:
                    mem[t + (32 * _720) + (32 * _762) + _924 + 384] = 0
                v = ceil32(_924) + 1
                s = s + 32
                t = ceil32(_924) + t + (32 * _720) + (32 * _762) + 384
                u = u + 32
                continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function sub_215fa2c6(?) {
    require calldata.size - 4 >= 64
    mem[0] = msg.sender
    mem[32] = 7
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 <= sub_20df060c[msg.sender]:
        if arg2 > test266151307():
            revert with 0, 65
        mem[96] = arg2
        mem[64] = (32 * arg2) + 128
        if not arg2:
            idx = 0
            while idx < arg2:
                mem[32] = 7
                if idx > !arg1:
                    revert with 0, 17
                if idx + arg1 >= sub_20df060c[msg.sender]:
                    revert with 0, 50
                if stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _207 = mem[64]
                mem[64] = mem[64] + 288
                mem[_207] = bool(uint8(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_0))
                mem[_207 + 32] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_256
                _208 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) + 32
                mem[_208] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512
                if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512:
                    mem[_207 + 64] = _208
                    _216 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_216] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_207 + 96] = _216
                        mem[_207 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_207 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_207 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_207 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _253 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_253] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_253 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_253 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _253 + 32
                                        t = sha3(mem[0])
                                        while _253 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_253 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_253 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _253 + 32
                                        t = sha3(mem[0])
                                        while _253 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_207 + 256] = _253
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _265 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_265] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_265 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_265 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _265 + 32
                                        t = sha3(mem[0])
                                        while _265 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_265 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_265 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _265 + 32
                                        t = sha3(mem[0])
                                        while _265 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_207 + 256] = _265
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_216 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _216 + 32
                        t = sha3(mem[0])
                        while _216 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_207 + 96] = _216
                        mem[_207 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_207 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_207 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_207 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _518 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_518] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_518 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_518 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _518 + 32
                                        t = sha3(mem[0])
                                        while _518 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_207 + 256] = _518
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_207 + 256] = _518
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_518 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_207 + 256] = _518
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_518 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _518 + 32
                            t = sha3(mem[0])
                            while _518 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_207 + 256] = _518
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _207
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _521 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_521] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_207 + 256] = _521
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_521 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_207 + 256] = _521
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_521 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _521 + 32
                            t = sha3(mem[0])
                            while _521 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_207 + 256] = _521
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _207
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_521 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_521 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _521 + 32
                                t = sha3(mem[0])
                                while _521 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_207 + 256] = _521
                else:
                    mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 2
                    mem[_208 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 2)].field_0
                    s = _208 + 32
                    t = sha3(mem[0])
                    while _208 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_207 + 64] = _208
                    _502 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_502] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_207 + 96] = _502
                        mem[_207 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_207 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_207 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_207 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _522 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_522] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_522 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_522 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _522 + 32
                                        t = sha3(mem[0])
                                        while _522 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_207 + 256] = _522
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_207 + 256] = _522
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_522 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_207 + 256] = _522
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_522 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _522 + 32
                            t = sha3(mem[0])
                            while _522 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_207 + 256] = _522
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _207
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _541 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_541] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_207 + 256] = _541
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_541 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_207 + 256] = _541
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _207
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_541 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _541 + 32
                            t = sha3(mem[0])
                            while _541 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_207 + 256] = _541
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _207
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_541 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_541 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _541 + 32
                                t = sha3(mem[0])
                                while _541 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_207 + 256] = _541
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_502 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _502 + 32
                        t = sha3(mem[0])
                        while _502 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_207 + 96] = _502
                        mem[_207 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_207 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_207 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_207 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _776 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_776] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_776 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_776 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _776 + 32
                                        t = sha3(mem[0])
                                        while _776 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_776 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_776 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _776 + 32
                                        t = sha3(mem[0])
                                        while _776 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_207 + 256] = _776
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _780 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_780] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_780 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_780 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _780 + 32
                                        t = sha3(mem[0])
                                        while _780 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_780 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_780 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _780 + 32
                                        t = sha3(mem[0])
                                        while _780 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_207 + 256] = _780
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _207
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _190 = mem[64]
            mem[mem[64]] = 32
            _192 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _192:
                mem[u] = t + -_190 - 64
                _370 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_370 + 32]
                _373 = mem[_370 + 64]
                mem[t + 64] = 288
                _379 = mem[_373]
                mem[t + 288] = mem[_373]
                v = 0
                w = _373 + 32
                x = t + 320
                while v < _379:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _510 = mem[_370 + 96]
                mem[t + 96] = (32 * _379) + 320
                _514 = mem[_510]
                mem[t + (32 * _379) + 320] = mem[_510]
                v = 0
                w = _510 + 32
                x = t + (32 * _379) + 352
                while v < _514:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_370 + 128]
                mem[t + 160] = mem[_370 + 160]
                mem[t + 192] = mem[_370 + 192]
                mem[t + 224] = mem[_370 + 236 len 20]
                _704 = mem[_370 + 256]
                mem[t + 256] = (32 * _379) + (32 * _514) + 352
                _738 = mem[_704]
                mem[t + (32 * _379) + (32 * _514) + 352] = mem[_704]
                v = 0
                while v < _738:
                    mem[v + t + (32 * _379) + (32 * _514) + 384] = mem[_704 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_738) > _738:
                    mem[t + (32 * _379) + (32 * _514) + _738 + 384] = 0
                v = ceil32(_738) + 1
                s = s + 32
                t = ceil32(_738) + t + (32 * _379) + (32 * _514) + 384
                u = u + 32
                continue 
        else:
            mem[64] = (32 * arg2) + 416
            mem[(32 * arg2) + 128] = 0
            mem[(32 * arg2) + 160] = 0
            mem[(32 * arg2) + 192] = 96
            mem[(32 * arg2) + 224] = 96
            mem[(32 * arg2) + 256] = 0
            mem[(32 * arg2) + 288] = 0
            mem[(32 * arg2) + 320] = 0
            mem[(32 * arg2) + 352] = 0
            mem[(32 * arg2) + 384] = 96
            mem[var16001] = (32 * arg2) + 128
            s = var16001
            idx = var16002
            while idx - 1:
                mem[64] = mem[64] + 288
                mem[(32 * arg2) + 128] = 0
                mem[(32 * arg2) + 160] = 0
                mem[(32 * arg2) + 192] = 96
                mem[(32 * arg2) + 224] = 96
                mem[(32 * arg2) + 256] = 0
                mem[(32 * arg2) + 288] = 0
                mem[(32 * arg2) + 320] = 0
                mem[(32 * arg2) + 352] = 0
                mem[(32 * arg2) + 384] = 96
                mem[s + 32] = (32 * arg2) + 128
                s = s + 32
                idx = idx - 1
                continue 
            idx = 0
            while idx < arg2:
                mem[32] = 7
                if idx > !arg1:
                    revert with 0, 17
                if idx + arg1 >= sub_20df060c[msg.sender]:
                    revert with 0, 50
                if stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _545 = mem[64]
                mem[64] = mem[64] + 288
                mem[_545] = bool(uint8(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_0))
                mem[_545 + 32] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_256
                _546 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) + 32
                mem[_546] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512
                if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512:
                    mem[_545 + 64] = _546
                    _559 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_559] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_545 + 96] = _559
                        mem[_545 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_545 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_545 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_545 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _606 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_606] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_606 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_606 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _606 + 32
                                        t = sha3(mem[0])
                                        while _606 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_606 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_606 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _606 + 32
                                        t = sha3(mem[0])
                                        while _606 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_545 + 256] = _606
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _626 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_626] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_626 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_626 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _626 + 32
                                        t = sha3(mem[0])
                                        while _626 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_626 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_626 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _626 + 32
                                        t = sha3(mem[0])
                                        while _626 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_545 + 256] = _626
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_559 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _559 + 32
                        t = sha3(mem[0])
                        while _559 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_545 + 96] = _559
                        mem[_545 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_545 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_545 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_545 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _777 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_777] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_777 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_777 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _777 + 32
                                        t = sha3(mem[0])
                                        while _777 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_545 + 256] = _777
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_545 + 256] = _777
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_777 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_545 + 256] = _777
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_777 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _777 + 32
                            t = sha3(mem[0])
                            while _777 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_545 + 256] = _777
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _545
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _782 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_782] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_545 + 256] = _782
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_782 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_545 + 256] = _782
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_782 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _782 + 32
                            t = sha3(mem[0])
                            while _782 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_545 + 256] = _782
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _545
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_782 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_782 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _782 + 32
                                t = sha3(mem[0])
                                while _782 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_545 + 256] = _782
                else:
                    mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 2
                    mem[_546 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 2)].field_0
                    s = _546 + 32
                    t = sha3(mem[0])
                    while _546 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_545 + 64] = _546
                    _764 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_764] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_545 + 96] = _764
                        mem[_545 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_545 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_545 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_545 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _783 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_783] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_783 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_783 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _783 + 32
                                        t = sha3(mem[0])
                                        while _783 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_545 + 256] = _783
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_545 + 256] = _783
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_783 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_545 + 256] = _783
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_783 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _783 + 32
                            t = sha3(mem[0])
                            while _783 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_545 + 256] = _783
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _545
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _793 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_793] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_545 + 256] = _793
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_793 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_545 + 256] = _793
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _545
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_793 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _793 + 32
                            t = sha3(mem[0])
                            while _793 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_545 + 256] = _793
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _545
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_793 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_793 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _793 + 32
                                t = sha3(mem[0])
                                while _793 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_545 + 256] = _793
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_764 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _764 + 32
                        t = sha3(mem[0])
                        while _764 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_545 + 96] = _764
                        mem[_545 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_545 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_545 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_545 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _942 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_942] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_942 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_942 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _942 + 32
                                        t = sha3(mem[0])
                                        while _942 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_942 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_942 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _942 + 32
                                        t = sha3(mem[0])
                                        while _942 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_545 + 256] = _942
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _944 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_944] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_944 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_944 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _944 + 32
                                        t = sha3(mem[0])
                                        while _944 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_944 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_944 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _944 + 32
                                        t = sha3(mem[0])
                                        while _944 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_545 + 256] = _944
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _545
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _511 = mem[64]
            mem[mem[64]] = 32
            _515 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _515:
                mem[u] = t + -_511 - 64
                _691 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_691 + 32]
                _694 = mem[_691 + 64]
                mem[t + 64] = 288
                _714 = mem[_694]
                mem[t + 288] = mem[_694]
                v = 0
                w = _694 + 32
                x = t + 320
                while v < _714:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _772 = mem[_691 + 96]
                mem[t + 96] = (32 * _714) + 320
                _774 = mem[_772]
                mem[t + (32 * _714) + 320] = mem[_772]
                v = 0
                w = _772 + 32
                x = t + (32 * _714) + 352
                while v < _774:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_691 + 128]
                mem[t + 160] = mem[_691 + 160]
                mem[t + 192] = mem[_691 + 192]
                mem[t + 224] = mem[_691 + 236 len 20]
                _910 = mem[_691 + 256]
                mem[t + 256] = (32 * _714) + (32 * _774) + 352
                _936 = mem[_910]
                mem[t + (32 * _714) + (32 * _774) + 352] = mem[_910]
                v = 0
                while v < _936:
                    mem[v + t + (32 * _714) + (32 * _774) + 384] = mem[_910 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_936) > _936:
                    mem[t + (32 * _714) + (32 * _774) + _936 + 384] = 0
                v = ceil32(_936) + 1
                s = s + 32
                t = ceil32(_936) + t + (32 * _714) + (32 * _774) + 384
                u = u + 32
                continue 
    else:
        if sub_20df060c[msg.sender] < arg1:
            revert with 0, 17
        if sub_20df060c[msg.sender] - arg1 > test266151307():
            revert with 0, 65
        mem[96] = sub_20df060c[msg.sender] - arg1
        mem[64] = (32 * sub_20df060c[msg.sender] - arg1) + 128
        if not sub_20df060c[msg.sender] - arg1:
            idx = 0
            while idx < sub_20df060c[msg.sender] - arg1:
                mem[32] = 7
                if idx > !arg1:
                    revert with 0, 17
                if idx + arg1 >= sub_20df060c[msg.sender]:
                    revert with 0, 50
                if stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _213 = mem[64]
                mem[64] = mem[64] + 288
                mem[_213] = bool(uint8(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_0))
                mem[_213 + 32] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_256
                _214 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) + 32
                mem[_214] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512
                if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512:
                    mem[_213 + 64] = _214
                    _219 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_219] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_213 + 96] = _219
                        mem[_213 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_213 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_213 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_213 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _257 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_257] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_257 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_257 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _257 + 32
                                        t = sha3(mem[0])
                                        while _257 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_257 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_257 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _257 + 32
                                        t = sha3(mem[0])
                                        while _257 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_213 + 256] = _257
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _273 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_273] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_273 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_273 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _273 + 32
                                        t = sha3(mem[0])
                                        while _273 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_273 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_273 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _273 + 32
                                        t = sha3(mem[0])
                                        while _273 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_213 + 256] = _273
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_219 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _219 + 32
                        t = sha3(mem[0])
                        while _219 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_213 + 96] = _219
                        mem[_213 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_213 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_213 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_213 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _519 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_519] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_519 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_519 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _519 + 32
                                        t = sha3(mem[0])
                                        while _519 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_213 + 256] = _519
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_213 + 256] = _519
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_519 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_213 + 256] = _519
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_519 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _519 + 32
                            t = sha3(mem[0])
                            while _519 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_213 + 256] = _519
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _213
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _529 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_529] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_213 + 256] = _529
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_529 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_213 + 256] = _529
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_529 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _529 + 32
                            t = sha3(mem[0])
                            while _529 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_213 + 256] = _529
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _213
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_529 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_529 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _529 + 32
                                t = sha3(mem[0])
                                while _529 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_213 + 256] = _529
                else:
                    mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 2
                    mem[_214 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 2)].field_0
                    s = _214 + 32
                    t = sha3(mem[0])
                    while _214 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_213 + 64] = _214
                    _503 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_503] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_213 + 96] = _503
                        mem[_213 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_213 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_213 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_213 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _530 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_530] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_530 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_530 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _530 + 32
                                        t = sha3(mem[0])
                                        while _530 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_213 + 256] = _530
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_213 + 256] = _530
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_530 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_213 + 256] = _530
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_530 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _530 + 32
                            t = sha3(mem[0])
                            while _530 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_213 + 256] = _530
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _213
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _552 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_552] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_213 + 256] = _552
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_552 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_213 + 256] = _552
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _213
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_552 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _552 + 32
                            t = sha3(mem[0])
                            while _552 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_213 + 256] = _552
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _213
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_552 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_552 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _552 + 32
                                t = sha3(mem[0])
                                while _552 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_213 + 256] = _552
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_503 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _503 + 32
                        t = sha3(mem[0])
                        while _503 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_213 + 96] = _503
                        mem[_213 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_213 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_213 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_213 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _778 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_778] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_778 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_778 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _778 + 32
                                        t = sha3(mem[0])
                                        while _778 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_778 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_778 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _778 + 32
                                        t = sha3(mem[0])
                                        while _778 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_213 + 256] = _778
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _784 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_784] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_784 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_784 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _784 + 32
                                        t = sha3(mem[0])
                                        while _784 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_784 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_784 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _784 + 32
                                        t = sha3(mem[0])
                                        while _784 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_213 + 256] = _784
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _213
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _191 = mem[64]
            mem[mem[64]] = 32
            _193 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _193:
                mem[u] = t + -_191 - 64
                _374 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_374 + 32]
                _377 = mem[_374 + 64]
                mem[t + 64] = 288
                _385 = mem[_377]
                mem[t + 288] = mem[_377]
                v = 0
                w = _377 + 32
                x = t + 320
                while v < _385:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _512 = mem[_374 + 96]
                mem[t + 96] = (32 * _385) + 320
                _516 = mem[_512]
                mem[t + (32 * _385) + 320] = mem[_512]
                v = 0
                w = _512 + 32
                x = t + (32 * _385) + 352
                while v < _516:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_374 + 128]
                mem[t + 160] = mem[_374 + 160]
                mem[t + 192] = mem[_374 + 192]
                mem[t + 224] = mem[_374 + 236 len 20]
                _723 = mem[_374 + 256]
                mem[t + 256] = (32 * _385) + (32 * _516) + 352
                _739 = mem[_723]
                mem[t + (32 * _385) + (32 * _516) + 352] = mem[_723]
                v = 0
                while v < _739:
                    mem[v + t + (32 * _385) + (32 * _516) + 384] = mem[_723 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_739) > _739:
                    mem[t + (32 * _385) + (32 * _516) + _739 + 384] = 0
                v = ceil32(_739) + 1
                s = s + 32
                t = ceil32(_739) + t + (32 * _385) + (32 * _516) + 384
                u = u + 32
                continue 
        else:
            mem[64] = (32 * sub_20df060c[msg.sender] - arg1) + 416
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 128] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 160] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 192] = 96
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 224] = 96
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 256] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 288] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 320] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 352] = 0
            mem[(32 * sub_20df060c[msg.sender] - arg1) + 384] = 96
            mem[var20001] = (32 * sub_20df060c[msg.sender] - arg1) + 128
            s = var20001
            idx = var20002
            while idx - 1:
                mem[64] = mem[64] + 288
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 128] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 160] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 192] = 96
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 224] = 96
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 256] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 288] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 320] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 352] = 0
                mem[(32 * sub_20df060c[msg.sender] - arg1) + 384] = 96
                mem[s + 32] = (32 * sub_20df060c[msg.sender] - arg1) + 128
                s = s + 32
                idx = idx - 1
                continue 
            idx = 0
            while idx < sub_20df060c[msg.sender] - arg1:
                mem[32] = 7
                if idx > !arg1:
                    revert with 0, 17
                if idx + arg1 >= sub_20df060c[msg.sender]:
                    revert with 0, 50
                if stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1] >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _556 = mem[64]
                mem[64] = mem[64] + 288
                mem[_556] = bool(uint8(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_0))
                mem[_556 + 32] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_256
                _557 = mem[64]
                mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) + 32
                mem[_557] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512
                if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512:
                    mem[_556 + 64] = _557
                    _562 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_562] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_556 + 96] = _562
                        mem[_556 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_556 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_556 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_556 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _615 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_615] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_615 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_615 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _615 + 32
                                        t = sha3(mem[0])
                                        while _615 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_615 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_615 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _615 + 32
                                        t = sha3(mem[0])
                                        while _615 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_556 + 256] = _615
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _637 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_637] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_637 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_637 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _637 + 32
                                        t = sha3(mem[0])
                                        while _637 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_637 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_637 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _637 + 32
                                        t = sha3(mem[0])
                                        while _637 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_556 + 256] = _637
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_562 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _562 + 32
                        t = sha3(mem[0])
                        while _562 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_556 + 96] = _562
                        mem[_556 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_556 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_556 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_556 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _779 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_779] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_779 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_779 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _779 + 32
                                        t = sha3(mem[0])
                                        while _779 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_556 + 256] = _779
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_556 + 256] = _779
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_779 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_556 + 256] = _779
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_779 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _779 + 32
                            t = sha3(mem[0])
                            while _779 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_556 + 256] = _779
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _556
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _786 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_786] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_556 + 256] = _786
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_786 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_556 + 256] = _786
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_786 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _786 + 32
                            t = sha3(mem[0])
                            while _786 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_556 + 256] = _786
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _556
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_786 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_786 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _786 + 32
                                t = sha3(mem[0])
                                while _786 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_556 + 256] = _786
                else:
                    mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 2
                    mem[_557 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 2)].field_0
                    s = _557 + 32
                    t = sha3(mem[0])
                    while _557 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_512) > s:
                        mem[s + 32] = uint256(stor1[t])
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_556 + 64] = _557
                    _765 = mem[64]
                    mem[64] = mem[64] + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) + 32
                    mem[_765] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768
                    if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768:
                        mem[_556 + 96] = _765
                        mem[_556 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_556 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_556 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_556 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _787 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_787] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_787 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_787 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _787 + 32
                                        t = sha3(mem[0])
                                        while _787 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                                mem[_556 + 256] = _787
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            if not stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_556 + 256] = _787
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_787 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_556 + 256] = _787
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_787 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _787 + 32
                            t = sha3(mem[0])
                            while _787 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_556 + 256] = _787
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _556
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        _799 = mem[64]
                        mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                        mem[_799] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                mem[_556 + 256] = _799
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                mem[_799 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                mem[_556 + 256] = _799
                                if idx >= mem[96]:
                                    revert with 0, 50
                                mem[(32 * idx) + 128] = _556
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                            mem[_799 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                            s = _799 + 32
                            t = sha3(mem[0])
                            while _799 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + s + arg1]].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_556 + 256] = _799
                            if s >= mem[96]:
                                revert with 0, 50
                            mem[(32 * s) + 128] = _556
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                            revert with 0, 34
                        if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                            if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                mem[_799 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                            else:
                                mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                mem[_799 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                s = _799 + 32
                                t = sha3(mem[0])
                                while _799 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                        mem[_556 + 256] = _799
                    else:
                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 3
                        mem[_765 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 3)].field_0
                        s = _765 + 32
                        t = sha3(mem[0])
                        while _765 + (32 * stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_768) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_556 + 96] = _765
                        mem[_556 + 128] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1024
                        mem[_556 + 160] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1280
                        mem[_556 + 192] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1536
                        mem[_556 + 224] = address(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_1792)
                        if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                revert with 0, 34
                            _943 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) + 32
                            mem[_943] = uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_943 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_943 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _943 + 32
                                        t = sha3(mem[0])
                                        while _943 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_943 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_943 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _943 + 32
                                        t = sha3(mem[0])
                                        while _943 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_556 + 256] = _943
                        else:
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                revert with 0, 34
                            _945 = mem[64]
                            mem[64] = mem[64] + ceil32(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128) + 32
                            mem[_945] = stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128
                            if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048):
                                    if 31 >= uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5:
                                        mem[_945 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_945 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _945 + 32
                                        t = sha3(mem[0])
                                        while _945 + (uint255(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) * 0.5) > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if bool(stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2048) == stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 < 32:
                                    revert with 0, 34
                                if stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                    if 31 >= stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128:
                                        mem[_945 + 32] = 256 * Mask(248, 0, stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2056)
                                    else:
                                        mem[0] = sha3(5) + (9 * stor[('map', 'msg.sender', ('name', 'sub_20df060c', 7)) + idx + arg1]) + 8
                                        mem[_945 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]) + 8)].field_0
                                        s = _945 + 32
                                        t = sha3(mem[0])
                                        while _945 + stor5[stor[('map', 'msg.sender', ('name', 'stor7', 7)) + idx + arg1]].field_2049 % 128 > s:
                                            mem[s + 32] = uint256(stor1[t])
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_556 + 256] = _945
                if idx >= mem[96]:
                    revert with 0, 50
                mem[(32 * idx) + 128] = _556
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _513 = mem[64]
            mem[mem[64]] = 32
            _517 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _517:
                mem[u] = t + -_513 - 64
                _696 = mem[s]
                mem[t] = bool(mem[mem[s]])
                mem[t + 32] = mem[_696 + 32]
                _699 = mem[_696 + 64]
                mem[t + 64] = 288
                _733 = mem[_699]
                mem[t + 288] = mem[_699]
                v = 0
                w = _699 + 32
                x = t + 320
                while v < _733:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _773 = mem[_696 + 96]
                mem[t + 96] = (32 * _733) + 320
                _775 = mem[_773]
                mem[t + (32 * _733) + 320] = mem[_773]
                v = 0
                w = _773 + 32
                x = t + (32 * _733) + 352
                while v < _775:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                mem[t + 128] = mem[_696 + 128]
                mem[t + 160] = mem[_696 + 160]
                mem[t + 192] = mem[_696 + 192]
                mem[t + 224] = mem[_696 + 236 len 20]
                _927 = mem[_696 + 256]
                mem[t + 256] = (32 * _733) + (32 * _775) + 352
                _937 = mem[_927]
                mem[t + (32 * _733) + (32 * _775) + 352] = mem[_927]
                v = 0
                while v < _937:
                    mem[v + t + (32 * _733) + (32 * _775) + 384] = mem[_927 + v + 32]
                    v = v + 32
                    continue 
                if ceil32(_937) > _937:
                    mem[t + (32 * _733) + (32 * _775) + _937 + 384] = 0
                v = ceil32(_937) + 1
                s = s + 32
                t = ceil32(_937) + t + (32 * _733) + (32 * _775) + 384
                u = u + 32
                continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function sub_a342f71c(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    if not sub_aca20f07:
        revert with 0, 'Only in emergency.'
    if isMarketOpen:
        revert with 0, 'Only in emergency.'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _405 = mem[(32 * idx) + 128]
        if mem[(32 * idx) + 128] >= stor5.length:
            revert with 0, 'Invalid Collection'
        mem[0] = 5
        _408 = mem[64]
        mem[64] = mem[64] + 288
        mem[_408] = bool(uint8(stor5[mem[(32 * idx) + 128]].field_0))
        mem[_408 + 32] = stor5[_405].field_256
        _409 = mem[64]
        mem[64] = mem[64] + (32 * stor5[_405].field_512) + 32
        mem[_409] = stor5[_405].field_512
        if not stor5[_405].field_512:
            mem[_408 + 64] = _409
            _410 = mem[64]
            mem[64] = mem[64] + (32 * stor5[_405].field_768) + 32
            mem[_410] = stor5[_405].field_768
            if not stor5[_405].field_768:
                mem[_408 + 96] = _410
                mem[_408 + 128] = stor5[_405].field_1024
                mem[_408 + 160] = stor5[_405].field_1280
                mem[_408 + 192] = stor5[_405].field_1536
                mem[_408 + 224] = address(stor5[_405].field_1792)
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    _414 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor5[_405].field_2048) * 0.5) + 32
                    mem[_414] = uint255(stor5[_405].field_2048) * 0.5
                    if bool(stor5[_405].field_2048):
                        if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor5[_405].field_2048):
                            mem[_408 + 256] = _414
                            _418 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_418] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_418]:
                                        revert with 0, 50
                                    _636 = mem[(32 * mem[(32 * s) + _410 + 32]) + _418 + 32]
                                    _637 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _672 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_637)
                                    mem[mem[64] + 68] = _672
                                    require ext_code.size(address(_636))
                                    call address(_636).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_637), _672
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_418 + 32] = address(supportedTokens.field_0)
                                s = _418 + 32
                                t = sha3(3)
                                while _418 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _733 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _733:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_418]:
                                        revert with 0, 50
                                    _1338 = mem[(32 * mem[(32 * s) + _410 + 32]) + _418 + 32]
                                    _1339 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1442 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1339)
                                    mem[mem[64] + 68] = _1442
                                    require ext_code.size(address(_1338))
                                    call address(_1338).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1339), _1442
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                                mem[_414 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _414
                                _431 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_431] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_410]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _410 + 32] >= mem[_431]:
                                            revert with 0, 50
                                        _642 = mem[(32 * mem[(32 * s) + _410 + 32]) + _431 + 32]
                                        _643 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _674 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_643)
                                        mem[mem[64] + 68] = _674
                                        require ext_code.size(address(_642))
                                        call address(_642).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_643), _674
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_431 + 32] = address(supportedTokens.field_0)
                                    s = _431 + 32
                                    t = sha3(3)
                                    while _431 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _735 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _735:
                                        if s >= mem[_410]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _410 + 32] >= mem[_431]:
                                            revert with 0, 50
                                        _1343 = mem[(32 * mem[(32 * s) + _410 + 32]) + _431 + 32]
                                        _1344 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1447 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1344)
                                        mem[mem[64] + 68] = _1447
                                        require ext_code.size(address(_1343))
                                        call address(_1343).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1344), _1447
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_414 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _414 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _414 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _414
                                _610 = mem[_408 + 64]
                                _611 = mem[_408 + 96]
                                _612 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_612] = supportedTokens.length
                                if not supportedTokens.length:
                                    _640 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _640:
                                        if s >= mem[_611]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _611 + 32] >= mem[_612]:
                                            revert with 0, 50
                                        _772 = mem[(32 * mem[(32 * s) + _611 + 32]) + _612 + 32]
                                        _773 = mem[_408 + 224]
                                        if s >= mem[_610]:
                                            revert with 0, 50
                                        _801 = mem[(32 * s) + _610 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_773)
                                        mem[mem[64] + 68] = _801
                                        require ext_code.size(address(_772))
                                        call address(_772).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_773), _801
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_612 + 32] = address(supportedTokens.field_0)
                                    s = _612 + 32
                                    t = sha3(3)
                                    while _612 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _1231 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1231:
                                        if s >= mem[_611]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _611 + 32] >= mem[_612]:
                                            revert with 0, 50
                                        _1694 = mem[(32 * mem[(32 * s) + _611 + 32]) + _612 + 32]
                                        _1695 = mem[_408 + 224]
                                        if s >= mem[_610]:
                                            revert with 0, 50
                                        _1762 = mem[(32 * s) + _610 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1695)
                                        mem[mem[64] + 68] = _1762
                                        require ext_code.size(address(_1694))
                                        call address(_1694).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1695), _1762
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                            revert with 0, 34
                        if not stor5[_405].field_2049 % 128:
                            mem[_408 + 256] = _414
                            _425 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_425] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_425]:
                                        revert with 0, 50
                                    _645 = mem[(32 * mem[(32 * s) + _410 + 32]) + _425 + 32]
                                    _646 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _676 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_646)
                                    mem[mem[64] + 68] = _676
                                    require ext_code.size(address(_645))
                                    call address(_645).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_646), _676
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_425 + 32] = address(supportedTokens.field_0)
                                s = _425 + 32
                                t = sha3(3)
                                while _425 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _737 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _737:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_425]:
                                        revert with 0, 50
                                    _1346 = mem[(32 * mem[(32 * s) + _410 + 32]) + _425 + 32]
                                    _1347 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1449 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1347)
                                    mem[mem[64] + 68] = _1449
                                    require ext_code.size(address(_1346))
                                    call address(_1346).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1347), _1449
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= stor5[_405].field_2049 % 128:
                                mem[_414 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _414
                                _449 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_449] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_410]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _410 + 32] >= mem[_449]:
                                            revert with 0, 50
                                        _651 = mem[(32 * mem[(32 * s) + _410 + 32]) + _449 + 32]
                                        _652 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _678 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_652)
                                        mem[mem[64] + 68] = _678
                                        require ext_code.size(address(_651))
                                        call address(_651).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_652), _678
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_449 + 32] = address(supportedTokens.field_0)
                                    s = _449 + 32
                                    t = sha3(3)
                                    while _449 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _739 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _739:
                                        if s >= mem[_410]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _410 + 32] >= mem[_449]:
                                            revert with 0, 50
                                        _1351 = mem[(32 * mem[(32 * s) + _410 + 32]) + _449 + 32]
                                        _1352 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1454 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1352)
                                        mem[mem[64] + 68] = _1454
                                        require ext_code.size(address(_1351))
                                        call address(_1351).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1352), _1454
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_414 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _414 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _414 + stor5[_405].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _414
                                _617 = mem[_408 + 64]
                                _618 = mem[_408 + 96]
                                _619 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_619] = supportedTokens.length
                                if not supportedTokens.length:
                                    _649 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _649:
                                        if s >= mem[_618]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _618 + 32] >= mem[_619]:
                                            revert with 0, 50
                                        _779 = mem[(32 * mem[(32 * s) + _618 + 32]) + _619 + 32]
                                        _780 = mem[_408 + 224]
                                        if s >= mem[_617]:
                                            revert with 0, 50
                                        _809 = mem[(32 * s) + _617 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_780)
                                        mem[mem[64] + 68] = _809
                                        require ext_code.size(address(_779))
                                        call address(_779).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_780), _809
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_619 + 32] = address(supportedTokens.field_0)
                                    s = _619 + 32
                                    t = sha3(3)
                                    while _619 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _1233 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1233:
                                        if s >= mem[_618]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _618 + 32] >= mem[_619]:
                                            revert with 0, 50
                                        _1697 = mem[(32 * mem[(32 * s) + _618 + 32]) + _619 + 32]
                                        _1698 = mem[_408 + 224]
                                        if s >= mem[_617]:
                                            revert with 0, 50
                                        _1764 = mem[(32 * s) + _617 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1698)
                                        mem[mem[64] + 68] = _1764
                                        require ext_code.size(address(_1697))
                                        call address(_1697).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1698), _1764
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                    revert with 0, 34
                _415 = mem[64]
                mem[64] = mem[64] + ceil32(stor5[_405].field_2049 % 128) + 32
                mem[_415] = stor5[_405].field_2049 % 128
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[_405].field_2048):
                        mem[_408 + 256] = _415
                        _428 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_428] = supportedTokens.length
                        if not supportedTokens.length:
                            s = 0
                            while s < stor5[_405].field_512:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_428]:
                                    revert with 0, 50
                                _654 = mem[(32 * mem[(32 * s) + _410 + 32]) + _428 + 32]
                                _655 = mem[_408 + 224]
                                if s >= mem[_409]:
                                    revert with 0, 50
                                _680 = mem[(32 * s) + _409 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_655)
                                mem[mem[64] + 68] = _680
                                require ext_code.size(address(_654))
                                call address(_654).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_655), _680
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_428 + 32] = address(supportedTokens.field_0)
                            s = _428 + 32
                            t = sha3(3)
                            while _428 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _741 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _741:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_428]:
                                    revert with 0, 50
                                _1354 = mem[(32 * mem[(32 * s) + _410 + 32]) + _428 + 32]
                                _1355 = mem[_408 + 224]
                                if s >= mem[_409]:
                                    revert with 0, 50
                                _1456 = mem[(32 * s) + _409 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1355)
                                mem[mem[64] + 68] = _1456
                                require ext_code.size(address(_1354))
                                call address(_1354).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1355), _1456
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                            mem[_415 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                            mem[_408 + 256] = _415
                            _452 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_452] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_452]:
                                        revert with 0, 50
                                    _660 = mem[(32 * mem[(32 * s) + _410 + 32]) + _452 + 32]
                                    _661 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _682 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_661)
                                    mem[mem[64] + 68] = _682
                                    require ext_code.size(address(_660))
                                    call address(_660).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_661), _682
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_452 + 32] = address(supportedTokens.field_0)
                                s = _452 + 32
                                t = sha3(3)
                                while _452 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _743 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _743:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_452]:
                                        revert with 0, 50
                                    _1359 = mem[(32 * mem[(32 * s) + _410 + 32]) + _452 + 32]
                                    _1360 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1461 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1360)
                                    mem[mem[64] + 68] = _1461
                                    require ext_code.size(address(_1359))
                                    call address(_1359).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1360), _1461
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            mem[0] = sha3(5) + (9 * _405) + 8
                            mem[_415 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                            s = _415 + 32
                            t = sha3(sha3(5) + (9 * _405) + 8)
                            while _415 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_408 + 256] = _415
                            _624 = mem[_408 + 64]
                            _625 = mem[_408 + 96]
                            _626 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_626] = supportedTokens.length
                            if not supportedTokens.length:
                                _658 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _658:
                                    if s >= mem[_625]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _625 + 32] >= mem[_626]:
                                        revert with 0, 50
                                    _786 = mem[(32 * mem[(32 * s) + _625 + 32]) + _626 + 32]
                                    _787 = mem[_408 + 224]
                                    if s >= mem[_624]:
                                        revert with 0, 50
                                    _817 = mem[(32 * s) + _624 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_787)
                                    mem[mem[64] + 68] = _817
                                    require ext_code.size(address(_786))
                                    call address(_786).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_787), _817
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_626 + 32] = address(supportedTokens.field_0)
                                s = _626 + 32
                                t = sha3(3)
                                while _626 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1235 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1235:
                                    if s >= mem[_625]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _625 + 32] >= mem[_626]:
                                        revert with 0, 50
                                    _1700 = mem[(32 * mem[(32 * s) + _625 + 32]) + _626 + 32]
                                    _1701 = mem[_408 + 224]
                                    if s >= mem[_624]:
                                        revert with 0, 50
                                    _1766 = mem[(32 * s) + _624 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1701)
                                    mem[mem[64] + 68] = _1766
                                    require ext_code.size(address(_1700))
                                    call address(_1700).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1701), _1766
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                    revert with 0, 34
                if not stor5[_405].field_2049 % 128:
                    mem[_408 + 256] = _415
                    _442 = mem[64]
                    mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                    mem[_442] = supportedTokens.length
                    if not supportedTokens.length:
                        s = 0
                        while s < stor5[_405].field_512:
                            if s >= mem[_410]:
                                revert with 0, 50
                            if mem[(32 * s) + _410 + 32] >= mem[_442]:
                                revert with 0, 50
                            _663 = mem[(32 * mem[(32 * s) + _410 + 32]) + _442 + 32]
                            _664 = mem[_408 + 224]
                            if s >= mem[_409]:
                                revert with 0, 50
                            _684 = mem[(32 * s) + _409 + 32]
                            mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = address(_664)
                            mem[mem[64] + 68] = _684
                            require ext_code.size(address(_663))
                            call address(_663).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args address(this.address), address(_664), _684
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                    else:
                        mem[0] = 3
                        mem[_442 + 32] = address(supportedTokens.field_0)
                        s = _442 + 32
                        t = sha3(3)
                        while _442 + (32 * supportedTokens.length) > s:
                            mem[s + 32] = address(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        _745 = mem[mem[_408 + 64]]
                        s = 0
                        while s < _745:
                            if s >= mem[_410]:
                                revert with 0, 50
                            if mem[(32 * s) + _410 + 32] >= mem[_442]:
                                revert with 0, 50
                            _1362 = mem[(32 * mem[(32 * s) + _410 + 32]) + _442 + 32]
                            _1363 = mem[_408 + 224]
                            if s >= mem[_409]:
                                revert with 0, 50
                            _1463 = mem[(32 * s) + _409 + 32]
                            mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = address(_1363)
                            mem[mem[64] + 68] = _1463
                            require ext_code.size(address(_1362))
                            call address(_1362).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args address(this.address), address(_1363), _1463
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if 31 >= stor5[_405].field_2049 % 128:
                    mem[_415 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                    mem[_408 + 256] = _415
                    _472 = mem[64]
                    mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                    mem[_472] = supportedTokens.length
                    if not supportedTokens.length:
                        s = 0
                        while s < stor5[_405].field_512:
                            if s >= mem[_410]:
                                revert with 0, 50
                            if mem[(32 * s) + _410 + 32] >= mem[_472]:
                                revert with 0, 50
                            _669 = mem[(32 * mem[(32 * s) + _410 + 32]) + _472 + 32]
                            _670 = mem[_408 + 224]
                            if s >= mem[_409]:
                                revert with 0, 50
                            _686 = mem[(32 * s) + _409 + 32]
                            mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = address(_670)
                            mem[mem[64] + 68] = _686
                            require ext_code.size(address(_669))
                            call address(_669).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args address(this.address), address(_670), _686
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                    else:
                        mem[0] = 3
                        mem[_472 + 32] = address(supportedTokens.field_0)
                        s = _472 + 32
                        t = sha3(3)
                        while _472 + (32 * supportedTokens.length) > s:
                            mem[s + 32] = address(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        _747 = mem[mem[_408 + 64]]
                        s = 0
                        while s < _747:
                            if s >= mem[_410]:
                                revert with 0, 50
                            if mem[(32 * s) + _410 + 32] >= mem[_472]:
                                revert with 0, 50
                            _1367 = mem[(32 * mem[(32 * s) + _410 + 32]) + _472 + 32]
                            _1368 = mem[_408 + 224]
                            if s >= mem[_409]:
                                revert with 0, 50
                            _1468 = mem[(32 * s) + _409 + 32]
                            mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = address(_1368)
                            mem[mem[64] + 68] = _1468
                            require ext_code.size(address(_1367))
                            call address(_1367).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                 gas gas_remaining wei
                                args address(this.address), address(_1368), _1468
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[0] = sha3(5) + (9 * _405) + 8
                mem[_415 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                s = _415 + 32
                t = sha3(sha3(5) + (9 * _405) + 8)
                while _415 + stor5[_405].field_2049 % 128 > s:
                    mem[s + 32] = uint256(stor1[t])
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_408 + 256] = _415
                _631 = mem[_408 + 64]
                _632 = mem[_408 + 96]
                _633 = mem[64]
                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                mem[_633] = supportedTokens.length
                if not supportedTokens.length:
                    _667 = mem[mem[_408 + 64]]
                    s = 0
                    while s < _667:
                        if s >= mem[_632]:
                            revert with 0, 50
                        if mem[(32 * s) + _632 + 32] >= mem[_633]:
                            revert with 0, 50
                        _793 = mem[(32 * mem[(32 * s) + _632 + 32]) + _633 + 32]
                        _794 = mem[_408 + 224]
                        if s >= mem[_631]:
                            revert with 0, 50
                        _825 = mem[(32 * s) + _631 + 32]
                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = address(_794)
                        mem[mem[64] + 68] = _825
                        require ext_code.size(address(_793))
                        call address(_793).transferFrom(address arg1, address arg2, uint256 arg3) with:
                             gas gas_remaining wei
                            args address(this.address), address(_794), _825
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[0] = 3
                mem[_633 + 32] = address(supportedTokens.field_0)
                s = _633 + 32
                t = sha3(3)
                while _633 + (32 * supportedTokens.length) > s:
                    mem[s + 32] = address(stor1[t])
                    s = s + 32
                    t = t + 1
                    continue 
                _1237 = mem[mem[_408 + 64]]
                idx = 0
                while idx < _1237:
                    if idx >= mem[_632]:
                        revert with 0, 50
                    if mem[(32 * idx) + _632 + 32] >= mem[_633]:
                        revert with 0, 50
                    _1703 = mem[(32 * mem[(32 * idx) + _632 + 32]) + _633 + 32]
                    _1704 = mem[_408 + 224]
                    if idx >= mem[_631]:
                        revert with 0, 50
                    _1768 = mem[(32 * idx) + _631 + 32]
                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(_1704)
                    mem[mem[64] + 68] = _1768
                    require ext_code.size(address(_1703))
                    call address(_1703).transferFrom(address arg1, address arg2, uint256 arg3) with:
                         gas gas_remaining wei
                        args address(this.address), address(_1704), _1768
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if _633 + floor32((32 * supportedTokens.length) - 1) + 32 == -1:
                    revert with 0, 17
                s = _633 + floor32((32 * supportedTokens.length) - 1) + 33
                continue 
            mem[0] = sha3(5) + (9 * _405) + 3
            mem[_410 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 3)].field_0
            s = _410 + 32
            t = sha3(sha3(5) + (9 * _405) + 3)
            while _410 + (32 * stor5[_405].field_768) > s:
                mem[s + 32] = uint256(stor1[t])
                s = s + 32
                t = t + 1
                continue 
            mem[_408 + 96] = _410
            mem[_408 + 128] = stor5[_405].field_1024
            mem[_408 + 160] = stor5[_405].field_1280
            mem[_408 + 192] = stor5[_405].field_1536
            mem[_408 + 224] = address(stor5[_405].field_1792)
            if bool(stor5[_405].field_2048):
                if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                    revert with 0, 34
                _830 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor5[_405].field_2048) * 0.5) + 32
                mem[_830] = uint255(stor5[_405].field_2048) * 0.5
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[_405].field_2048):
                        mem[_408 + 256] = _830
                        _862 = mem[_408 + 64]
                        _864 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_864] = supportedTokens.length
                        if not supportedTokens.length:
                            _866 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _866:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_864]:
                                    revert with 0, 50
                                _1370 = mem[(32 * mem[(32 * s) + _410 + 32]) + _864 + 32]
                                _1371 = mem[_408 + 224]
                                if s >= mem[_862]:
                                    revert with 0, 50
                                _1470 = mem[(32 * s) + _862 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1371)
                                mem[mem[64] + 68] = _1470
                                require ext_code.size(address(_1370))
                                call address(_1370).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1371), _1470
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_864 + 32] = address(supportedTokens.field_0)
                            s = _864 + 32
                            t = sha3(3)
                            while _864 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1611 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1611:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_864]:
                                    revert with 0, 50
                                _2188 = mem[(32 * mem[(32 * s) + _410 + 32]) + _864 + 32]
                                _2189 = mem[_408 + 224]
                                if s >= mem[_862]:
                                    revert with 0, 50
                                _2288 = mem[(32 * s) + _862 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2189)
                                mem[mem[64] + 68] = _2288
                                require ext_code.size(address(_2188))
                                call address(_2188).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2189), _2288
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                            mem[_830 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                            mem[_408 + 256] = _830
                            _878 = mem[_408 + 64]
                            _880 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_880] = supportedTokens.length
                            if not supportedTokens.length:
                                _904 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _904:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_880]:
                                        revert with 0, 50
                                    _1376 = mem[(32 * mem[(32 * s) + _410 + 32]) + _880 + 32]
                                    _1377 = mem[_408 + 224]
                                    if s >= mem[_878]:
                                        revert with 0, 50
                                    _1472 = mem[(32 * s) + _878 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1377)
                                    mem[mem[64] + 68] = _1472
                                    require ext_code.size(address(_1376))
                                    call address(_1376).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1377), _1472
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_880 + 32] = address(supportedTokens.field_0)
                                s = _880 + 32
                                t = sha3(3)
                                while _880 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1613 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1613:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_880]:
                                        revert with 0, 50
                                    _2193 = mem[(32 * mem[(32 * s) + _410 + 32]) + _880 + 32]
                                    _2194 = mem[_408 + 224]
                                    if s >= mem[_878]:
                                        revert with 0, 50
                                    _2293 = mem[(32 * s) + _878 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2194)
                                    mem[mem[64] + 68] = _2293
                                    require ext_code.size(address(_2193))
                                    call address(_2193).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2194), _2293
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            mem[0] = sha3(5) + (9 * _405) + 8
                            mem[_830 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                            s = _830 + 32
                            t = sha3(sha3(5) + (9 * _405) + 8)
                            while _830 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_408 + 256] = _830
                            _1284 = mem[_408 + 64]
                            _1285 = mem[_408 + 96]
                            _1286 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1286] = supportedTokens.length
                            if not supportedTokens.length:
                                _1374 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1374:
                                    if s >= mem[_1285]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1285 + 32] >= mem[_1286]:
                                        revert with 0, 50
                                    _1708 = mem[(32 * mem[(32 * s) + _1285 + 32]) + _1286 + 32]
                                    _1709 = mem[_408 + 224]
                                    if s >= mem[_1284]:
                                        revert with 0, 50
                                    _1773 = mem[(32 * s) + _1284 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1709)
                                    mem[mem[64] + 68] = _1773
                                    require ext_code.size(address(_1708))
                                    call address(_1708).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1709), _1773
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1286 + 32] = address(supportedTokens.field_0)
                                s = _1286 + 32
                                t = sha3(3)
                                while _1286 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2081 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2081:
                                    if s >= mem[_1285]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1285 + 32] >= mem[_1286]:
                                        revert with 0, 50
                                    _2504 = mem[(32 * mem[(32 * s) + _1285 + 32]) + _1286 + 32]
                                    _2505 = mem[_408 + 224]
                                    if s >= mem[_1284]:
                                        revert with 0, 50
                                    _2556 = mem[(32 * s) + _1284 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2505)
                                    mem[mem[64] + 68] = _2556
                                    require ext_code.size(address(_2504))
                                    call address(_2504).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2505), _2556
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[_405].field_2049 % 128:
                        mem[_408 + 256] = _830
                        _869 = mem[_408 + 64]
                        _871 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_871] = supportedTokens.length
                        if not supportedTokens.length:
                            _882 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _882:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_871]:
                                    revert with 0, 50
                                _1379 = mem[(32 * mem[(32 * s) + _410 + 32]) + _871 + 32]
                                _1380 = mem[_408 + 224]
                                if s >= mem[_869]:
                                    revert with 0, 50
                                _1474 = mem[(32 * s) + _869 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1380)
                                mem[mem[64] + 68] = _1474
                                require ext_code.size(address(_1379))
                                call address(_1379).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1380), _1474
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_871 + 32] = address(supportedTokens.field_0)
                            s = _871 + 32
                            t = sha3(3)
                            while _871 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1615 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1615:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_871]:
                                    revert with 0, 50
                                _2196 = mem[(32 * mem[(32 * s) + _410 + 32]) + _871 + 32]
                                _2197 = mem[_408 + 224]
                                if s >= mem[_869]:
                                    revert with 0, 50
                                _2295 = mem[(32 * s) + _869 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2197)
                                mem[mem[64] + 68] = _2295
                                require ext_code.size(address(_2196))
                                call address(_2196).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2197), _2295
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                    else:
                        if 31 >= stor5[_405].field_2049 % 128:
                            mem[_830 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                            mem[_408 + 256] = _830
                            _906 = mem[_408 + 64]
                            _908 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_908] = supportedTokens.length
                            if not supportedTokens.length:
                                _937 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _937:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_908]:
                                        revert with 0, 50
                                    _1385 = mem[(32 * mem[(32 * s) + _410 + 32]) + _908 + 32]
                                    _1386 = mem[_408 + 224]
                                    if s >= mem[_906]:
                                        revert with 0, 50
                                    _1476 = mem[(32 * s) + _906 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1386)
                                    mem[mem[64] + 68] = _1476
                                    require ext_code.size(address(_1385))
                                    call address(_1385).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1386), _1476
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = 3
                            mem[_908 + 32] = address(supportedTokens.field_0)
                            s = _908 + 32
                            t = sha3(3)
                            while _908 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1617 = mem[mem[_408 + 64]]
                            idx = 0
                            while idx < _1617:
                                if idx >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * idx) + _410 + 32] >= mem[_908]:
                                    revert with 0, 50
                                _2201 = mem[(32 * mem[(32 * idx) + _410 + 32]) + _908 + 32]
                                _2202 = mem[_408 + 224]
                                if idx >= mem[_906]:
                                    revert with 0, 50
                                _2300 = mem[(32 * idx) + _906 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2202)
                                mem[mem[64] + 68] = _2300
                                require ext_code.size(address(_2201))
                                call address(_2201).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2202), _2300
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if _908 + floor32((32 * supportedTokens.length) - 1) + 32 == -1:
                                revert with 0, 17
                            s = _908 + floor32((32 * supportedTokens.length) - 1) + 33
                            continue 
                        mem[0] = sha3(5) + (9 * _405) + 8
                        mem[_830 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                        s = _830 + 32
                        t = sha3(sha3(5) + (9 * _405) + 8)
                        while _830 + stor5[_405].field_2049 % 128 > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_408 + 256] = _830
                        _1291 = mem[_408 + 64]
                        _1292 = mem[_408 + 96]
                        _1293 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_1293] = supportedTokens.length
                        if not supportedTokens.length:
                            _1383 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1383:
                                if s >= mem[_1292]:
                                    revert with 0, 50
                                if mem[(32 * s) + _1292 + 32] >= mem[_1293]:
                                    revert with 0, 50
                                _1715 = mem[(32 * mem[(32 * s) + _1292 + 32]) + _1293 + 32]
                                _1716 = mem[_408 + 224]
                                if s >= mem[_1291]:
                                    revert with 0, 50
                                _1781 = mem[(32 * s) + _1291 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1716)
                                mem[mem[64] + 68] = _1781
                                require ext_code.size(address(_1715))
                                call address(_1715).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1716), _1781
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_1293 + 32] = address(supportedTokens.field_0)
                            s = _1293 + 32
                            t = sha3(3)
                            while _1293 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _2083 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _2083:
                                if s >= mem[_1292]:
                                    revert with 0, 50
                                if mem[(32 * s) + _1292 + 32] >= mem[_1293]:
                                    revert with 0, 50
                                _2507 = mem[(32 * mem[(32 * s) + _1292 + 32]) + _1293 + 32]
                                _2508 = mem[_408 + 224]
                                if s >= mem[_1291]:
                                    revert with 0, 50
                                _2558 = mem[(32 * s) + _1291 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2508)
                                mem[mem[64] + 68] = _2558
                                require ext_code.size(address(_2507))
                                call address(_2507).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2508), _2558
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
            else:
                if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                    revert with 0, 34
                _847 = mem[64]
                mem[64] = mem[64] + ceil32(stor5[_405].field_2049 % 128) + 32
                mem[_847] = stor5[_405].field_2049 % 128
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[_405].field_2048):
                        mem[_408 + 256] = _847
                        _872 = mem[_408 + 64]
                        _874 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_874] = supportedTokens.length
                        if not supportedTokens.length:
                            _886 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _886:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_874]:
                                    revert with 0, 50
                                _1388 = mem[(32 * mem[(32 * s) + _410 + 32]) + _874 + 32]
                                _1389 = mem[_408 + 224]
                                if s >= mem[_872]:
                                    revert with 0, 50
                                _1478 = mem[(32 * s) + _872 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1389)
                                mem[mem[64] + 68] = _1478
                                require ext_code.size(address(_1388))
                                call address(_1388).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1389), _1478
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_874 + 32] = address(supportedTokens.field_0)
                            s = _874 + 32
                            t = sha3(3)
                            while _874 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1619 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1619:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_874]:
                                    revert with 0, 50
                                _2204 = mem[(32 * mem[(32 * s) + _410 + 32]) + _874 + 32]
                                _2205 = mem[_408 + 224]
                                if s >= mem[_872]:
                                    revert with 0, 50
                                _2302 = mem[(32 * s) + _872 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2205)
                                mem[mem[64] + 68] = _2302
                                require ext_code.size(address(_2204))
                                call address(_2204).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2205), _2302
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                            mem[_847 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                            mem[_408 + 256] = _847
                            _909 = mem[_408 + 64]
                            _911 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_911] = supportedTokens.length
                            if not supportedTokens.length:
                                _941 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _941:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_911]:
                                        revert with 0, 50
                                    _1394 = mem[(32 * mem[(32 * s) + _410 + 32]) + _911 + 32]
                                    _1395 = mem[_408 + 224]
                                    if s >= mem[_909]:
                                        revert with 0, 50
                                    _1480 = mem[(32 * s) + _909 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1395)
                                    mem[mem[64] + 68] = _1480
                                    require ext_code.size(address(_1394))
                                    call address(_1394).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1395), _1480
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            mem[0] = 3
                            mem[_911 + 32] = address(supportedTokens.field_0)
                            s = _911 + 32
                            t = sha3(3)
                            while _911 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1621 = mem[mem[_408 + 64]]
                            idx = 0
                            while idx < _1621:
                                if idx >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * idx) + _410 + 32] >= mem[_911]:
                                    revert with 0, 50
                                _2209 = mem[(32 * mem[(32 * idx) + _410 + 32]) + _911 + 32]
                                _2210 = mem[_408 + 224]
                                if idx >= mem[_909]:
                                    revert with 0, 50
                                _2307 = mem[(32 * idx) + _909 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2210)
                                mem[mem[64] + 68] = _2307
                                require ext_code.size(address(_2209))
                                call address(_2209).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2210), _2307
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if _911 + floor32((32 * supportedTokens.length) - 1) + 32 == -1:
                                revert with 0, 17
                            s = _911 + floor32((32 * supportedTokens.length) - 1) + 33
                            continue 
                        mem[0] = sha3(5) + (9 * _405) + 8
                        mem[_847 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                        s = _847 + 32
                        t = sha3(sha3(5) + (9 * _405) + 8)
                        while _847 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                            mem[s + 32] = uint256(stor1[t])
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_408 + 256] = _847
                        _1298 = mem[_408 + 64]
                        _1299 = mem[_408 + 96]
                        _1300 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_1300] = supportedTokens.length
                        if not supportedTokens.length:
                            _1392 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1392:
                                if s >= mem[_1299]:
                                    revert with 0, 50
                                if mem[(32 * s) + _1299 + 32] >= mem[_1300]:
                                    revert with 0, 50
                                _1722 = mem[(32 * mem[(32 * s) + _1299 + 32]) + _1300 + 32]
                                _1723 = mem[_408 + 224]
                                if s >= mem[_1298]:
                                    revert with 0, 50
                                _1789 = mem[(32 * s) + _1298 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1723)
                                mem[mem[64] + 68] = _1789
                                require ext_code.size(address(_1722))
                                call address(_1722).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1723), _1789
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_1300 + 32] = address(supportedTokens.field_0)
                            s = _1300 + 32
                            t = sha3(3)
                            while _1300 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _2085 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _2085:
                                if s >= mem[_1299]:
                                    revert with 0, 50
                                if mem[(32 * s) + _1299 + 32] >= mem[_1300]:
                                    revert with 0, 50
                                _2510 = mem[(32 * mem[(32 * s) + _1299 + 32]) + _1300 + 32]
                                _2511 = mem[_408 + 224]
                                if s >= mem[_1298]:
                                    revert with 0, 50
                                _2560 = mem[(32 * s) + _1298 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2511)
                                mem[mem[64] + 68] = _2560
                                require ext_code.size(address(_2510))
                                call address(_2510).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2511), _2560
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                else:
                    if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[_405].field_2049 % 128:
                        mem[_408 + 256] = _847
                        _889 = mem[_408 + 64]
                        _891 = mem[64]
                        mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                        mem[_891] = supportedTokens.length
                        if not supportedTokens.length:
                            _913 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _913:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_891]:
                                    revert with 0, 50
                                _1397 = mem[(32 * mem[(32 * s) + _410 + 32]) + _891 + 32]
                                _1398 = mem[_408 + 224]
                                if s >= mem[_889]:
                                    revert with 0, 50
                                _1482 = mem[(32 * s) + _889 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_1398)
                                mem[mem[64] + 68] = _1482
                                require ext_code.size(address(_1397))
                                call address(_1397).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_1398), _1482
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[_891 + 32] = address(supportedTokens.field_0)
                            s = _891 + 32
                            t = sha3(3)
                            while _891 + (32 * supportedTokens.length) > s:
                                mem[s + 32] = address(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            _1623 = mem[mem[_408 + 64]]
                            s = 0
                            while s < _1623:
                                if s >= mem[_410]:
                                    revert with 0, 50
                                if mem[(32 * s) + _410 + 32] >= mem[_891]:
                                    revert with 0, 50
                                _2212 = mem[(32 * mem[(32 * s) + _410 + 32]) + _891 + 32]
                                _2213 = mem[_408 + 224]
                                if s >= mem[_889]:
                                    revert with 0, 50
                                _2309 = mem[(32 * s) + _889 + 32]
                                mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = address(_2213)
                                mem[mem[64] + 68] = _2309
                                require ext_code.size(address(_2212))
                                call address(_2212).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(_2213), _2309
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                    else:
                        if 31 >= stor5[_405].field_2049 % 128:
                            mem[_847 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                            mem[_408 + 256] = _847
                            _943 = mem[_408 + 64]
                            _945 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_945] = supportedTokens.length
                            if not supportedTokens.length:
                                _979 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _979:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_945]:
                                        revert with 0, 50
                                    _1403 = mem[(32 * mem[(32 * s) + _410 + 32]) + _945 + 32]
                                    _1404 = mem[_408 + 224]
                                    if s >= mem[_943]:
                                        revert with 0, 50
                                    _1484 = mem[(32 * s) + _943 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1404)
                                    mem[mem[64] + 68] = _1484
                                    require ext_code.size(address(_1403))
                                    call address(_1403).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1404), _1484
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_945 + 32] = address(supportedTokens.field_0)
                                s = _945 + 32
                                t = sha3(3)
                                while _945 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1625 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1625:
                                    if s >= mem[_410]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _410 + 32] >= mem[_945]:
                                        revert with 0, 50
                                    _2217 = mem[(32 * mem[(32 * s) + _410 + 32]) + _945 + 32]
                                    _2218 = mem[_408 + 224]
                                    if s >= mem[_943]:
                                        revert with 0, 50
                                    _2314 = mem[(32 * s) + _943 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2218)
                                    mem[mem[64] + 68] = _2314
                                    require ext_code.size(address(_2217))
                                    call address(_2217).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2218), _2314
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            mem[0] = sha3(5) + (9 * _405) + 8
                            mem[_847 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                            s = _847 + 32
                            t = sha3(sha3(5) + (9 * _405) + 8)
                            while _847 + stor5[_405].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_408 + 256] = _847
                            _1305 = mem[_408 + 64]
                            _1306 = mem[_408 + 96]
                            _1307 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1307] = supportedTokens.length
                            if not supportedTokens.length:
                                _1401 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1401:
                                    if s >= mem[_1306]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1306 + 32] >= mem[_1307]:
                                        revert with 0, 50
                                    _1729 = mem[(32 * mem[(32 * s) + _1306 + 32]) + _1307 + 32]
                                    _1730 = mem[_408 + 224]
                                    if s >= mem[_1305]:
                                        revert with 0, 50
                                    _1797 = mem[(32 * s) + _1305 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1730)
                                    mem[mem[64] + 68] = _1797
                                    require ext_code.size(address(_1729))
                                    call address(_1729).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1730), _1797
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1307 + 32] = address(supportedTokens.field_0)
                                s = _1307 + 32
                                t = sha3(3)
                                while _1307 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2087 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2087:
                                    if s >= mem[_1306]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1306 + 32] >= mem[_1307]:
                                        revert with 0, 50
                                    _2513 = mem[(32 * mem[(32 * s) + _1306 + 32]) + _1307 + 32]
                                    _2514 = mem[_408 + 224]
                                    if s >= mem[_1305]:
                                        revert with 0, 50
                                    _2562 = mem[(32 * s) + _1305 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2514)
                                    mem[mem[64] + 68] = _2562
                                    require ext_code.size(address(_2513))
                                    call address(_2513).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2514), _2562
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
        else:
            mem[0] = sha3(5) + (9 * _405) + 2
            mem[_409 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 2)].field_0
            s = _409 + 32
            t = sha3(sha3(5) + (9 * _405) + 2)
            while _409 + (32 * stor5[_405].field_512) > s:
                mem[s + 32] = uint256(stor1[t])
                s = s + 32
                t = t + 1
                continue 
            mem[_408 + 64] = _409
            _748 = mem[64]
            mem[64] = mem[64] + (32 * stor5[_405].field_768) + 32
            mem[_748] = stor5[_405].field_768
            if not stor5[_405].field_768:
                mem[_408 + 96] = _748
                mem[_408 + 128] = stor5[_405].field_1024
                mem[_408 + 160] = stor5[_405].field_1280
                mem[_408 + 192] = stor5[_405].field_1536
                mem[_408 + 224] = address(stor5[_405].field_1792)
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    _848 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor5[_405].field_2048) * 0.5) + 32
                    mem[_848] = uint255(stor5[_405].field_2048) * 0.5
                    if bool(stor5[_405].field_2048):
                        if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor5[_405].field_2048):
                            mem[_408 + 256] = _848
                            _877 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_877] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_877]:
                                        revert with 0, 50
                                    _1406 = mem[(32 * mem[(32 * s) + _748 + 32]) + _877 + 32]
                                    _1407 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1486 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1407)
                                    mem[mem[64] + 68] = _1486
                                    require ext_code.size(address(_1406))
                                    call address(_1406).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1407), _1486
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_877 + 32] = address(supportedTokens.field_0)
                                s = _877 + 32
                                t = sha3(3)
                                while _877 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1627 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1627:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_877]:
                                        revert with 0, 50
                                    _2220 = mem[(32 * mem[(32 * s) + _748 + 32]) + _877 + 32]
                                    _2221 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _2316 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2221)
                                    mem[mem[64] + 68] = _2316
                                    require ext_code.size(address(_2220))
                                    call address(_2220).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2221), _2316
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                                mem[_848 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _848
                                _918 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_918] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_918]:
                                            revert with 0, 50
                                        _1412 = mem[(32 * mem[(32 * s) + _748 + 32]) + _918 + 32]
                                        _1413 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1488 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1413)
                                        mem[mem[64] + 68] = _1488
                                        require ext_code.size(address(_1412))
                                        call address(_1412).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1413), _1488
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_918 + 32] = address(supportedTokens.field_0)
                                    s = _918 + 32
                                    t = sha3(3)
                                    while _918 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _1629 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1629:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_918]:
                                            revert with 0, 50
                                        _2225 = mem[(32 * mem[(32 * s) + _748 + 32]) + _918 + 32]
                                        _2226 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _2321 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2226)
                                        mem[mem[64] + 68] = _2321
                                        require ext_code.size(address(_2225))
                                        call address(_2225).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2226), _2321
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_848 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _848 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _848 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _848
                                _1312 = mem[_408 + 64]
                                _1313 = mem[_408 + 96]
                                _1314 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1314] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1410 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1410:
                                        if s >= mem[_1313]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _1313 + 32] >= mem[_1314]:
                                            revert with 0, 50
                                        _1736 = mem[(32 * mem[(32 * s) + _1313 + 32]) + _1314 + 32]
                                        _1737 = mem[_408 + 224]
                                        if s >= mem[_1312]:
                                            revert with 0, 50
                                        _1805 = mem[(32 * s) + _1312 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1737)
                                        mem[mem[64] + 68] = _1805
                                        require ext_code.size(address(_1736))
                                        call address(_1736).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1737), _1805
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1314 + 32] = address(supportedTokens.field_0)
                                    s = _1314 + 32
                                    t = sha3(3)
                                    while _1314 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2089 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2089:
                                        if s >= mem[_1313]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _1313 + 32] >= mem[_1314]:
                                            revert with 0, 50
                                        _2516 = mem[(32 * mem[(32 * s) + _1313 + 32]) + _1314 + 32]
                                        _2517 = mem[_408 + 224]
                                        if s >= mem[_1312]:
                                            revert with 0, 50
                                        _2564 = mem[(32 * s) + _1312 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2517)
                                        mem[mem[64] + 68] = _2564
                                        require ext_code.size(address(_2516))
                                        call address(_2516).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2517), _2564
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                            revert with 0, 34
                        if not stor5[_405].field_2049 % 128:
                            mem[_408 + 256] = _848
                            _898 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_898] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_898]:
                                        revert with 0, 50
                                    _1415 = mem[(32 * mem[(32 * s) + _748 + 32]) + _898 + 32]
                                    _1416 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1490 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1416)
                                    mem[mem[64] + 68] = _1490
                                    require ext_code.size(address(_1415))
                                    call address(_1415).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1416), _1490
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_898 + 32] = address(supportedTokens.field_0)
                                s = _898 + 32
                                t = sha3(3)
                                while _898 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1631 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1631:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_898]:
                                        revert with 0, 50
                                    _2228 = mem[(32 * mem[(32 * s) + _748 + 32]) + _898 + 32]
                                    _2229 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _2323 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2229)
                                    mem[mem[64] + 68] = _2323
                                    require ext_code.size(address(_2228))
                                    call address(_2228).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2229), _2323
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= stor5[_405].field_2049 % 128:
                                mem[_848 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _848
                                _952 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_952] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_952]:
                                            revert with 0, 50
                                        _1421 = mem[(32 * mem[(32 * s) + _748 + 32]) + _952 + 32]
                                        _1422 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1492 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1422)
                                        mem[mem[64] + 68] = _1492
                                        require ext_code.size(address(_1421))
                                        call address(_1421).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1422), _1492
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[0] = 3
                                mem[_952 + 32] = address(supportedTokens.field_0)
                                s = _952 + 32
                                t = sha3(3)
                                while _952 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1633 = mem[mem[_408 + 64]]
                                idx = 0
                                while idx < _1633:
                                    if idx >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * idx) + _748 + 32] >= mem[_952]:
                                        revert with 0, 50
                                    _2233 = mem[(32 * mem[(32 * idx) + _748 + 32]) + _952 + 32]
                                    _2234 = mem[_408 + 224]
                                    if idx >= mem[_409]:
                                        revert with 0, 50
                                    _2328 = mem[(32 * idx) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2234)
                                    mem[mem[64] + 68] = _2328
                                    require ext_code.size(address(_2233))
                                    call address(_2233).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2234), _2328
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if _952 + floor32((32 * supportedTokens.length) - 1) + 32 == -1:
                                    revert with 0, 17
                                s = _952 + floor32((32 * supportedTokens.length) - 1) + 33
                                continue 
                            mem[0] = sha3(5) + (9 * _405) + 8
                            mem[_848 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                            s = _848 + 32
                            t = sha3(sha3(5) + (9 * _405) + 8)
                            while _848 + stor5[_405].field_2049 % 128 > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_408 + 256] = _848
                            _1319 = mem[_408 + 64]
                            _1320 = mem[_408 + 96]
                            _1321 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1321] = supportedTokens.length
                            if not supportedTokens.length:
                                _1419 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1419:
                                    if s >= mem[_1320]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1320 + 32] >= mem[_1321]:
                                        revert with 0, 50
                                    _1743 = mem[(32 * mem[(32 * s) + _1320 + 32]) + _1321 + 32]
                                    _1744 = mem[_408 + 224]
                                    if s >= mem[_1319]:
                                        revert with 0, 50
                                    _1813 = mem[(32 * s) + _1319 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1744)
                                    mem[mem[64] + 68] = _1813
                                    require ext_code.size(address(_1743))
                                    call address(_1743).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1744), _1813
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1321 + 32] = address(supportedTokens.field_0)
                                s = _1321 + 32
                                t = sha3(3)
                                while _1321 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2091 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2091:
                                    if s >= mem[_1320]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1320 + 32] >= mem[_1321]:
                                        revert with 0, 50
                                    _2519 = mem[(32 * mem[(32 * s) + _1320 + 32]) + _1321 + 32]
                                    _2520 = mem[_408 + 224]
                                    if s >= mem[_1319]:
                                        revert with 0, 50
                                    _2566 = mem[(32 * s) + _1319 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2520)
                                    mem[mem[64] + 68] = _2566
                                    require ext_code.size(address(_2519))
                                    call address(_2519).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2520), _2566
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                else:
                    if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                        revert with 0, 34
                    _853 = mem[64]
                    mem[64] = mem[64] + ceil32(stor5[_405].field_2049 % 128) + 32
                    mem[_853] = stor5[_405].field_2049 % 128
                    if bool(stor5[_405].field_2048):
                        if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor5[_405].field_2048):
                            mem[_408 + 256] = _853
                            _901 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_901] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_901]:
                                        revert with 0, 50
                                    _1424 = mem[(32 * mem[(32 * s) + _748 + 32]) + _901 + 32]
                                    _1425 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1494 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1425)
                                    mem[mem[64] + 68] = _1494
                                    require ext_code.size(address(_1424))
                                    call address(_1424).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1425), _1494
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_901 + 32] = address(supportedTokens.field_0)
                                s = _901 + 32
                                t = sha3(3)
                                while _901 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1635 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1635:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_901]:
                                        revert with 0, 50
                                    _2236 = mem[(32 * mem[(32 * s) + _748 + 32]) + _901 + 32]
                                    _2237 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _2330 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2237)
                                    mem[mem[64] + 68] = _2330
                                    require ext_code.size(address(_2236))
                                    call address(_2236).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2237), _2330
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                                mem[_853 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _853
                                _955 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_955] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_955]:
                                            revert with 0, 50
                                        _1430 = mem[(32 * mem[(32 * s) + _748 + 32]) + _955 + 32]
                                        _1431 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1496 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1431)
                                        mem[mem[64] + 68] = _1496
                                        require ext_code.size(address(_1430))
                                        call address(_1430).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1431), _1496
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                mem[0] = 3
                                mem[_955 + 32] = address(supportedTokens.field_0)
                                s = _955 + 32
                                t = sha3(3)
                                while _955 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1637 = mem[mem[_408 + 64]]
                                idx = 0
                                while idx < _1637:
                                    if idx >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * idx) + _748 + 32] >= mem[_955]:
                                        revert with 0, 50
                                    _2241 = mem[(32 * mem[(32 * idx) + _748 + 32]) + _955 + 32]
                                    _2242 = mem[_408 + 224]
                                    if idx >= mem[_409]:
                                        revert with 0, 50
                                    _2335 = mem[(32 * idx) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2242)
                                    mem[mem[64] + 68] = _2335
                                    require ext_code.size(address(_2241))
                                    call address(_2241).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2242), _2335
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if _955 + floor32((32 * supportedTokens.length) - 1) + 32 == -1:
                                    revert with 0, 17
                                s = _955 + floor32((32 * supportedTokens.length) - 1) + 33
                                continue 
                            mem[0] = sha3(5) + (9 * _405) + 8
                            mem[_853 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                            s = _853 + 32
                            t = sha3(sha3(5) + (9 * _405) + 8)
                            while _853 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                mem[s + 32] = uint256(stor1[t])
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_408 + 256] = _853
                            _1326 = mem[_408 + 64]
                            _1327 = mem[_408 + 96]
                            _1328 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1328] = supportedTokens.length
                            if not supportedTokens.length:
                                _1428 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1428:
                                    if s >= mem[_1327]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1327 + 32] >= mem[_1328]:
                                        revert with 0, 50
                                    _1750 = mem[(32 * mem[(32 * s) + _1327 + 32]) + _1328 + 32]
                                    _1751 = mem[_408 + 224]
                                    if s >= mem[_1326]:
                                        revert with 0, 50
                                    _1821 = mem[(32 * s) + _1326 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1751)
                                    mem[mem[64] + 68] = _1821
                                    require ext_code.size(address(_1750))
                                    call address(_1750).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1751), _1821
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1328 + 32] = address(supportedTokens.field_0)
                                s = _1328 + 32
                                t = sha3(3)
                                while _1328 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2093 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2093:
                                    if s >= mem[_1327]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _1327 + 32] >= mem[_1328]:
                                        revert with 0, 50
                                    _2522 = mem[(32 * mem[(32 * s) + _1327 + 32]) + _1328 + 32]
                                    _2523 = mem[_408 + 224]
                                    if s >= mem[_1326]:
                                        revert with 0, 50
                                    _2568 = mem[(32 * s) + _1326 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2523)
                                    mem[mem[64] + 68] = _2568
                                    require ext_code.size(address(_2522))
                                    call address(_2522).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2523), _2568
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                            revert with 0, 34
                        if not stor5[_405].field_2049 % 128:
                            mem[_408 + 256] = _853
                            _929 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_929] = supportedTokens.length
                            if not supportedTokens.length:
                                s = 0
                                while s < stor5[_405].field_512:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_929]:
                                        revert with 0, 50
                                    _1433 = mem[(32 * mem[(32 * s) + _748 + 32]) + _929 + 32]
                                    _1434 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _1498 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_1434)
                                    mem[mem[64] + 68] = _1498
                                    require ext_code.size(address(_1433))
                                    call address(_1433).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_1434), _1498
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_929 + 32] = address(supportedTokens.field_0)
                                s = _929 + 32
                                t = sha3(3)
                                while _929 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _1639 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1639:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_929]:
                                        revert with 0, 50
                                    _2244 = mem[(32 * mem[(32 * s) + _748 + 32]) + _929 + 32]
                                    _2245 = mem[_408 + 224]
                                    if s >= mem[_409]:
                                        revert with 0, 50
                                    _2337 = mem[(32 * s) + _409 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2245)
                                    mem[mem[64] + 68] = _2337
                                    require ext_code.size(address(_2244))
                                    call address(_2244).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2245), _2337
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= stor5[_405].field_2049 % 128:
                                mem[_853 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _853
                                _996 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_996] = supportedTokens.length
                                if not supportedTokens.length:
                                    s = 0
                                    while s < stor5[_405].field_512:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_996]:
                                            revert with 0, 50
                                        _1439 = mem[(32 * mem[(32 * s) + _748 + 32]) + _996 + 32]
                                        _1440 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _1500 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1440)
                                        mem[mem[64] + 68] = _1500
                                        require ext_code.size(address(_1439))
                                        call address(_1439).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1440), _1500
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_996 + 32] = address(supportedTokens.field_0)
                                    s = _996 + 32
                                    t = sha3(3)
                                    while _996 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _1641 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1641:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_996]:
                                            revert with 0, 50
                                        _2249 = mem[(32 * mem[(32 * s) + _748 + 32]) + _996 + 32]
                                        _2250 = mem[_408 + 224]
                                        if s >= mem[_409]:
                                            revert with 0, 50
                                        _2342 = mem[(32 * s) + _409 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2250)
                                        mem[mem[64] + 68] = _2342
                                        require ext_code.size(address(_2249))
                                        call address(_2249).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2250), _2342
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_853 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _853 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _853 + stor5[_405].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _853
                                _1333 = mem[_408 + 64]
                                _1334 = mem[_408 + 96]
                                _1335 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1335] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1437 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1437:
                                        if s >= mem[_1334]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _1334 + 32] >= mem[_1335]:
                                            revert with 0, 50
                                        _1757 = mem[(32 * mem[(32 * s) + _1334 + 32]) + _1335 + 32]
                                        _1758 = mem[_408 + 224]
                                        if s >= mem[_1333]:
                                            revert with 0, 50
                                        _1829 = mem[(32 * s) + _1333 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_1758)
                                        mem[mem[64] + 68] = _1829
                                        require ext_code.size(address(_1757))
                                        call address(_1757).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_1758), _1829
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1335 + 32] = address(supportedTokens.field_0)
                                    s = _1335 + 32
                                    t = sha3(3)
                                    while _1335 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2095 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2095:
                                        if s >= mem[_1334]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _1334 + 32] >= mem[_1335]:
                                            revert with 0, 50
                                        _2525 = mem[(32 * mem[(32 * s) + _1334 + 32]) + _1335 + 32]
                                        _2526 = mem[_408 + 224]
                                        if s >= mem[_1333]:
                                            revert with 0, 50
                                        _2570 = mem[(32 * s) + _1333 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2526)
                                        mem[mem[64] + 68] = _2570
                                        require ext_code.size(address(_2525))
                                        call address(_2525).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2526), _2570
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
            else:
                mem[0] = sha3(5) + (9 * _405) + 3
                mem[_748 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 3)].field_0
                s = _748 + 32
                t = sha3(sha3(5) + (9 * _405) + 3)
                while _748 + (32 * stor5[_405].field_768) > s:
                    mem[s + 32] = uint256(stor1[t])
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_408 + 96] = _748
                mem[_408 + 128] = stor5[_405].field_1024
                mem[_408 + 160] = stor5[_405].field_1280
                mem[_408 + 192] = stor5[_405].field_1536
                mem[_408 + 224] = address(stor5[_405].field_1792)
                if bool(stor5[_405].field_2048):
                    if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    _1834 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor5[_405].field_2048) * 0.5) + 32
                    mem[_1834] = uint255(stor5[_405].field_2048) * 0.5
                    if bool(stor5[_405].field_2048):
                        if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor5[_405].field_2048):
                            mem[_408 + 256] = _1834
                            _1896 = mem[_408 + 64]
                            _1898 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1898] = supportedTokens.length
                            if not supportedTokens.length:
                                _1900 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1900:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1898]:
                                        revert with 0, 50
                                    _2252 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1898 + 32]
                                    _2253 = mem[_408 + 224]
                                    if s >= mem[_1896]:
                                        revert with 0, 50
                                    _2344 = mem[(32 * s) + _1896 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2253)
                                    mem[mem[64] + 68] = _2344
                                    require ext_code.size(address(_2252))
                                    call address(_2252).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2253), _2344
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1898 + 32] = address(supportedTokens.field_0)
                                s = _1898 + 32
                                t = sha3(3)
                                while _1898 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2445 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2445:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1898]:
                                        revert with 0, 50
                                    _2676 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1898 + 32]
                                    _2677 = mem[_408 + 224]
                                    if s >= mem[_1896]:
                                        revert with 0, 50
                                    _2708 = mem[(32 * s) + _1896 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2677)
                                    mem[mem[64] + 68] = _2708
                                    require ext_code.size(address(_2676))
                                    call address(_2676).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2677), _2708
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                                mem[_1834 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _1834
                                _1909 = mem[_408 + 64]
                                _1911 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1911] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1925 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1925:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1911]:
                                            revert with 0, 50
                                        _2258 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1911 + 32]
                                        _2259 = mem[_408 + 224]
                                        if s >= mem[_1909]:
                                            revert with 0, 50
                                        _2346 = mem[(32 * s) + _1909 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2259)
                                        mem[mem[64] + 68] = _2346
                                        require ext_code.size(address(_2258))
                                        call address(_2258).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2259), _2346
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1911 + 32] = address(supportedTokens.field_0)
                                    s = _1911 + 32
                                    t = sha3(3)
                                    while _1911 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2447 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2447:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1911]:
                                            revert with 0, 50
                                        _2681 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1911 + 32]
                                        _2682 = mem[_408 + 224]
                                        if s >= mem[_1909]:
                                            revert with 0, 50
                                        _2713 = mem[(32 * s) + _1909 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2682)
                                        mem[mem[64] + 68] = _2713
                                        require ext_code.size(address(_2681))
                                        call address(_2681).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2682), _2713
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_1834 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _1834 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _1834 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _1834
                                _2162 = mem[_408 + 64]
                                _2163 = mem[_408 + 96]
                                _2164 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_2164] = supportedTokens.length
                                if not supportedTokens.length:
                                    _2256 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2256:
                                        if s >= mem[_2163]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2163 + 32] >= mem[_2164]:
                                            revert with 0, 50
                                        _2530 = mem[(32 * mem[(32 * s) + _2163 + 32]) + _2164 + 32]
                                        _2531 = mem[_408 + 224]
                                        if s >= mem[_2162]:
                                            revert with 0, 50
                                        _2575 = mem[(32 * s) + _2162 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2531)
                                        mem[mem[64] + 68] = _2575
                                        require ext_code.size(address(_2530))
                                        call address(_2530).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2531), _2575
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_2164 + 32] = address(supportedTokens.field_0)
                                    s = _2164 + 32
                                    t = sha3(3)
                                    while _2164 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2641 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2641:
                                        if s >= mem[_2163]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2163 + 32] >= mem[_2164]:
                                            revert with 0, 50
                                        _2768 = mem[(32 * mem[(32 * s) + _2163 + 32]) + _2164 + 32]
                                        _2769 = mem[_408 + 224]
                                        if s >= mem[_2162]:
                                            revert with 0, 50
                                        _2780 = mem[(32 * s) + _2162 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2769)
                                        mem[mem[64] + 68] = _2780
                                        require ext_code.size(address(_2768))
                                        call address(_2768).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2769), _2780
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                            revert with 0, 34
                        if not stor5[_405].field_2049 % 128:
                            mem[_408 + 256] = _1834
                            _1903 = mem[_408 + 64]
                            _1905 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1905] = supportedTokens.length
                            if not supportedTokens.length:
                                _1913 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1913:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1905]:
                                        revert with 0, 50
                                    _2261 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1905 + 32]
                                    _2262 = mem[_408 + 224]
                                    if s >= mem[_1903]:
                                        revert with 0, 50
                                    _2348 = mem[(32 * s) + _1903 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2262)
                                    mem[mem[64] + 68] = _2348
                                    require ext_code.size(address(_2261))
                                    call address(_2261).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2262), _2348
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1905 + 32] = address(supportedTokens.field_0)
                                s = _1905 + 32
                                t = sha3(3)
                                while _1905 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2449 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2449:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1905]:
                                        revert with 0, 50
                                    _2684 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1905 + 32]
                                    _2685 = mem[_408 + 224]
                                    if s >= mem[_1903]:
                                        revert with 0, 50
                                    _2715 = mem[(32 * s) + _1903 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2685)
                                    mem[mem[64] + 68] = _2715
                                    require ext_code.size(address(_2684))
                                    call address(_2684).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2685), _2715
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= stor5[_405].field_2049 % 128:
                                mem[_1834 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _1834
                                _1927 = mem[_408 + 64]
                                _1929 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1929] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1944 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1944:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1929]:
                                            revert with 0, 50
                                        _2267 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1929 + 32]
                                        _2268 = mem[_408 + 224]
                                        if s >= mem[_1927]:
                                            revert with 0, 50
                                        _2350 = mem[(32 * s) + _1927 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2268)
                                        mem[mem[64] + 68] = _2350
                                        require ext_code.size(address(_2267))
                                        call address(_2267).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2268), _2350
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1929 + 32] = address(supportedTokens.field_0)
                                    s = _1929 + 32
                                    t = sha3(3)
                                    while _1929 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2451 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2451:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1929]:
                                            revert with 0, 50
                                        _2689 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1929 + 32]
                                        _2690 = mem[_408 + 224]
                                        if s >= mem[_1927]:
                                            revert with 0, 50
                                        _2720 = mem[(32 * s) + _1927 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2690)
                                        mem[mem[64] + 68] = _2720
                                        require ext_code.size(address(_2689))
                                        call address(_2689).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2690), _2720
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_1834 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _1834 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _1834 + stor5[_405].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _1834
                                _2169 = mem[_408 + 64]
                                _2170 = mem[_408 + 96]
                                _2171 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_2171] = supportedTokens.length
                                if not supportedTokens.length:
                                    _2265 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2265:
                                        if s >= mem[_2170]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2170 + 32] >= mem[_2171]:
                                            revert with 0, 50
                                        _2537 = mem[(32 * mem[(32 * s) + _2170 + 32]) + _2171 + 32]
                                        _2538 = mem[_408 + 224]
                                        if s >= mem[_2169]:
                                            revert with 0, 50
                                        _2583 = mem[(32 * s) + _2169 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2538)
                                        mem[mem[64] + 68] = _2583
                                        require ext_code.size(address(_2537))
                                        call address(_2537).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2538), _2583
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_2171 + 32] = address(supportedTokens.field_0)
                                    s = _2171 + 32
                                    t = sha3(3)
                                    while _2171 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2643 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2643:
                                        if s >= mem[_2170]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2170 + 32] >= mem[_2171]:
                                            revert with 0, 50
                                        _2771 = mem[(32 * mem[(32 * s) + _2170 + 32]) + _2171 + 32]
                                        _2772 = mem[_408 + 224]
                                        if s >= mem[_2169]:
                                            revert with 0, 50
                                        _2782 = mem[(32 * s) + _2169 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2772)
                                        mem[mem[64] + 68] = _2782
                                        require ext_code.size(address(_2771))
                                        call address(_2771).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2772), _2782
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                else:
                    if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                        revert with 0, 34
                    _1867 = mem[64]
                    mem[64] = mem[64] + ceil32(stor5[_405].field_2049 % 128) + 32
                    mem[_1867] = stor5[_405].field_2049 % 128
                    if bool(stor5[_405].field_2048):
                        if bool(stor5[_405].field_2048) == uint255(stor5[_405].field_2048) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor5[_405].field_2048):
                            mem[_408 + 256] = _1867
                            _1906 = mem[_408 + 64]
                            _1908 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1908] = supportedTokens.length
                            if not supportedTokens.length:
                                _1917 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1917:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1908]:
                                        revert with 0, 50
                                    _2270 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1908 + 32]
                                    _2271 = mem[_408 + 224]
                                    if s >= mem[_1906]:
                                        revert with 0, 50
                                    _2352 = mem[(32 * s) + _1906 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2271)
                                    mem[mem[64] + 68] = _2352
                                    require ext_code.size(address(_2270))
                                    call address(_2270).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2271), _2352
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1908 + 32] = address(supportedTokens.field_0)
                                s = _1908 + 32
                                t = sha3(3)
                                while _1908 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2453 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2453:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1908]:
                                        revert with 0, 50
                                    _2692 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1908 + 32]
                                    _2693 = mem[_408 + 224]
                                    if s >= mem[_1906]:
                                        revert with 0, 50
                                    _2722 = mem[(32 * s) + _1906 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2693)
                                    mem[mem[64] + 68] = _2722
                                    require ext_code.size(address(_2692))
                                    call address(_2692).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2693), _2722
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= uint255(stor5[_405].field_2048) * 0.5:
                                mem[_1867 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _1867
                                _1930 = mem[_408 + 64]
                                _1932 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1932] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1948 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1948:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1932]:
                                            revert with 0, 50
                                        _2276 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1932 + 32]
                                        _2277 = mem[_408 + 224]
                                        if s >= mem[_1930]:
                                            revert with 0, 50
                                        _2354 = mem[(32 * s) + _1930 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2277)
                                        mem[mem[64] + 68] = _2354
                                        require ext_code.size(address(_2276))
                                        call address(_2276).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2277), _2354
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1932 + 32] = address(supportedTokens.field_0)
                                    s = _1932 + 32
                                    t = sha3(3)
                                    while _1932 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2455 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2455:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1932]:
                                            revert with 0, 50
                                        _2697 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1932 + 32]
                                        _2698 = mem[_408 + 224]
                                        if s >= mem[_1930]:
                                            revert with 0, 50
                                        _2727 = mem[(32 * s) + _1930 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2698)
                                        mem[mem[64] + 68] = _2727
                                        require ext_code.size(address(_2697))
                                        call address(_2697).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2698), _2727
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_1867 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _1867 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _1867 + (uint255(stor5[_405].field_2048) * 0.5) > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _1867
                                _2176 = mem[_408 + 64]
                                _2177 = mem[_408 + 96]
                                _2178 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_2178] = supportedTokens.length
                                if not supportedTokens.length:
                                    _2274 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2274:
                                        if s >= mem[_2177]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2177 + 32] >= mem[_2178]:
                                            revert with 0, 50
                                        _2544 = mem[(32 * mem[(32 * s) + _2177 + 32]) + _2178 + 32]
                                        _2545 = mem[_408 + 224]
                                        if s >= mem[_2176]:
                                            revert with 0, 50
                                        _2591 = mem[(32 * s) + _2176 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2545)
                                        mem[mem[64] + 68] = _2591
                                        require ext_code.size(address(_2544))
                                        call address(_2544).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2545), _2591
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_2178 + 32] = address(supportedTokens.field_0)
                                    s = _2178 + 32
                                    t = sha3(3)
                                    while _2178 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2645 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2645:
                                        if s >= mem[_2177]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2177 + 32] >= mem[_2178]:
                                            revert with 0, 50
                                        _2774 = mem[(32 * mem[(32 * s) + _2177 + 32]) + _2178 + 32]
                                        _2775 = mem[_408 + 224]
                                        if s >= mem[_2176]:
                                            revert with 0, 50
                                        _2784 = mem[(32 * s) + _2176 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2775)
                                        mem[mem[64] + 68] = _2784
                                        require ext_code.size(address(_2774))
                                        call address(_2774).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2775), _2784
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                    else:
                        if bool(stor5[_405].field_2048) == stor5[_405].field_2049 % 128 < 32:
                            revert with 0, 34
                        if not stor5[_405].field_2049 % 128:
                            mem[_408 + 256] = _1867
                            _1920 = mem[_408 + 64]
                            _1922 = mem[64]
                            mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                            mem[_1922] = supportedTokens.length
                            if not supportedTokens.length:
                                _1934 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _1934:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1922]:
                                        revert with 0, 50
                                    _2279 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1922 + 32]
                                    _2280 = mem[_408 + 224]
                                    if s >= mem[_1920]:
                                        revert with 0, 50
                                    _2356 = mem[(32 * s) + _1920 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2280)
                                    mem[mem[64] + 68] = _2356
                                    require ext_code.size(address(_2279))
                                    call address(_2279).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2280), _2356
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[_1922 + 32] = address(supportedTokens.field_0)
                                s = _1922 + 32
                                t = sha3(3)
                                while _1922 + (32 * supportedTokens.length) > s:
                                    mem[s + 32] = address(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                _2457 = mem[mem[_408 + 64]]
                                s = 0
                                while s < _2457:
                                    if s >= mem[_748]:
                                        revert with 0, 50
                                    if mem[(32 * s) + _748 + 32] >= mem[_1922]:
                                        revert with 0, 50
                                    _2700 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1922 + 32]
                                    _2701 = mem[_408 + 224]
                                    if s >= mem[_1920]:
                                        revert with 0, 50
                                    _2729 = mem[(32 * s) + _1920 + 32]
                                    mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = address(_2701)
                                    mem[mem[64] + 68] = _2729
                                    require ext_code.size(address(_2700))
                                    call address(_2700).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(_2701), _2729
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    continue 
                        else:
                            if 31 >= stor5[_405].field_2049 % 128:
                                mem[_1867 + 32] = 256 * Mask(248, 0, stor5[_405].field_2056)
                                mem[_408 + 256] = _1867
                                _1950 = mem[_408 + 64]
                                _1952 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_1952] = supportedTokens.length
                                if not supportedTokens.length:
                                    _1972 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _1972:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1952]:
                                            revert with 0, 50
                                        _2285 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1952 + 32]
                                        _2286 = mem[_408 + 224]
                                        if s >= mem[_1950]:
                                            revert with 0, 50
                                        _2358 = mem[(32 * s) + _1950 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2286)
                                        mem[mem[64] + 68] = _2358
                                        require ext_code.size(address(_2285))
                                        call address(_2285).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2286), _2358
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_1952 + 32] = address(supportedTokens.field_0)
                                    s = _1952 + 32
                                    t = sha3(3)
                                    while _1952 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2459 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2459:
                                        if s >= mem[_748]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _748 + 32] >= mem[_1952]:
                                            revert with 0, 50
                                        _2705 = mem[(32 * mem[(32 * s) + _748 + 32]) + _1952 + 32]
                                        _2706 = mem[_408 + 224]
                                        if s >= mem[_1950]:
                                            revert with 0, 50
                                        _2734 = mem[(32 * s) + _1950 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2706)
                                        mem[mem[64] + 68] = _2734
                                        require ext_code.size(address(_2705))
                                        call address(_2705).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2706), _2734
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                            else:
                                mem[0] = sha3(5) + (9 * _405) + 8
                                mem[_1867 + 32] = stor[sha3(('name', 'stor5', 5) + (9 * _405) + 8)].field_0
                                s = _1867 + 32
                                t = sha3(sha3(5) + (9 * _405) + 8)
                                while _1867 + stor5[_405].field_2049 % 128 > s:
                                    mem[s + 32] = uint256(stor1[t])
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_408 + 256] = _1867
                                _2183 = mem[_408 + 64]
                                _2184 = mem[_408 + 96]
                                _2185 = mem[64]
                                mem[64] = mem[64] + (32 * supportedTokens.length) + 32
                                mem[_2185] = supportedTokens.length
                                if not supportedTokens.length:
                                    _2283 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2283:
                                        if s >= mem[_2184]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2184 + 32] >= mem[_2185]:
                                            revert with 0, 50
                                        _2551 = mem[(32 * mem[(32 * s) + _2184 + 32]) + _2185 + 32]
                                        _2552 = mem[_408 + 224]
                                        if s >= mem[_2183]:
                                            revert with 0, 50
                                        _2599 = mem[(32 * s) + _2183 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2552)
                                        mem[mem[64] + 68] = _2599
                                        require ext_code.size(address(_2551))
                                        call address(_2551).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2552), _2599
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
                                else:
                                    mem[0] = 3
                                    mem[_2185 + 32] = address(supportedTokens.field_0)
                                    s = _2185 + 32
                                    t = sha3(3)
                                    while _2185 + (32 * supportedTokens.length) > s:
                                        mem[s + 32] = address(stor1[t])
                                        s = s + 32
                                        t = t + 1
                                        continue 
                                    _2647 = mem[mem[_408 + 64]]
                                    s = 0
                                    while s < _2647:
                                        if s >= mem[_2184]:
                                            revert with 0, 50
                                        if mem[(32 * s) + _2184 + 32] >= mem[_2185]:
                                            revert with 0, 50
                                        _2777 = mem[(32 * mem[(32 * s) + _2184 + 32]) + _2185 + 32]
                                        _2778 = mem[_408 + 224]
                                        if s >= mem[_2183]:
                                            revert with 0, 50
                                        _2786 = mem[(32 * s) + _2183 + 32]
                                        mem[mem[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = address(_2778)
                                        mem[mem[64] + 68] = _2786
                                        require ext_code.size(address(_2777))
                                        call address(_2777).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                             gas gas_remaining wei
                                            args address(this.address), address(_2778), _2786
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_30a40b6c(?) {
    require calldata.size - 4 >= 32
    if arg1 >= stor5.length:
        revert with 0, 'Invalid Collection'
    mem[96] = bool(uint8(stor5[arg1].field_0))
    mem[128] = stor5[arg1].field_256
    mem[384] = stor5[arg1].field_512
    if not stor5[arg1].field_512:
        mem[160] = 384
        mem[(32 * stor5[arg1].field_512) + 416] = stor5[arg1].field_768
        if not stor5[arg1].field_768:
            mem[192] = (32 * stor5[arg1].field_512) + 416
            mem[224] = stor5[arg1].field_1024
            mem[256] = stor5[arg1].field_1280
            mem[288] = stor5[arg1].field_1536
            mem[320] = address(stor5[arg1].field_1792)
            if bool(stor5[arg1].field_2048):
                if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = uint255(stor5[arg1].field_2048) * 0.5
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _615 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _655 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _655
                                require ext_code.size(address(_615))
                                call address(_615).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _655
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2265 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2385 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2385
                                require ext_code.size(address(_2265))
                                call address(_2265).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2385
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _621 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _659 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _659
                                    require ext_code.size(address(_621))
                                    call address(_621).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _659
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2271 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2391 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2391
                                    require ext_code.size(address(_2271))
                                    call address(_2271).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2391
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _907 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _941 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _941
                                    require ext_code.size(address(_907))
                                    call address(_907).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _941
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2949 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3029 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3029
                                    require ext_code.size(address(_2949))
                                    call address(_2949).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3029
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _625 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _661 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _661
                                require ext_code.size(address(_625))
                                call address(_625).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _661
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2275 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2393 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2393
                                require ext_code.size(address(_2275))
                                call address(_2275).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2393
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _631 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _665 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _665
                                    require ext_code.size(address(_631))
                                    call address(_631).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _665
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2281 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2399 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2399
                                    require ext_code.size(address(_2281))
                                    call address(_2281).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2399
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _915 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _951 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _951
                                    require ext_code.size(address(_915))
                                    call address(_915).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _951
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2953 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3031 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3031
                                    require ext_code.size(address(_2953))
                                    call address(_2953).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3031
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = stor5[arg1].field_2049 % 128
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _635 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _667 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _667
                                require ext_code.size(address(_635))
                                call address(_635).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _667
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2285 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2401 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2401
                                require ext_code.size(address(_2285))
                                call address(_2285).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2401
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _641 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _671 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _671
                                    require ext_code.size(address(_641))
                                    call address(_641).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _671
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2291 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2407 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2407
                                    require ext_code.size(address(_2291))
                                    call address(_2291).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2407
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _923 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _961 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _961
                                    require ext_code.size(address(_923))
                                    call address(_923).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _961
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2957 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3033 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3033
                                    require ext_code.size(address(_2957))
                                    call address(_2957).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3033
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _645 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _673 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _673
                                require ext_code.size(address(_645))
                                call address(_645).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _673
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2295 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2409 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2409
                                require ext_code.size(address(_2295))
                                call address(_2295).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2409
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _651 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _677 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _677
                                    require ext_code.size(address(_651))
                                    call address(_651).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _677
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2301 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2415 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2415
                                    require ext_code.size(address(_2301))
                                    call address(_2301).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2415
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _931 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _971 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _971
                                    require ext_code.size(address(_931))
                                    call address(_931).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _971
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2961 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3035 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3035
                                    require ext_code.size(address(_2961))
                                    call address(_2961).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3035
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
        else:
            mem[(32 * stor5[arg1].field_512) + 448] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 3)].field_0
            idx = (32 * stor5[arg1].field_512) + 448
            s = 0
            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 416 > idx:
                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 3)].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[192] = (32 * stor5[arg1].field_512) + 416
            mem[224] = stor5[arg1].field_1024
            mem[256] = stor5[arg1].field_1280
            mem[288] = stor5[arg1].field_1536
            mem[320] = address(stor5[arg1].field_1792)
            if bool(stor5[arg1].field_2048):
                if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = uint255(stor5[arg1].field_2048) * 0.5
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2305 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2417 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2417
                                require ext_code.size(address(_2305))
                                call address(_2305).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2417
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3879 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _3999 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3999
                                require ext_code.size(address(_3879))
                                call address(_3879).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _3999
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2311 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2421 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2421
                                    require ext_code.size(address(_2311))
                                    call address(_2311).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2421
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3885 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4005 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4005
                                    require ext_code.size(address(_3885))
                                    call address(_3885).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4005
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2967 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3041 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3041
                                    require ext_code.size(address(_2967))
                                    call address(_2967).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3041
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4383 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4447 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4447
                                    require ext_code.size(address(_4383))
                                    call address(_4383).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4447
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2315 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2423 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2423
                                require ext_code.size(address(_2315))
                                call address(_2315).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2423
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3889 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4007 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4007
                                require ext_code.size(address(_3889))
                                call address(_3889).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4007
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2321 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2427 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2427
                                    require ext_code.size(address(_2321))
                                    call address(_2321).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2427
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3895 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4013 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4013
                                    require ext_code.size(address(_3895))
                                    call address(_3895).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4013
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2975 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3051 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3051
                                    require ext_code.size(address(_2975))
                                    call address(_2975).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3051
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4387 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4449 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4449
                                    require ext_code.size(address(_4387))
                                    call address(_4387).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4449
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = stor5[arg1].field_2049 % 128
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2325 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2429 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2429
                                require ext_code.size(address(_2325))
                                call address(_2325).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2429
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3899 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4015 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4015
                                require ext_code.size(address(_3899))
                                call address(_3899).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4015
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2331 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2433 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2433
                                    require ext_code.size(address(_2331))
                                    call address(_2331).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2433
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3905 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4021 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4021
                                    require ext_code.size(address(_3905))
                                    call address(_3905).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4021
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2983 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3061 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3061
                                    require ext_code.size(address(_2983))
                                    call address(_2983).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3061
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4391 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4451 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4451
                                    require ext_code.size(address(_4391))
                                    call address(_4391).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4451
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2335 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2435 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2435
                                require ext_code.size(address(_2335))
                                call address(_2335).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2435
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3909 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4023 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4023
                                require ext_code.size(address(_3909))
                                call address(_3909).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4023
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2341 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2439 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2439
                                    require ext_code.size(address(_2341))
                                    call address(_2341).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2439
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3915 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4029 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4029
                                    require ext_code.size(address(_3915))
                                    call address(_3915).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4029
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2991 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3071 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3071
                                    require ext_code.size(address(_2991))
                                    call address(_2991).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3071
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4395 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4453 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4453
                                    require ext_code.size(address(_4395))
                                    call address(_4395).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4453
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
    else:
        mem[416] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 2)].field_0
        idx = 416
        s = 0
        while (32 * stor5[arg1].field_512) + 384 > idx:
            mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 2)].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[160] = 384
        mem[(32 * stor5[arg1].field_512) + 416] = stor5[arg1].field_768
        if not stor5[arg1].field_768:
            mem[192] = (32 * stor5[arg1].field_512) + 416
            mem[224] = stor5[arg1].field_1024
            mem[256] = stor5[arg1].field_1280
            mem[288] = stor5[arg1].field_1536
            mem[320] = address(stor5[arg1].field_1792)
            if bool(stor5[arg1].field_2048):
                if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = uint255(stor5[arg1].field_2048) * 0.5
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2345 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2441 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2441
                                require ext_code.size(address(_2345))
                                call address(_2345).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2441
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3919 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4031 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4031
                                require ext_code.size(address(_3919))
                                call address(_3919).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4031
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2351 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2445 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2445
                                    require ext_code.size(address(_2351))
                                    call address(_2351).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2445
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3925 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4037 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4037
                                    require ext_code.size(address(_3925))
                                    call address(_3925).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4037
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2999 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3081 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3081
                                    require ext_code.size(address(_2999))
                                    call address(_2999).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3081
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4399 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4455 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4455
                                    require ext_code.size(address(_4399))
                                    call address(_4399).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4455
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2355 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2447 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2447
                                require ext_code.size(address(_2355))
                                call address(_2355).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2447
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3929 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4039 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4039
                                require ext_code.size(address(_3929))
                                call address(_3929).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4039
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2361 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2451 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _2451
                                    require ext_code.size(address(_2361))
                                    call address(_2361).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2451
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3935 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4045 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4045
                                    require ext_code.size(address(_3935))
                                    call address(_3935).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4045
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3007 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3091 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _3091
                                    require ext_code.size(address(_3007))
                                    call address(_3007).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3091
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4403 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4457 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4457
                                    require ext_code.size(address(_4403))
                                    call address(_4403).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4457
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = stor5[arg1].field_2049 % 128
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2365 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2453 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2453
                                require ext_code.size(address(_2365))
                                call address(_2365).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2453
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3939 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4047 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4047
                                require ext_code.size(address(_3939))
                                call address(_3939).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4047
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2371 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2457 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2457
                                    require ext_code.size(address(_2371))
                                    call address(_2371).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2457
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3945 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4053 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4053
                                    require ext_code.size(address(_3945))
                                    call address(_3945).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4053
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3015 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3101 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3101
                                    require ext_code.size(address(_3015))
                                    call address(_3015).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3101
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4407 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4459 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4459
                                    require ext_code.size(address(_4407))
                                    call address(_4407).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4459
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _2375 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _2459 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2459
                                require ext_code.size(address(_2375))
                                call address(_2375).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _2459
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3949 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4055 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4055
                                require ext_code.size(address(_3949))
                                call address(_3949).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4055
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _2381 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _2463 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _2463
                                    require ext_code.size(address(_2381))
                                    call address(_2381).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _2463
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3955 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4061 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4061
                                    require ext_code.size(address(_3955))
                                    call address(_3955).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4061
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3023 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _3111 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _3111
                                    require ext_code.size(address(_3023))
                                    call address(_3023).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _3111
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4411 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4461 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4461
                                    require ext_code.size(address(_4411))
                                    call address(_4411).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4461
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
        else:
            mem[(32 * stor5[arg1].field_512) + 448] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 3)].field_0
            idx = (32 * stor5[arg1].field_512) + 448
            s = 0
            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 416 > idx:
                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 3)].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[192] = (32 * stor5[arg1].field_512) + 416
            mem[224] = stor5[arg1].field_1024
            mem[256] = stor5[arg1].field_1280
            mem[288] = stor5[arg1].field_1536
            mem[320] = address(stor5[arg1].field_1792)
            if bool(stor5[arg1].field_2048):
                if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = uint255(stor5[arg1].field_2048) * 0.5
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3959 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4063 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4063
                                require ext_code.size(address(_3959))
                                call address(_3959).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4063
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _4587 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4627 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4627
                                require ext_code.size(address(_4587))
                                call address(_4587).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4627
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3965 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4067 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4067
                                    require ext_code.size(address(_3965))
                                    call address(_3965).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4067
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4593 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4633 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4633
                                    require ext_code.size(address(_4593))
                                    call address(_4593).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4633
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4417 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4467 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4467
                                    require ext_code.size(address(_4417))
                                    call address(_4417).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4467
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4695 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4711 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4711
                                    require ext_code.size(address(_4695))
                                    call address(_4695).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4711
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3969 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4069 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4069
                                require ext_code.size(address(_3969))
                                call address(_3969).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4069
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _4597 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4635 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4635
                                require ext_code.size(address(_4597))
                                call address(_4597).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4635
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3975 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4073 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4073
                                    require ext_code.size(address(_3975))
                                    call address(_3975).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4073
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4603 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4641 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4641
                                    require ext_code.size(address(_4603))
                                    call address(_4603).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4641
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4425 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4477 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4477
                                    require ext_code.size(address(_4425))
                                    call address(_4425).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4477
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4699 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4713 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(uint255(stor5[arg1].field_2048) * 0.5) + (32 * supportedTokens.length) + 580] = _4713
                                    require ext_code.size(address(_4699))
                                    call address(_4699).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4713
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                    revert with 0, 34
                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448] = stor5[arg1].field_2049 % 128
                if bool(stor5[arg1].field_2048):
                    if bool(stor5[arg1].field_2048) == uint255(stor5[arg1].field_2048) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor5[arg1].field_2048):
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3979 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4075 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4075
                                require ext_code.size(address(_3979))
                                call address(_3979).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4075
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _4607 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4643 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4643
                                require ext_code.size(address(_4607))
                                call address(_4607).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4643
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= uint255(stor5[arg1].field_2048) * 0.5:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3985 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4079 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4079
                                    require ext_code.size(address(_3985))
                                    call address(_3985).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4079
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4613 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4649 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4649
                                    require ext_code.size(address(_4613))
                                    call address(_4613).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4649
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + (uint255(stor5[arg1].field_2048) * 0.5) + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4433 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4487 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4487
                                    require ext_code.size(address(_4433))
                                    call address(_4433).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4487
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4703 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4715 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4715
                                    require ext_code.size(address(_4703))
                                    call address(_4703).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4715
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(stor5[arg1].field_2048) == stor5[arg1].field_2049 % 128 < 32:
                        revert with 0, 34
                    if not stor5[arg1].field_2049 % 128:
                        mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                        if not uint8(stor5[arg1].field_0):
                            revert with 0, 'Collection no longer active'
                        if address(stor5[arg1].field_1792) != msg.sender:
                            revert with 0, 'Invalid Owner'
                        if not sub_4432e12b.length:
                            revert with 0, 'There are no active collections'
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 'Incorrect index'
                        if sub_4432e12b.length < 1:
                            revert with 0, 17
                        if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                            revert with 0, 50
                        if stor5[arg1].field_1280 >= sub_4432e12b.length:
                            revert with 0, 50
                        sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                        if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                            revert with 0, 50
                        stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                        if not sub_4432e12b.length:
                            revert with 0, 49
                        sub_4432e12b[sub_4432e12b.length] = 0
                        sub_4432e12b.length--
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 'There are no active collections for this user.'
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 'Incorrect index'
                        if sub_20df060c[address(msg.sender)] < 1:
                            revert with 0, 17
                        if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                        if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                            revert with 0, 50
                        if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                            revert with 0, 50
                        stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                        mem[32] = 7
                        if not sub_20df060c[address(msg.sender)]:
                            revert with 0, 49
                        sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                        sub_20df060c[address(msg.sender)]--
                        if arg1 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        uint8(stor5[arg1].field_0) = 0
                        mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                        mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                        if not supportedTokens.length:
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _3989 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4081 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4081
                                require ext_code.size(address(_3989))
                                call address(_3989).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4081
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            mem[0] = 3
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                mem[idx + 32] = address(supportedTokens[s].field_256)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            while idx < stor5[arg1].field_512:
                                if idx >= stor5[arg1].field_768:
                                    revert with 0, 50
                                if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                    revert with 0, 50
                                _4617 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                if idx >= stor5[arg1].field_512:
                                    revert with 0, 50
                                _4651 = mem[(32 * idx) + 416]
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4651
                                require ext_code.size(address(_4617))
                                call address(_4617).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                     gas gas_remaining wei
                                    args address(this.address), address(stor5[arg1].field_1792), _4651
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if 31 >= stor5[arg1].field_2049 % 128:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = 256 * Mask(248, 0, stor5[arg1].field_2056)
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _3995 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4085 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4085
                                    require ext_code.size(address(_3995))
                                    call address(_3995).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4085
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4623 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4657 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4657
                                    require ext_code.size(address(_4623))
                                    call address(_4623).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4657
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                        else:
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480] = stor[sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_0
                            idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 480
                            s = 0
                            while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + stor5[arg1].field_2049 % 128 + 448 > idx:
                                mem[idx + 32] = stor[s + sha3(('name', 'stor5', 5) + (9 * arg1) + 8)].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[352] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + 448
                            if not uint8(stor5[arg1].field_0):
                                revert with 0, 'Collection no longer active'
                            if address(stor5[arg1].field_1792) != msg.sender:
                                revert with 0, 'Invalid Owner'
                            if not sub_4432e12b.length:
                                revert with 0, 'There are no active collections'
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 'Incorrect index'
                            if sub_4432e12b.length < 1:
                                revert with 0, 17
                            if sub_4432e12b.length - 1 >= sub_4432e12b.length:
                                revert with 0, 50
                            if stor5[arg1].field_1280 >= sub_4432e12b.length:
                                revert with 0, 50
                            sub_4432e12b[stor5[arg1].field_1280] = sub_4432e12b[sub_4432e12b.length]
                            if sub_4432e12b[stor5[arg1].field_1280] >= stor5.length:
                                revert with 0, 50
                            stor5[stor6[stor5[arg1].field_1280]].field_1280 = stor5[arg1].field_1280
                            if not sub_4432e12b.length:
                                revert with 0, 49
                            sub_4432e12b[sub_4432e12b.length] = 0
                            sub_4432e12b.length--
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 'There are no active collections for this user.'
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 'Incorrect index'
                            if sub_20df060c[address(msg.sender)] < 1:
                                revert with 0, 17
                            if sub_20df060c[address(msg.sender)] - 1 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] = sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]]
                            if stor5[arg1].field_1536 >= sub_20df060c[address(msg.sender)]:
                                revert with 0, 50
                            if sub_20df060c[address(msg.sender)][stor5[arg1].field_1536] >= stor5.length:
                                revert with 0, 50
                            stor5[stor7[address(msg.sender)][stor5[arg1].field_1536]].field_1536 = stor5[arg1].field_1536
                            mem[32] = 7
                            if not sub_20df060c[address(msg.sender)]:
                                revert with 0, 49
                            sub_20df060c[address(msg.sender)][sub_20df060c[address(msg.sender)]] = 0
                            sub_20df060c[address(msg.sender)]--
                            if arg1 >= stor5.length:
                                revert with 0, 50
                            mem[0] = 5
                            uint8(stor5[arg1].field_0) = 0
                            mem[64] = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512
                            mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 480] = supportedTokens.length
                            if not supportedTokens.length:
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4441 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4497 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4497
                                    require ext_code.size(address(_4441))
                                    call address(_4441).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4497
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = 3
                                mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512] = address(supportedTokens.field_0)
                                idx = (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512
                                s = 0
                                while (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 480 > idx:
                                    mem[idx + 32] = address(supportedTokens[s].field_256)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                while idx < stor5[arg1].field_512:
                                    if idx >= stor5[arg1].field_768:
                                        revert with 0, 50
                                    if mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448] >= supportedTokens.length:
                                        revert with 0, 50
                                    _4707 = mem[(32 * mem[(32 * idx) + (32 * stor5[arg1].field_512) + 448]) + (32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + 512]
                                    if idx >= stor5[arg1].field_512:
                                        revert with 0, 50
                                    _4717 = mem[(32 * idx) + 416]
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 512] = 0x23b872dd00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 516] = this.address
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 548] = address(stor5[arg1].field_1792)
                                    mem[(32 * stor5[arg1].field_512) + (32 * stor5[arg1].field_768) + ceil32(stor5[arg1].field_2049 % 128) + (32 * supportedTokens.length) + 580] = _4717
                                    require ext_code.size(address(_4707))
                                    call address(_4707).transferFrom(address arg1, address arg2, uint256 arg3) with:
                                         gas gas_remaining wei
                                        args address(this.address), address(stor5[arg1].field_1792), _4717
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
}



}

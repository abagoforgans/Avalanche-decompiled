contract main {




// =====================  Runtime code  =====================


#
#  - sub_2c2f24da(?)
#
const name = 'EverStake', 0

const decimals = 18

const symbol = 'EVERSTAKE', 0

const PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9


address owner;
array of struct stor3;
mapping of uint256 stor5;
mapping of uint256 stor6;
mapping of uint256 allowance;
mapping of uint8 stor8;
uint8 stor9;
uint8 stor9; offset 8
address stor9;
address stor9; offset 16
uint256 stor9; offset 8
mapping of uint8 stor11;
array of address stor12;
uint256 totalAmountStaked;
uint256 totalRewardsDistributed;
uint256 totalSupply;
uint256 stor16;
uint256 DOMAIN_SEPARATOR;
mapping of uint256 nonces;

function totalSupply() payable {
    return totalSupply
}

function getTotalAmountStaked() payable {
    return totalAmountStaked
}

function DOMAIN_SEPARATOR() payable {
    return DOMAIN_SEPARATOR
}

function nonces(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return nonces[arg1]
}

function isExcludedFromReward(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor11[address(arg1)])
}

function owner() payable {
    return owner
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function getTotalRewardsDistributed() payable {
    return totalRewardsDistributed
}

function _fallback() payable {
    revert
}

function sub_4dc95ec8(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    uint8(stor9.field_0) = uint8(bool(arg1))
}

function sub_086e47d5(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor9.field_8) = Mask(248, 0, bool(arg1))
}

function sub_ec70b5cc(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(stor9.field_16) = address(arg1)
    stor8[address(arg1)] = 1
}

function getCurrentBalance(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(arg1)
    staticcall arg1.getCurrentBalance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_f128b0c1(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call address(arg1) with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_7bb5ce37(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).getDepositorAddress() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, code.data[20438 len 37], mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function sub_9d3d3aae(?) payable {
    mem[64] = (32 * stor3[msg.sender].field_0) + 128
    mem[96] = stor3[msg.sender].field_0
    if not stor3[msg.sender].field_0:
        mem[(32 * stor3[msg.sender].field_0) + 128] = 32
        mem[(32 * stor3[msg.sender].field_0) + 160] = stor3[msg.sender].field_0
        idx = 0
        s = (32 * stor3[msg.sender].field_0) + 192
        t = 128
        while idx < stor3[msg.sender].field_0:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * stor3[msg.sender].field_0) + 128
           len (96 * stor3[msg.sender].field_0) + 64
    mem[128] = stor3[msg.sender].field_0
    idx = 128
    s = 0
    while (32 * stor3[msg.sender].field_0) + 96 > idx:
        mem[idx + 32] = stor3[msg.sender][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * stor3[msg.sender].field_0) + 128] = 32
    mem[(32 * stor3[msg.sender].field_0) + 160] = stor3[msg.sender].field_0
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < stor3[msg.sender].field_0:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * stor3[msg.sender].field_0) + -mem[64] + 192
}

function sub_171c1fda(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Token Address can not be a zero address'
    if not address(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'To Address can not be a zero address'
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'Balance is zero'
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(arg1))
    call address(arg1).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg2), ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_c943cc39(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if not address(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The new address can not be zero address'
    if msg.sender == address(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Alternative owner can not be the same owner'
    require ext_code.size(address(arg1))
    staticcall address(arg1).getDepositorAddress() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'Depositor on this contract is not the same as caller'
    require ext_code.size(address(arg1))
    call address(arg1).0xbfe26280 with:
         gas gas_remaining wei
        args address(arg2)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor3[address(arg2)].field_0++
    stor3[address(arg2)][stor3[address(arg2)].field_0].field_0 = address(arg1)
    if not stor3[address(arg2)].field_0:
        idx = 0
        while stor3[address(arg2)].field_0 > idx:
            stor3[address(arg2)][idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 0
        while stor3[address(arg2)].field_0 > idx:
            stor3[address(arg2)][s].field_0 = stor3[address(arg2)][idx].field_0
            s = s + 1
            idx = idx + 1
            continue 
        idx = stor3[address(arg2)].field_0
        while stor3[address(arg2)].field_0 > idx:
            stor3[address(arg2)][idx].field_0 = 0
            idx = idx + 1
            continue 
}

function _getCurrentSupply() payable {
    mem[64] = 96
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        if stor5[stor12[idx]] > t:
            return stor16, totalSupply
        if idx >= stor12.length:
            revert with 0, 50
        if stor6[stor12[idx]] > s:
            return stor16, totalSupply
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 5
        _48 = mem[64]
        mem[64] = mem[64] + 64
        mem[_48] = 30
        mem[_48 + 32] = 'SafeMath: subtraction overflow'
        if stor5[stor12[idx]] > t:
            _50 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _50 + 68] = mem[_48 + idx + 32]
                idx = idx + 32
                continue 
            mem[_50 + 98] = 0
            revert with memory
              from mem[64]
               len _50 + -mem[64] + 100
        if t < stor5[stor12[idx]]:
            revert with 0, 17
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        _61 = mem[64]
        mem[64] = mem[64] + 64
        mem[_61] = 30
        mem[_61 + 32] = 'SafeMath: subtraction overflow'
        if stor6[stor12[idx]] <= s:
            if s < stor6[stor12[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor6[stor12[idx]]
            t = t - stor5[stor12[idx]]
            continue 
        _64 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _64 + 68] = mem[_61 + idx + 32]
            idx = idx + 32
            continue 
        mem[_64 + 98] = 0
        revert with memory
          from mem[64]
           len _64 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        return t, s
    return stor16, totalSupply
}

function getWeightedGeometricMean(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).getDepositorAddress() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x910afbe9 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, 'Depositor on this contract is not the same as caller'
    require ext_code.size(this.address)
    staticcall this.address.0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'Balance should be greater than zero'
    require ext_code.size(address(arg1))
    call address(arg1).0xe6ffda80 with:
         gas gas_remaining wei
        args bool(uint8(stor9.field_8))
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if ext_call.return_data[0]:
        if ext_call.return_data[0] > !ext_call.return_data[32]:
            revert with 0, 17
        if ext_call.return_data[0] + ext_call.return_data[32] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        require ext_code.size(address(stor9.field_16))
        call address(stor9.field_16).0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ext_call.return_data[0] + ext_call.return_data[32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if ext_call.return_data[0] > totalAmountStaked:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if totalAmountStaked < ext_call.return_data[0]:
            revert with 0, 17
        totalAmountStaked -= ext_call.return_data[0]
}

function withDraw(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require ext_code.size(arg1)
    staticcall arg1.getDepositorAddress() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        require ext_code.size(arg1)
        staticcall arg1.0x910afbe9 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, 'Depositor on this contract is not the same as caller'
    if arg2 <= 0:
        revert with 0, 'Amount should be greater than zero'
    require ext_code.size(arg1)
    staticcall arg1.0x56fe8cf7 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(arg1)
    if ext_call.return_data[0] >= arg2:
        call arg1.0xea57e767 with:
             gas gas_remaining wei
            args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            require ext_code.size(address(stor9.field_16))
            call address(stor9.field_16).0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
    else:
        call arg1.0x6666c862 with:
             gas gas_remaining wei
            args arg2, bool(uint8(stor9.field_0))
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        if ext_call.return_data[0]:
            if ext_call.return_data[0] > !ext_call.return_data[64]:
                revert with 0, 17
            if ext_call.return_data[0] + ext_call.return_data[64] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            require ext_code.size(address(stor9.field_16))
            call address(stor9.field_16).0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ext_call.return_data[0] + ext_call.return_data[64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if ext_call.return_data[0] > totalAmountStaked:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if totalAmountStaked < ext_call.return_data[0]:
                revert with 0, 17
            if ext_call.return_data[32] > totalAmountStaked - ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if totalAmountStaked - ext_call.return_data[0] < ext_call.return_data[32]:
                revert with 0, 17
            totalAmountStaked = totalAmountStaked - ext_call.return_data[0] - ext_call.return_data[32]
}

function _getRate() payable {
    mem[64] = 96
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _66 = mem[64]
            mem[64] = mem[64] + 64
            mem[_66] = 26
            mem[_66 + 32] = 'SafeMath: division by zero'
            if totalSupply:
                return (stor16 / totalSupply)
            _70 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _70 + 68] = mem[_66 + idx + 32]
                idx = idx + 32
                continue 
            mem[_70 + 94] = 0
            revert with memory
              from mem[64]
               len _70 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        if stor6[stor12[idx]] > s:
            _72 = mem[64]
            mem[64] = mem[64] + 64
            mem[_72] = 26
            mem[_72 + 32] = 'SafeMath: division by zero'
            if totalSupply:
                return (stor16 / totalSupply)
            _75 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _75 + 68] = mem[_72 + idx + 32]
                idx = idx + 32
                continue 
            mem[_75 + 94] = 0
            revert with memory
              from mem[64]
               len _75 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 5
        _71 = mem[64]
        mem[64] = mem[64] + 64
        mem[_71] = 30
        mem[_71 + 32] = 'SafeMath: subtraction overflow'
        if stor5[stor12[idx]] > t:
            _74 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _74 + 68] = mem[_71 + idx + 32]
                idx = idx + 32
                continue 
            mem[_74 + 98] = 0
            revert with memory
              from mem[64]
               len _74 + -mem[64] + 100
        if t < stor5[stor12[idx]]:
            revert with 0, 17
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor6[stor12[idx]] <= s:
            if s < stor6[stor12[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor6[stor12[idx]]
            t = t - stor5[stor12[idx]]
            continue 
        _104 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _104 + 68] = mem[_96 + idx + 32]
            idx = idx + 32
            continue 
        mem[_104 + 98] = 0
        revert with memory
          from mem[64]
           len _104 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        return (t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor16 / totalSupply)
}

function reflectionFromToken(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _84 = mem[64]
            mem[64] = mem[64] + 64
            mem[_84] = 26
            mem[_84 + 32] = 'SafeMath: division by zero'
            if totalSupply:
                if not arg1:
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                return (arg1 * stor16 / totalSupply)
            _88 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _88 + 68] = mem[_84 + idx + 32]
                idx = idx + 32
                continue 
            mem[_88 + 94] = 0
            revert with memory
              from mem[64]
               len _88 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        if stor6[stor12[idx]] > s:
            _90 = mem[64]
            mem[64] = mem[64] + 64
            mem[_90] = 26
            mem[_90 + 32] = 'SafeMath: division by zero'
            if totalSupply:
                if not arg1:
                    return 0
                if arg1 and stor16 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                return (arg1 * stor16 / totalSupply)
            _93 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _93 + 68] = mem[_90 + idx + 32]
                idx = idx + 32
                continue 
            mem[_93 + 94] = 0
            revert with memory
              from mem[64]
               len _93 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 5
        _89 = mem[64]
        mem[64] = mem[64] + 64
        mem[_89] = 30
        mem[_89 + 32] = 'SafeMath: subtraction overflow'
        if stor5[stor12[idx]] > t:
            _92 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _92 + 68] = mem[_89 + idx + 32]
                idx = idx + 32
                continue 
            mem[_92 + 98] = 0
            revert with memory
              from mem[64]
               len _92 + -mem[64] + 100
        if t < stor5[stor12[idx]]:
            revert with 0, 17
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        _111 = mem[64]
        mem[64] = mem[64] + 64
        mem[_111] = 30
        mem[_111 + 32] = 'SafeMath: subtraction overflow'
        if stor6[stor12[idx]] <= s:
            if s < stor6[stor12[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor6[stor12[idx]]
            t = t - stor5[stor12[idx]]
            continue 
        _119 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _119 + 68] = mem[_111 + idx + 32]
            idx = idx + 32
            continue 
        mem[_119 + 98] = 0
        revert with memory
          from mem[64]
           len _119 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            return 0
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        return (arg1 * t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not arg1:
        return 0
    if arg1 and stor16 / totalSupply > -1 / arg1:
        revert with 0, 17
    if not arg1:
        revert with 0, 18
    if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
        revert with 0, 'SafeMath: multiplication overflow'
    return (arg1 * stor16 / totalSupply)
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor16:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[_92 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _113 = mem[64]
            mem[64] = mem[64] + 64
            mem[_113] = 26
            mem[_113 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (arg1 / stor16 / totalSupply)
            _120 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _120 + 68] = mem[_113 + idx + 32]
                idx = idx + 32
                continue 
            mem[_120 + 94] = 0
            revert with memory
              from mem[64]
               len _120 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        if stor6[stor12[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[_98 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _123 = mem[64]
            mem[64] = mem[64] + 64
            mem[_123] = 26
            mem[_123 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (arg1 / stor16 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[_123 + idx + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 5
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor5[stor12[idx]] > t:
            _100 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _100 + 68] = mem[_97 + idx + 32]
                idx = idx + 32
                continue 
            mem[_100 + 98] = 0
            revert with memory
              from mem[64]
               len _100 + -mem[64] + 100
        if t < stor5[stor12[idx]]:
            revert with 0, 17
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        _121 = mem[64]
        mem[64] = mem[64] + 64
        mem[_121] = 30
        mem[_121 + 32] = 'SafeMath: subtraction overflow'
        if stor6[stor12[idx]] <= s:
            if s < stor6[stor12[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor6[stor12[idx]]
            t = t - stor5[stor12[idx]]
            continue 
        _130 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _130 + 68] = mem[_121 + idx + 32]
            idx = idx + 32
            continue 
        mem[_130 + 98] = 0
        revert with memory
          from mem[64]
           len _130 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor16 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor16 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor11[address(arg1)]:
        return stor6[address(arg1)]
    mem[0] = arg1
    mem[32] = 5
    if stor5[address(arg1)] > stor16:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[_97 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _118 = mem[64]
            mem[64] = mem[64] + 64
            mem[_118] = 26
            mem[_118 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (stor5[address(arg1)] / stor16 / totalSupply)
            _125 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _125 + 68] = mem[_118 + idx + 32]
                idx = idx + 32
                continue 
            mem[_125 + 94] = 0
            revert with memory
              from mem[64]
               len _125 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        if stor6[stor12[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _106 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _106 + 68] = mem[_103 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_106 + 94] = 0
                revert with memory
                  from mem[64]
                   len _106 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor16 / totalSupply:
                return (stor5[address(arg1)] / stor16 / totalSupply)
            _136 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _136 + 68] = mem[_128 + idx + 32]
                idx = idx + 32
                continue 
            mem[_136 + 94] = 0
            revert with memory
              from mem[64]
               len _136 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 5
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor5[stor12[idx]] > t:
            _105 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _105 + 68] = mem[_102 + idx + 32]
                idx = idx + 32
                continue 
            mem[_105 + 98] = 0
            revert with memory
              from mem[64]
               len _105 + -mem[64] + 100
        if t < stor5[stor12[idx]]:
            revert with 0, 17
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        _126 = mem[64]
        mem[64] = mem[64] + 64
        mem[_126] = 30
        mem[_126 + 32] = 'SafeMath: subtraction overflow'
        if stor6[stor12[idx]] <= s:
            if s < stor6[stor12[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor6[stor12[idx]]
            t = t - stor5[stor12[idx]]
            continue 
        _135 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _135 + 68] = mem[_126 + idx + 32]
            idx = idx + 32
            continue 
        mem[_135 + 98] = 0
        revert with memory
          from mem[64]
           len _135 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor5[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor16 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor5[address(arg1)] / stor16 / totalSupply)
}

function excludeFromReward(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor11[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor5[address(arg1)]:
        mem[0] = arg1
        mem[32] = 5
        if stor5[address(arg1)] > stor16:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor16
        while idx < stor12.length:
            mem[0] = stor12[idx]
            mem[32] = 5
            if stor5[stor12[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[_100 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _121 = mem[64]
                mem[64] = mem[64] + 64
                mem[_121] = 26
                mem[_121 + 32] = 'SafeMath: division by zero'
                if stor16 / totalSupply:
                    stor6[address(arg1)] = stor5[address(arg1)] / stor16 / totalSupply
                    stor11[address(arg1)] = 1
                    stor12.length++
                    stor12[stor12.length] = arg1
                _128 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _128 + 68] = mem[_121 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_128 + 94] = 0
                revert with memory
                  from mem[64]
                   len _128 + -mem[64] + 100
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 6
            if stor6[stor12[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _109 + 68] = mem[_106 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_109 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _109 + -mem[64] + 100
                _131 = mem[64]
                mem[64] = mem[64] + 64
                mem[_131] = 26
                mem[_131 + 32] = 'SafeMath: division by zero'
                if stor16 / totalSupply:
                    stor6[address(arg1)] = stor5[address(arg1)] / stor16 / totalSupply
                    stor11[address(arg1)] = 1
                    stor12.length++
                    stor12[stor12.length] = arg1
                _139 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _139 + 68] = mem[_131 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_139 + 94] = 0
                revert with memory
                  from mem[64]
                   len _139 + -mem[64] + 100
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 5
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor5[stor12[idx]] > t:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _108 + 68] = mem[_105 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 98] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            if t < stor5[stor12[idx]]:
                revert with 0, 17
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 6
            _129 = mem[64]
            mem[64] = mem[64] + 64
            mem[_129] = 30
            mem[_129 + 32] = 'SafeMath: subtraction overflow'
            if stor6[stor12[idx]] <= s:
                if s < stor6[stor12[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor6[stor12[idx]]
                t = t - stor5[stor12[idx]]
                continue 
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _138 + 68] = mem[_129 + idx + 32]
                idx = idx + 32
                continue 
            mem[_138 + 98] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor16 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor6[address(arg1)] = stor5[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor16 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor6[address(arg1)] = stor5[address(arg1)] / stor16 / totalSupply
    stor11[address(arg1)] = 1
    stor12.length++
    stor12[stor12.length] = arg1
}

function deliver(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 11
    if stor11[msg.sender]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Excluded addresses cannot call this function'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _197 = mem[64]
            mem[64] = mem[64] + 64
            mem[_197] = 26
            mem[_197 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _201 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _201 + 68] = mem[_197 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_201 + 94] = 0
                revert with memory
                  from mem[64]
                   len _201 + -mem[64] + 100
            if not arg1:
                mem[0] = msg.sender
                mem[32] = 5
                _232 = mem[64]
                mem[64] = mem[64] + 64
                mem[_232] = 30
                mem[_232 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor5[address(msg.sender)]:
                    _237 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _237 + 68] = mem[_232 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_237 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _237 + -mem[64] + 100
                if stor5[address(msg.sender)] < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 5
                _263 = mem[64]
                mem[64] = mem[64] + 64
                mem[_263] = 30
                mem[_263 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor16:
                    if stor16 < 0:
                        revert with 0, 17
                    if totalRewardsDistributed > !arg1:
                        revert with 0, 17
                    if totalRewardsDistributed + arg1 < totalRewardsDistributed:
                        revert with 0, 'SafeMath: addition overflow'
                    totalRewardsDistributed += arg1
                _274 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _274 + 68] = mem[_263 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_274 + 98] = 0
                revert with memory
                  from mem[64]
                   len _274 + -mem[64] + 100
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[0] = msg.sender
            mem[32] = 5
            _252 = mem[64]
            mem[64] = mem[64] + 64
            mem[_252] = 30
            mem[_252 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor16 / totalSupply > stor5[address(msg.sender)]:
                _262 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _262 + 68] = mem[_252 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_262 + 98] = 0
                revert with memory
                  from mem[64]
                   len _262 + -mem[64] + 100
            if stor5[address(msg.sender)] < arg1 * stor16 / totalSupply:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 5
            stor5[address(msg.sender)] += -1 * arg1 * stor16 / totalSupply
            _299 = mem[64]
            mem[64] = mem[64] + 64
            mem[_299] = 30
            mem[_299 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor16 / totalSupply <= stor16:
                if stor16 < arg1 * stor16 / totalSupply:
                    revert with 0, 17
                stor16 += -1 * arg1 * stor16 / totalSupply
                if totalRewardsDistributed > !arg1:
                    revert with 0, 17
                if totalRewardsDistributed + arg1 < totalRewardsDistributed:
                    revert with 0, 'SafeMath: addition overflow'
                totalRewardsDistributed += arg1
            _313 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _313 + 68] = mem[_299 + idx + 32]
                idx = idx + 32
                continue 
            mem[_313 + 98] = 0
            revert with memory
              from mem[64]
               len _313 + -mem[64] + 100
        if idx >= stor12.length:
            revert with 0, 50
        mem[0] = stor12[idx]
        mem[32] = 6
        if stor6[stor12[idx]] <= s:
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 5
            _202 = mem[64]
            mem[64] = mem[64] + 64
            mem[_202] = 30
            mem[_202 + 32] = 'SafeMath: subtraction overflow'
            if stor5[stor12[idx]] > t:
                _205 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _205 + 68] = mem[_202 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_205 + 98] = 0
                revert with memory
                  from mem[64]
                   len _205 + -mem[64] + 100
            if t < stor5[stor12[idx]]:
                revert with 0, 17
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 6
            _224 = mem[64]
            mem[64] = mem[64] + 64
            mem[_224] = 30
            mem[_224 + 32] = 'SafeMath: subtraction overflow'
            if stor6[stor12[idx]] <= s:
                if s < stor6[stor12[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor6[stor12[idx]]
                t = t - stor5[stor12[idx]]
                continue 
            _233 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _233 + 68] = mem[_224 + idx + 32]
                idx = idx + 32
                continue 
            mem[_233 + 98] = 0
            revert with memory
              from mem[64]
               len _233 + -mem[64] + 100
        _203 = mem[64]
        mem[64] = mem[64] + 64
        mem[_203] = 26
        mem[_203 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            _206 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _206 + 68] = mem[_203 + idx + 32]
                idx = idx + 32
                continue 
            mem[_206 + 94] = 0
            revert with memory
              from mem[64]
               len _206 + -mem[64] + 100
        if not arg1:
            mem[0] = msg.sender
            mem[32] = 5
            _239 = mem[64]
            mem[64] = mem[64] + 64
            mem[_239] = 30
            mem[_239 + 32] = 'SafeMath: subtraction overflow'
            if 0 > stor5[address(msg.sender)]:
                _245 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _245 + 68] = mem[_239 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_245 + 98] = 0
                revert with memory
                  from mem[64]
                   len _245 + -mem[64] + 100
            if stor5[address(msg.sender)] < 0:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 5
            _277 = mem[64]
            mem[64] = mem[64] + 64
            mem[_277] = 30
            mem[_277 + 32] = 'SafeMath: subtraction overflow'
            if 0 <= stor16:
                if stor16 < 0:
                    revert with 0, 17
                if totalRewardsDistributed > !arg1:
                    revert with 0, 17
                if totalRewardsDistributed + arg1 < totalRewardsDistributed:
                    revert with 0, 'SafeMath: addition overflow'
                totalRewardsDistributed += arg1
            _290 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _290 + 68] = mem[_277 + idx + 32]
                idx = idx + 32
                continue 
            mem[_290 + 98] = 0
            revert with memory
              from mem[64]
               len _290 + -mem[64] + 100
        if arg1 and stor16 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[0] = msg.sender
        mem[32] = 5
        _265 = mem[64]
        mem[64] = mem[64] + 64
        mem[_265] = 30
        mem[_265 + 32] = 'SafeMath: subtraction overflow'
        if arg1 * stor16 / totalSupply > stor5[address(msg.sender)]:
            _276 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _276 + 68] = mem[_265 + idx + 32]
                idx = idx + 32
                continue 
            mem[_276 + 98] = 0
            revert with memory
              from mem[64]
               len _276 + -mem[64] + 100
        if stor5[address(msg.sender)] < arg1 * stor16 / totalSupply:
            revert with 0, 17
        mem[0] = msg.sender
        mem[32] = 5
        stor5[address(msg.sender)] += -1 * arg1 * stor16 / totalSupply
        _315 = mem[64]
        mem[64] = mem[64] + 64
        mem[_315] = 30
        mem[_315 + 32] = 'SafeMath: subtraction overflow'
        if arg1 * stor16 / totalSupply <= stor16:
            if stor16 < arg1 * stor16 / totalSupply:
                revert with 0, 17
            stor16 += -1 * arg1 * stor16 / totalSupply
            if totalRewardsDistributed > !arg1:
                revert with 0, 17
            if totalRewardsDistributed + arg1 < totalRewardsDistributed:
                revert with 0, 'SafeMath: addition overflow'
            totalRewardsDistributed += arg1
        _325 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _325 + 68] = mem[_315 + idx + 32]
            idx = idx + 32
            continue 
        mem[_325 + 98] = 0
        revert with memory
          from mem[64]
           len _325 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if 0 > stor5[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(msg.sender)] < 0:
                revert with 0, 17
            if 0 > stor16:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor16 < 0:
                revert with 0, 17
        else:
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * t / s > stor5[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(msg.sender)] < arg1 * t / s:
                revert with 0, 17
            stor5[address(msg.sender)] += -1 * arg1 * t / s
            if arg1 * t / s > stor16:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor16 < arg1 * t / s:
                revert with 0, 17
            stor16 += -1 * arg1 * t / s
    else:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if 0 > stor5[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(msg.sender)] < 0:
                revert with 0, 17
            if 0 > stor16:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor16 < 0:
                revert with 0, 17
        else:
            if arg1 and stor16 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor16 / totalSupply / arg1 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor16 / totalSupply > stor5[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(msg.sender)] < arg1 * stor16 / totalSupply:
                revert with 0, 17
            stor5[address(msg.sender)] += -1 * arg1 * stor16 / totalSupply
            if arg1 * stor16 / totalSupply > stor16:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor16 < arg1 * stor16 / totalSupply:
                revert with 0, 17
            stor16 += -1 * arg1 * stor16 / totalSupply
    if totalRewardsDistributed > !arg1:
        revert with 0, 17
    if totalRewardsDistributed + arg1 < totalRewardsDistributed:
        revert with 0, 'SafeMath: addition overflow'
    totalRewardsDistributed += arg1
}

function sub_c0e89b57(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    mem[0] = msg.sender
    mem[32] = 8
    if not stor8[msg.sender]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You are not allowed to claim rewards to distribute'
    idx = 0
    s = totalSupply
    t = stor16
    while idx < stor12.length:
        mem[0] = stor12[idx]
        mem[32] = 5
        if stor5[stor12[idx]] > t:
            _261 = mem[64]
            mem[64] = mem[64] + 64
            mem[_261] = 26
            mem[_261 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _265 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _265 + 68] = mem[_261 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_265 + 94] = 0
                revert with memory
                  from mem[64]
                   len _265 + -mem[64] + 100
            if not arg2:
                mem[0] = this.address
                mem[32] = 6
                _296 = mem[64]
                mem[64] = mem[64] + 64
                mem[_296] = 30
                mem[_296 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor6[address(this.address)]:
                    _301 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _301 + 68] = mem[_296 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_301 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _301 + -mem[64] + 100
                if stor6[address(this.address)] < arg2:
                    revert with 0, 17
                mem[0] = this.address
                stor6[address(this.address)] -= arg2
                mem[32] = 5
                _328 = mem[64]
                mem[64] = mem[64] + 64
                mem[_328] = 30
                mem[_328 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor5[address(this.address)]:
                    _340 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _340 + 68] = mem[_328 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_340 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _340 + -mem[64] + 100
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(arg1)] > -1:
                    revert with 0, 17
                if stor5[address(arg1)] < stor5[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(arg1)] = stor5[address(arg1)]
            else:
                if arg2 and stor16 / totalSupply > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[0] = this.address
                mem[32] = 6
                _316 = mem[64]
                mem[64] = mem[64] + 64
                mem[_316] = 30
                mem[_316 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor6[address(this.address)]:
                    _327 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _327 + 68] = mem[_316 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_327 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _327 + -mem[64] + 100
                if stor6[address(this.address)] < arg2:
                    revert with 0, 17
                mem[0] = this.address
                stor6[address(this.address)] -= arg2
                mem[32] = 5
                _368 = mem[64]
                mem[64] = mem[64] + 64
                mem[_368] = 30
                mem[_368 + 32] = 'SafeMath: subtraction overflow'
                if arg2 * stor16 / totalSupply > stor5[address(this.address)]:
                    _385 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _385 + 68] = mem[_368 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_385 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _385 + -mem[64] + 100
                if stor5[address(this.address)] < arg2 * stor16 / totalSupply:
                    revert with 0, 17
                stor5[address(this.address)] += -1 * arg2 * stor16 / totalSupply
                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                    revert with 0, 17
                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(arg1)] += arg2 * stor16 / totalSupply
        else:
            if idx >= stor12.length:
                revert with 0, 50
            mem[0] = stor12[idx]
            mem[32] = 6
            if stor6[stor12[idx]] <= s:
                if idx >= stor12.length:
                    revert with 0, 50
                mem[0] = stor12[idx]
                mem[32] = 5
                _266 = mem[64]
                mem[64] = mem[64] + 64
                mem[_266] = 30
                mem[_266 + 32] = 'SafeMath: subtraction overflow'
                if stor5[stor12[idx]] > t:
                    _269 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _269 + 68] = mem[_266 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_269 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _269 + -mem[64] + 100
                if t < stor5[stor12[idx]]:
                    revert with 0, 17
                if idx >= stor12.length:
                    revert with 0, 50
                mem[0] = stor12[idx]
                mem[32] = 6
                _288 = mem[64]
                mem[64] = mem[64] + 64
                mem[_288] = 30
                mem[_288 + 32] = 'SafeMath: subtraction overflow'
                if stor6[stor12[idx]] <= s:
                    if s < stor6[stor12[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor6[stor12[idx]]
                    t = t - stor5[stor12[idx]]
                    continue 
                _297 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _297 + 68] = mem[_288 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_297 + 98] = 0
                revert with memory
                  from mem[64]
                   len _297 + -mem[64] + 100
            _267 = mem[64]
            mem[64] = mem[64] + 64
            mem[_267] = 26
            mem[_267 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _270 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _270 + 68] = mem[_267 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_270 + 94] = 0
                revert with memory
                  from mem[64]
                   len _270 + -mem[64] + 100
            if not arg2:
                mem[0] = this.address
                mem[32] = 6
                _303 = mem[64]
                mem[64] = mem[64] + 64
                mem[_303] = 30
                mem[_303 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor6[address(this.address)]:
                    _309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _309 + 68] = mem[_303 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_309 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _309 + -mem[64] + 100
                if stor6[address(this.address)] < arg2:
                    revert with 0, 17
                mem[0] = this.address
                stor6[address(this.address)] -= arg2
                mem[32] = 5
                _343 = mem[64]
                mem[64] = mem[64] + 64
                mem[_343] = 30
                mem[_343 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor5[address(this.address)]:
                    _356 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _356 + 68] = mem[_343 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_356 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _356 + -mem[64] + 100
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(arg1)] > -1:
                    revert with 0, 17
                if stor5[address(arg1)] < stor5[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(arg1)] = stor5[address(arg1)]
            else:
                if arg2 and stor16 / totalSupply > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[0] = this.address
                mem[32] = 6
                _330 = mem[64]
                mem[64] = mem[64] + 64
                mem[_330] = 30
                mem[_330 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor6[address(this.address)]:
                    _342 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _342 + 68] = mem[_330 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_342 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _342 + -mem[64] + 100
                if stor6[address(this.address)] < arg2:
                    revert with 0, 17
                mem[0] = this.address
                stor6[address(this.address)] -= arg2
                mem[32] = 5
                _387 = mem[64]
                mem[64] = mem[64] + 64
                mem[_387] = 30
                mem[_387 + 32] = 'SafeMath: subtraction overflow'
                if arg2 * stor16 / totalSupply > stor5[address(this.address)]:
                    _399 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _399 + 68] = mem[_387 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_399 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _399 + -mem[64] + 100
                if stor5[address(this.address)] < arg2 * stor16 / totalSupply:
                    revert with 0, 17
                stor5[address(this.address)] += -1 * arg2 * stor16 / totalSupply
                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                    revert with 0, 17
                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(arg1)] += arg2 * stor16 / totalSupply
        emit Transfer(arg2, this.address, address(arg1));
        if totalAmountStaked > !arg2:
            revert with 0, 17
        if totalAmountStaked + arg2 < totalAmountStaked:
            revert with 0, 'SafeMath: addition overflow'
        totalAmountStaked += arg2
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor16 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg2:
            if arg2 > stor6[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor6[address(this.address)] < arg2:
                revert with 0, 17
            stor6[address(this.address)] -= arg2
            if 0 > stor5[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(this.address)] < 0:
                revert with 0, 17
            if stor5[address(arg1)] > -1:
                revert with 0, 17
            if stor5[address(arg1)] < stor5[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            stor5[address(arg1)] = stor5[address(arg1)]
        else:
            if arg2 and t / s > -1 / arg2:
                revert with 0, 17
            if not arg2:
                revert with 0, 18
            if arg2 * t / s / arg2 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg2 > stor6[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor6[address(this.address)] < arg2:
                revert with 0, 17
            stor6[address(this.address)] -= arg2
            if arg2 * t / s > stor5[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(this.address)] < arg2 * t / s:
                revert with 0, 17
            stor5[address(this.address)] += -1 * arg2 * t / s
            if stor5[address(arg1)] > !(arg2 * t / s):
                revert with 0, 17
            if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            stor5[address(arg1)] += arg2 * t / s
    else:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg2:
            if arg2 > stor6[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor6[address(this.address)] < arg2:
                revert with 0, 17
            stor6[address(this.address)] -= arg2
            if 0 > stor5[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(this.address)] < 0:
                revert with 0, 17
            if stor5[address(arg1)] > -1:
                revert with 0, 17
            if stor5[address(arg1)] < stor5[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            stor5[address(arg1)] = stor5[address(arg1)]
        else:
            if arg2 and stor16 / totalSupply > -1 / arg2:
                revert with 0, 17
            if not arg2:
                revert with 0, 18
            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg2 > stor6[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor6[address(this.address)] < arg2:
                revert with 0, 17
            stor6[address(this.address)] -= arg2
            if arg2 * stor16 / totalSupply > stor5[address(this.address)]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if stor5[address(this.address)] < arg2 * stor16 / totalSupply:
                revert with 0, 17
            stor5[address(this.address)] += -1 * arg2 * stor16 / totalSupply
            if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                revert with 0, 17
            if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            stor5[address(arg1)] += arg2 * stor16 / totalSupply
    emit Transfer(arg2, this.address, address(arg1));
    if totalAmountStaked > !arg2:
        revert with 0, 17
    if totalAmountStaked + arg2 < totalAmountStaked:
        revert with 0, 'SafeMath: addition overflow'
    totalAmountStaked += arg2
}

function sub_741aaecd(?) payable {
    require calldata.size - 4 >= 224
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg3.length)) + 97 < 96 or ceil32(ceil32(arg3.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg3.length
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    require arg5 == uint8(arg5)
    if arg2 <= 0:
        revert with 0, 'Amount should be greater than Zero'
    if arg1 < 1:
        revert with 0, 'The lock period is out of range'
    if arg1 > 12:
        revert with 0, 'The lock period is out of range'
    mem[ceil32(ceil32(arg3.length)) + 101] = msg.sender
    mem[ceil32(ceil32(arg3.length)) + 133] = this.address
    mem[ceil32(ceil32(arg3.length)) + 165] = arg2
    mem[ceil32(ceil32(arg3.length)) + 197] = arg4
    mem[ceil32(ceil32(arg3.length)) + 229] = uint8(arg5)
    mem[ceil32(ceil32(arg3.length)) + 261] = arg6
    mem[ceil32(ceil32(arg3.length)) + 293] = arg7
    require ext_code.size(address(stor9.field_16))
    call address(stor9.field_16).0xd6e03cd4 with:
         gas gas_remaining wei
        args msg.sender, this.address, arg2, arg4, arg5 << 248, arg6, arg7
    mem[ceil32(ceil32(arg3.length)) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 97 len 6948] = code.data[13450 len 6948]
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7045] = msg.sender
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7077] = address(stor9.field_16)
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7109] = this.address
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7141] = arg2
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7173] = arg1
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7205] = 192
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7237] = arg3.length
    mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 7269 len ceil32(arg3.length)] = arg3[all], ext_call.return_data[arg3.length + -ceil32(ceil32(arg3.length)) + 31 len ceil32(arg3.length) - arg3.length]
    if ceil32(arg3.length) <= arg3.length:
        create contract with 0 wei
                        code: code.data[13450 len 6948], msg.sender, address(stor9.field_0), address(this.address), arg2, arg1, 192, arg3.length, arg3[all], ext_call.return_data[arg3.length + -ceil32(ceil32(arg3.length)) + 31 len ceil32(arg3.length) - arg3.length]
        if not create.new_address:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 101] = address(create.new_address)
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 133] = arg2
        require ext_code.size(address(stor9.field_16))
        call address(stor9.field_16).0xa9059cbb with:
             gas gas_remaining wei
            args address(create.new_address), arg2
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 97
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[32] = 3
        stor3[msg.sender].field_0++
        stor3[msg.sender][stor3[msg.sender].field_0].field_0 = address(create.new_address)
        mem[0] = sha3(msg.sender, 3)
        if not stor3[msg.sender].field_0:
            idx = 0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][idx].field_0 = 0
                idx = idx + 1
                continue 
            if totalAmountStaked > !arg2:
                revert with 0, 17
            if totalAmountStaked + arg2 < totalAmountStaked:
                revert with 0, 'SafeMath: addition overflow'
            totalAmountStaked += arg2
            if not arg2:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5023 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5023] = 26
                        mem[_5023 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5041 + 68] = mem[_5023 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5041 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5041 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 6
                        _5172 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5172] = 30
                        mem[_5172 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6[address(this.address)]:
                            _5197 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5197 + 68] = mem[_5172 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5197 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5197 + -mem[64] + 100
                        if stor6[address(this.address)] < 0:
                            revert with 0, 17
                        mem[0] = this.address
                        mem[32] = 5
                        _5317 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5317] = 30
                        mem[_5317 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor5[address(this.address)]:
                            if stor5[address(this.address)] < 0:
                                revert with 0, 17
                            if stor5[address(create.new_address)] > -1:
                                revert with 0, 17
                            if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(create.new_address)] = stor5[address(create.new_address)]
                            emit Transfer(0, this.address, address(create.new_address));
                            stor8[address(create.new_address)] = 1
                            return address(create.new_address)
                        _5369 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5369 + 68] = mem[_5317 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5369 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5369 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _5042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5042] = 30
                        mem[_5042 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _5060 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5060 + 68] = mem[_5042 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5060 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5060 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _5139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5139] = 30
                        mem[_5139 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _5173 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5173 + 68] = mem[_5139 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5173 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5173 + -mem[64] + 100
                    _5043 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5043] = 26
                    mem[_5043 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5061 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5061 + 68] = mem[_5043 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5061 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5061 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 6
                    _5199 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5199] = 30
                    mem[_5199 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor6[address(this.address)]:
                        _5230 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5230 + 68] = mem[_5199 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5230 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5230 + -mem[64] + 100
                    if stor6[address(this.address)] < 0:
                        revert with 0, 17
                    mem[0] = this.address
                    mem[32] = 5
                    _5371 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5371] = 30
                    mem[_5371 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor5[address(this.address)]:
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                        emit Transfer(0, this.address, address(create.new_address));
                        stor8[address(create.new_address)] = 1
                        return address(create.new_address)
                    _5430 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5430 + 68] = mem[_5371 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5430 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5430 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        var89001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                else:
                    if not totalSupply:
                        var89001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                if 0 > stor6[address(this.address)]:
                    var102001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6[address(this.address)] < 0:
                    revert with 0, 17
                if 0 > stor5[address(this.address)]:
                    var110001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(create.new_address)] > -1:
                    revert with 0, 17
                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                emit Transfer(0, this.address, address(create.new_address));
            else:
                if arg2 and arg1 > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * arg1 / arg2 != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5021 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5021] = 26
                        mem[_5021 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5037 + 68] = mem[_5021 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5037 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5037 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _5170 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5170] = 30
                            mem[_5170 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _5192 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5192 + 68] = mem[_5170 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5192 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5192 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _5311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5311] = 30
                            mem[_5311 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _5363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5363 + 68] = mem[_5311 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5363 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5363 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _5260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5260] = 30
                        mem[_5260 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _5310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5310 + 68] = mem[_5260 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5310 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _5488 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5488] = 30
                        mem[_5488 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _5560 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5560 + 68] = mem[_5488 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5560 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5560 + -mem[64] + 100
                    else:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5038] = 30
                            mem[_5038 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5057 + 68] = mem[_5038 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5057 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5057 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5136] = 30
                            mem[_5136 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5171 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5171 + 68] = mem[_5136 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5171 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5171 + -mem[64] + 100
                        _5039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5039] = 26
                        mem[_5039 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5058 + 68] = mem[_5039 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5058 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5058 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _5194 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5194] = 30
                            mem[_5194 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _5227 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5227 + 68] = mem[_5194 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5227 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5227 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _5366 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5366] = 30
                            mem[_5366 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _5425 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5425 + 68] = mem[_5366 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5425 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5425 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _5313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5313] = 30
                        mem[_5313 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _5365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5365 + 68] = mem[_5313 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5365 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _5562 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5562] = 30
                        mem[_5562 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _5630 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5630 + 68] = mem[_5562 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5630 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5630 + -mem[64] + 100
                    ('le', ('mul', ('param', 'arg2'), ('param', 'arg1'), ('div', ('stor', ('name', 'stor16', 16)), ('stor', ('name', 'totalSupply', 15)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'address'), ('name', 'stor5', 5))))
                    if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                    if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                    emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                    stor8[address(create.new_address)] = 1
                    return address(create.new_address)
                if not totalSupply:
                    var85001 = 32
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var108001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var116001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and t / s > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * t / s / arg2 * arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * t / s > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * t / s:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * t / s
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * t / s):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * t / s) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * t / s
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var108001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var116001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
        else:
            mem[0] = sha3(msg.sender, 3)
            s = 0
            idx = 0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][s].field_0 = stor3[msg.sender][idx].field_0
                s = s + 1
                idx = idx + 1
                continue 
            idx = stor3[msg.sender].field_0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][idx].field_0 = 0
                idx = idx + 1
                continue 
            if totalAmountStaked > !arg2:
                revert with 0, 17
            if totalAmountStaked + arg2 < totalAmountStaked:
                revert with 0, 'SafeMath: addition overflow'
            totalAmountStaked += arg2
            if not arg2:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _6891 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6891] = 26
                        mem[_6891 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6909 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6909 + 68] = mem[_6891 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6909 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6909 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 6
                        _7034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7034] = 30
                        mem[_7034 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6[address(this.address)]:
                            _7051 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7051 + 68] = mem[_7034 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7051 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7051 + -mem[64] + 100
                        if stor6[address(this.address)] < 0:
                            revert with 0, 17
                        mem[0] = this.address
                        mem[32] = 5
                        _7143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7143] = 30
                        mem[_7143 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor5[address(this.address)]:
                            if stor5[address(this.address)] < 0:
                                revert with 0, 17
                            if stor5[address(create.new_address)] > -1:
                                revert with 0, 17
                            if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(create.new_address)] = stor5[address(create.new_address)]
                            emit Transfer(0, this.address, address(create.new_address));
                            stor8[address(create.new_address)] = 1
                            return address(create.new_address)
                        _7181 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7181 + 68] = mem[_7143 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7181 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7181 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _6910 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6910] = 30
                        mem[_6910 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _6924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6924 + 68] = mem[_6910 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6924 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _7003 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7003] = 30
                        mem[_7003 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _7035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7035 + 68] = mem[_7003 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7035 + -mem[64] + 100
                    _6911 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6911] = 26
                    mem[_6911 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _6925 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6925 + 68] = mem[_6911 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6925 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _6925 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 6
                    _7053 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7053] = 30
                    mem[_7053 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor6[address(this.address)]:
                        _7078 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7078 + 68] = mem[_7053 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7078 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7078 + -mem[64] + 100
                    if stor6[address(this.address)] < 0:
                        revert with 0, 17
                    mem[0] = this.address
                    mem[32] = 5
                    _7183 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7183] = 30
                    mem[_7183 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor5[address(this.address)]:
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                        emit Transfer(0, this.address, address(create.new_address));
                        stor8[address(create.new_address)] = 1
                        return address(create.new_address)
                    _7222 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _7222 + 68] = mem[_7183 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7222 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7222 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        var92001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                else:
                    if not totalSupply:
                        var92001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                if 0 > stor6[address(this.address)]:
                    var105001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6[address(this.address)] < 0:
                    revert with 0, 17
                if 0 > stor5[address(this.address)]:
                    var113001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(create.new_address)] > -1:
                    revert with 0, 17
                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                emit Transfer(0, this.address, address(create.new_address));
            else:
                if arg2 and arg1 > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * arg1 / arg2 != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _6889 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6889] = 26
                        mem[_6889 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6905 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6905 + 68] = mem[_6889 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6905 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6905 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _7032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7032] = 30
                            mem[_7032 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _7046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7046 + 68] = mem[_7032 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7046 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _7137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7137] = 30
                            mem[_7137 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _7175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7175 + 68] = mem[_7137 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7175 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7175 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _7100 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7100] = 30
                        mem[_7100 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _7136 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7136 + 68] = mem[_7100 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7136 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7136 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _7262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7262] = 30
                        mem[_7262 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _7310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7310 + 68] = mem[_7262 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7310 + -mem[64] + 100
                    else:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _6906 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6906] = 30
                            mem[_6906 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _6921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6921 + 68] = mem[_6906 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6921 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6921 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _7000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7000] = 30
                            mem[_7000 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _7033 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7033 + 68] = mem[_7000 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7033 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7033 + -mem[64] + 100
                        _6907 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6907] = 26
                        mem[_6907 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6922 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6922 + 68] = mem[_6907 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6922 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6922 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _7048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7048] = 30
                            mem[_7048 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _7075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7075 + 68] = mem[_7048 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7075 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7075 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _7178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7178] = 30
                            mem[_7178 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _7217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7217 + 68] = mem[_7178 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7217 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _7139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7139] = 30
                        mem[_7139 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _7177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7177 + 68] = mem[_7139 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7177 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _7312 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7312] = 30
                        mem[_7312 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _7354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7354 + 68] = mem[_7312 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7354 + -mem[64] + 100
                    ('le', ('mul', ('param', 'arg2'), ('param', 'arg1'), ('div', ('stor', ('name', 'stor16', 16)), ('stor', ('name', 'totalSupply', 15)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'address'), ('name', 'stor5', 5))))
                    if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                    if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                    emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                    stor8[address(create.new_address)] = 1
                    return address(create.new_address)
                if not totalSupply:
                    var88001 = 32
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var111001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var119001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and t / s > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * t / s / arg2 * arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * t / s > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * t / s:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * t / s
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * t / s):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * t / s) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * t / s
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var111001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var119001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
    else:
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + arg3.length + 7269] = 0
        create contract with 0 wei
                        code: code.data[13450 len 6948], msg.sender, address(stor9.field_0), address(this.address), arg2, arg1, 192, arg3.length, arg3[all], ext_call.return_data[arg3.length + -ceil32(ceil32(arg3.length)) + 31 len ceil32(arg3.length) - arg3.length]
        if not create.new_address:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 101] = address(create.new_address)
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 133] = arg2
        require ext_code.size(address(stor9.field_16))
        call address(stor9.field_16).0xa9059cbb with:
             gas gas_remaining wei
            args address(create.new_address), arg2
        mem[ceil32(ceil32(arg3.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 97
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[32] = 3
        stor3[msg.sender].field_0++
        stor3[msg.sender][stor3[msg.sender].field_0].field_0 = address(create.new_address)
        mem[0] = sha3(msg.sender, 3)
        if not stor3[msg.sender].field_0:
            idx = 0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][idx].field_0 = 0
                idx = idx + 1
                continue 
            if totalAmountStaked > !arg2:
                revert with 0, 17
            if totalAmountStaked + arg2 < totalAmountStaked:
                revert with 0, 'SafeMath: addition overflow'
            totalAmountStaked += arg2
            if not arg2:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5027 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5027] = 26
                        mem[_5027 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5050 + 68] = mem[_5027 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5050 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5050 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 6
                        _5180 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5180] = 30
                        mem[_5180 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6[address(this.address)]:
                            _5210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5210 + 68] = mem[_5180 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5210 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5210 + -mem[64] + 100
                        if stor6[address(this.address)] < 0:
                            revert with 0, 17
                        mem[0] = this.address
                        mem[32] = 5
                        _5335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5335] = 30
                        mem[_5335 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor5[address(this.address)]:
                            if stor5[address(this.address)] < 0:
                                revert with 0, 17
                            if stor5[address(create.new_address)] > -1:
                                revert with 0, 17
                            if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(create.new_address)] = stor5[address(create.new_address)]
                            emit Transfer(0, this.address, address(create.new_address));
                            stor8[address(create.new_address)] = 1
                            return address(create.new_address)
                        _5391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5391 + 68] = mem[_5335 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5391 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _5051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5051] = 30
                        mem[_5051 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _5066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5066 + 68] = mem[_5051 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5066 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5066 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _5145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5145] = 30
                        mem[_5145 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _5181 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5181 + 68] = mem[_5145 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5181 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5181 + -mem[64] + 100
                    _5052 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5052] = 26
                    mem[_5052 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5067 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5067 + 68] = mem[_5052 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5067 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5067 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 6
                    _5212 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5212] = 30
                    mem[_5212 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor6[address(this.address)]:
                        _5239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5239 + 68] = mem[_5212 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5239 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5239 + -mem[64] + 100
                    if stor6[address(this.address)] < 0:
                        revert with 0, 17
                    mem[0] = this.address
                    mem[32] = 5
                    _5393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5393] = 30
                    mem[_5393 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor5[address(this.address)]:
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                        emit Transfer(0, this.address, address(create.new_address));
                        stor8[address(create.new_address)] = 1
                        return address(create.new_address)
                    _5452 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5452 + 68] = mem[_5393 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5452 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5452 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        var90001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                else:
                    if not totalSupply:
                        var90001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                if 0 > stor6[address(this.address)]:
                    var103001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6[address(this.address)] < 0:
                    revert with 0, 17
                if 0 > stor5[address(this.address)]:
                    var111001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(create.new_address)] > -1:
                    revert with 0, 17
                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                emit Transfer(0, this.address, address(create.new_address));
            else:
                if arg2 and arg1 > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * arg1 / arg2 != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5025] = 26
                        mem[_5025 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5046 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5046 + 68] = mem[_5025 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5046 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5046 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _5178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5178] = 30
                            mem[_5178 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _5205 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5205 + 68] = mem[_5178 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5205 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5205 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _5329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5329] = 30
                            mem[_5329 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _5385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5385 + 68] = mem[_5329 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5385 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5385 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _5277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5277] = 30
                        mem[_5277 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _5328 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5328 + 68] = mem[_5277 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5328 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5328 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _5508 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5508] = 30
                        mem[_5508 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _5586 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5586 + 68] = mem[_5508 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5586 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5586 + -mem[64] + 100
                    else:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5047 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5047] = 30
                            mem[_5047 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5063 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5063 + 68] = mem[_5047 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5063 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5063 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5142] = 30
                            mem[_5142 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5179 + 68] = mem[_5142 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5179 + -mem[64] + 100
                        _5048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5048] = 26
                        mem[_5048 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5064 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5064 + 68] = mem[_5048 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5064 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5064 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _5207 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5207] = 30
                            mem[_5207 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _5236 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5236 + 68] = mem[_5207 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5236 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5236 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _5388 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5388] = 30
                            mem[_5388 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _5447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5447 + 68] = mem[_5388 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5447 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5447 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _5331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5331] = 30
                        mem[_5331 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _5387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5387 + 68] = mem[_5331 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5387 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5387 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _5588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5588] = 30
                        mem[_5588 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _5646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5646 + 68] = mem[_5588 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5646 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5646 + -mem[64] + 100
                    ('le', ('mul', ('param', 'arg2'), ('param', 'arg1'), ('div', ('stor', ('name', 'stor16', 16)), ('stor', ('name', 'totalSupply', 15)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'address'), ('name', 'stor5', 5))))
                    if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                    if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                    emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                    stor8[address(create.new_address)] = 1
                    return address(create.new_address)
                if not totalSupply:
                    var86001 = 32
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var109001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var117001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and t / s > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * t / s / arg2 * arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * t / s > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * t / s:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * t / s
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * t / s):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * t / s) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * t / s
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var109001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var117001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
        else:
            mem[0] = sha3(msg.sender, 3)
            s = 0
            idx = 0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][s].field_0 = stor3[msg.sender][idx].field_0
                s = s + 1
                idx = idx + 1
                continue 
            idx = stor3[msg.sender].field_0
            while stor3[msg.sender].field_0 > idx:
                stor3[msg.sender][idx].field_0 = 0
                idx = idx + 1
                continue 
            if totalAmountStaked > !arg2:
                revert with 0, 17
            if totalAmountStaked + arg2 < totalAmountStaked:
                revert with 0, 'SafeMath: addition overflow'
            totalAmountStaked += arg2
            if not arg2:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _6895 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6895] = 26
                        mem[_6895 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6917 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6917 + 68] = mem[_6895 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6917 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6917 + -mem[64] + 100
                        mem[0] = this.address
                        mem[32] = 6
                        _7038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7038] = 30
                        mem[_7038 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6[address(this.address)]:
                            _7061 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7061 + 68] = mem[_7038 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7061 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7061 + -mem[64] + 100
                        if stor6[address(this.address)] < 0:
                            revert with 0, 17
                        mem[0] = this.address
                        mem[32] = 5
                        _7155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7155] = 30
                        mem[_7155 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor5[address(this.address)]:
                            if stor5[address(this.address)] < 0:
                                revert with 0, 17
                            if stor5[address(create.new_address)] > -1:
                                revert with 0, 17
                            if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(create.new_address)] = stor5[address(create.new_address)]
                            emit Transfer(0, this.address, address(create.new_address));
                            stor8[address(create.new_address)] = 1
                            return address(create.new_address)
                        _7195 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7195 + 68] = mem[_7155 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7195 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7195 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _6918 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6918] = 30
                        mem[_6918 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _6930 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6930 + 68] = mem[_6918 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6930 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6930 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _7009 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7009] = 30
                        mem[_7009 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _7039 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7039 + 68] = mem[_7009 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7039 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7039 + -mem[64] + 100
                    _6919 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6919] = 26
                    mem[_6919 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _6931 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _6931 + 68] = mem[_6919 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6931 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _6931 + -mem[64] + 100
                    mem[0] = this.address
                    mem[32] = 6
                    _7063 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7063] = 30
                    mem[_7063 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor6[address(this.address)]:
                        _7085 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7085 + 68] = mem[_7063 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7085 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7085 + -mem[64] + 100
                    if stor6[address(this.address)] < 0:
                        revert with 0, 17
                    mem[0] = this.address
                    mem[32] = 5
                    _7197 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7197] = 30
                    mem[_7197 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor5[address(this.address)]:
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                        emit Transfer(0, this.address, address(create.new_address));
                        stor8[address(create.new_address)] = 1
                        return address(create.new_address)
                    _7236 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _7236 + 68] = mem[_7197 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7236 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7236 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        var93001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                else:
                    if not totalSupply:
                        var93001 = 32
                        revert with 0, 'SafeMath: division by zero', 0
                if 0 > stor6[address(this.address)]:
                    var106001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6[address(this.address)] < 0:
                    revert with 0, 17
                if 0 > stor5[address(this.address)]:
                    var114001 = 32
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor5[address(this.address)] < 0:
                    revert with 0, 17
                if stor5[address(create.new_address)] > -1:
                    revert with 0, 17
                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                    revert with 0, 'SafeMath: addition overflow'
                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                emit Transfer(0, this.address, address(create.new_address));
            else:
                if arg2 and arg1 > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * arg1 / arg2 != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _6893 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6893] = 26
                        mem[_6893 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6913 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6913 + 68] = mem[_6893 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6913 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6913 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _7036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7036] = 30
                            mem[_7036 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _7056 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7056 + 68] = mem[_7036 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7056 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7056 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _7149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7149] = 30
                            mem[_7149 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _7189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7189 + 68] = mem[_7149 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7189 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7189 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _7110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7110] = 30
                        mem[_7110 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _7148 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7148 + 68] = mem[_7110 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7148 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7148 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _7274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7274] = 30
                        mem[_7274 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _7325 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7325 + 68] = mem[_7274 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7325 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7325 + -mem[64] + 100
                    else:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _6914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6914] = 30
                            mem[_6914 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _6927 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6927 + 68] = mem[_6914 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6927 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6927 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _7006 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7006] = 30
                            mem[_7006 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _7037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7037 + 68] = mem[_7006 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7037 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7037 + -mem[64] + 100
                        _6915 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6915] = 26
                        mem[_6915 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _6928 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _6928 + 68] = mem[_6915 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6928 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _6928 + -mem[64] + 100
                        if not arg2 * arg1:
                            mem[0] = this.address
                            mem[32] = 6
                            _7058 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7058] = 30
                            mem[_7058 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * arg1 > stor6[address(this.address)]:
                                _7082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7082 + 68] = mem[_7058 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7082 + -mem[64] + 100
                            if stor6[address(this.address)] < arg2 * arg1:
                                revert with 0, 17
                            mem[0] = this.address
                            stor6[address(this.address)] += -1 * arg2 * arg1
                            mem[32] = 5
                            _7192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7192] = 30
                            mem[_7192 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(this.address)]:
                                if stor5[address(this.address)] < 0:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] > -1:
                                    revert with 0, 17
                                if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(create.new_address)] = stor5[address(create.new_address)]
                                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                                stor8[address(create.new_address)] = 1
                                return address(create.new_address)
                            _7231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7231 + 68] = mem[_7192 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7231 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7231 + -mem[64] + 100
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = this.address
                        mem[32] = 6
                        _7151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7151] = 30
                        mem[_7151 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            _7191 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7191 + 68] = mem[_7151 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7191 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7191 + -mem[64] + 100
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        mem[0] = this.address
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        mem[32] = 5
                        _7327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7327] = 30
                        mem[_7327 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            _7365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7365 + 68] = mem[_7327 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7365 + -mem[64] + 100
                    ('le', ('mul', ('param', 'arg2'), ('param', 'arg1'), ('div', ('stor', ('name', 'stor16', 16)), ('stor', ('name', 'totalSupply', 15)))), ('stor', ('map', ('mask_shl', 160, 0, 0, 'address'), ('name', 'stor5', 5))))
                    if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                    if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                    emit Transfer((arg2 * arg1), this.address, address(create.new_address));
                    stor8[address(create.new_address)] = 1
                    return address(create.new_address)
                if not totalSupply:
                    var89001 = 32
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var112001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var120001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and t / s > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * t / s / arg2 * arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * t / s > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * t / s:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * t / s
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * t / s):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * t / s) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * t / s
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2 * arg1:
                        if arg2 * arg1 > stor6[address(this.address)]:
                            var112001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if 0 > stor5[address(this.address)]:
                            var120001 = 32
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < 0:
                            revert with 0, 17
                        if stor5[address(create.new_address)] > -1:
                            revert with 0, 17
                        if stor5[address(create.new_address)] < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] = stor5[address(create.new_address)]
                    else:
                        if arg2 * arg1 and stor16 / totalSupply > -1 / arg2 * arg1:
                            revert with 0, 17
                        if not arg2 * arg1:
                            revert with 0, 18
                        if arg2 * arg1 * stor16 / totalSupply / arg2 * arg1 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * arg1 > stor6[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(this.address)] < arg2 * arg1:
                            revert with 0, 17
                        stor6[address(this.address)] += -1 * arg2 * arg1
                        if arg2 * arg1 * stor16 / totalSupply > stor5[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(this.address)] < arg2 * arg1 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(this.address)] += -1 * arg2 * arg1 * stor16 / totalSupply
                        if stor5[address(create.new_address)] > !(arg2 * arg1 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(create.new_address)] + (arg2 * arg1 * stor16 / totalSupply) < stor5[address(create.new_address)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(create.new_address)] += arg2 * arg1 * stor16 / totalSupply
                emit Transfer((arg2 * arg1), this.address, address(create.new_address));
    stor8[address(create.new_address)] = 1
    return address(create.new_address)
}

function transfer(address arg1, uint256 arg2) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor11[address(msg.sender)]:
        if stor11[address(msg.sender)]:
            mem[0] = msg.sender
            mem[32] = 11
            if not stor11[address(msg.sender)]:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _3414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3414] = 26
                        mem[_3414 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _3474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3474 + 68] = mem[_3414 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3474 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3474 + -mem[64] + 100
                        if not arg2:
                            mem[0] = msg.sender
                            mem[32] = 5
                            _3953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3953] = 30
                            mem[_3953 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4000 + 68] = mem[_3953 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4000 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4000 + -mem[64] + 100
                        if arg2 and stor16 / totalSupply > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 5
                        _4225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4225] = 30
                        mem[_4225 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _4390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4390 + 68] = mem[_4225 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4390 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4390 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] > s:
                        _3476 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3476] = 26
                        mem[_3476 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _3535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3535 + 68] = mem[_3476 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3535 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3535 + -mem[64] + 100
                        if not arg2:
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4002 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4002] = 30
                            mem[_4002 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4106 + 68] = mem[_4002 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4106 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4106 + -mem[64] + 100
                        if arg2 and stor16 / totalSupply > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = msg.sender
                        mem[32] = 5
                        _4392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4392] = 30
                        mem[_4392 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _4534 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4534 + 68] = mem[_4392 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4534 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4534 + -mem[64] + 100
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    _3475 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3475] = 30
                    mem[_3475 + 32] = 'SafeMath: subtraction overflow'
                    if stor5[stor12[idx]] > t:
                        _3534 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3534 + 68] = mem[_3475 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3534 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3534 + -mem[64] + 100
                    if t < stor5[stor12[idx]]:
                        revert with 0, 17
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    _3833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3833] = 30
                    mem[_3833 + 32] = 'SafeMath: subtraction overflow'
                    if stor6[stor12[idx]] <= s:
                        if s < stor6[stor12[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor6[stor12[idx]]
                        t = t - stor5[stor12[idx]]
                        continue 
                    _3954 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3954 + 68] = mem[_3833 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3954 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3954 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if 0 > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor5[arg1] > -1:
                            revert with 0, 17
                        if stor5[arg1] < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1]
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * t / s > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < arg2 * t / s:
                            revert with 0, 17
                        stor5[address(msg.sender)] += -1 * arg2 * t / s
                        if stor5[arg1] > !(arg2 * t / s):
                            revert with 0, 17
                        if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if 0 > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor5[arg1] > -1:
                            revert with 0, 17
                        if stor5[arg1] < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1]
                    else:
                        if arg2 and stor16 / totalSupply > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                        if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
            else:
                mem[0] = arg1
                mem[32] = 11
                if not stor11[address(arg1)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _3416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3416] = 26
                            mem[_3416 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3478 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3478 + 68] = mem[_3416 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3478 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3478 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _3955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3955] = 30
                                mem[_3955 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4005 + 68] = mem[_3955 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4005 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4005 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4231] = 30
                            mem[_4231 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4396 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4396 + 68] = mem[_4231 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4396 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4396 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] > s:
                            _3480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3480] = 26
                            mem[_3480 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3538 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3538 + 68] = mem[_3480 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3538 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3538 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4007] = 30
                                mem[_4007 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4110 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4110 + 68] = mem[_4007 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4110 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4110 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4398 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4398] = 30
                            mem[_4398 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4541 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4541 + 68] = mem[_4398 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4541 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4541 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _3479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3479] = 30
                        mem[_3479 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _3537 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3537 + 68] = mem[_3479 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3537 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3537 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _3836 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3836] = 30
                        mem[_3836 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _3956 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3956 + 68] = mem[_3836 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3956 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3956 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * t / s > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * t / s
                            if stor5[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                    else:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                else:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _3418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3418] = 26
                            mem[_3418 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3482 + 68] = mem[_3418 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3482 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3482 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 6
                                _3957 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3957] = 30
                                mem[_3957 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    _4010 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4010 + 68] = mem[_3957 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4010 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4010 + -mem[64] + 100
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor6[address(msg.sender)] -= arg2
                                mem[32] = 5
                                _4403 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4403] = 30
                                mem[_4403 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(msg.sender)]:
                                    _4547 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4547 + 68] = mem[_4403 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4547 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4547 + -mem[64] + 100
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 6
                                _4237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4237] = 30
                                mem[_4237 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    _4402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4402 + 68] = mem[_4237 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4402 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4402 + -mem[64] + 100
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor6[address(msg.sender)] -= arg2
                                mem[32] = 5
                                _4977 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4977] = 30
                                mem[_4977 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    _5184 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5184 + 68] = mem[_4977 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5184 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5184 + -mem[64] + 100
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
                        else:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _3483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3483] = 30
                                mem[_3483 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _3540 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3540 + 68] = mem[_3483 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3540 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3540 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _3839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3839] = 30
                                mem[_3839 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _3958 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3958 + 68] = mem[_3839 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3958 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3958 + -mem[64] + 100
                            _3484 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3484] = 26
                            mem[_3484 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3541 + 68] = mem[_3484 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3541 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3541 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 6
                                _4012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4012] = 30
                                mem[_4012 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    _4114 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4114 + 68] = mem[_4012 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4114 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4114 + -mem[64] + 100
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor6[address(msg.sender)] -= arg2
                                mem[32] = 5
                                _4550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4550] = 30
                                mem[_4550 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(msg.sender)]:
                                    _4741 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4741 + 68] = mem[_4550 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4741 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4741 + -mem[64] + 100
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 6
                                _4405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4405] = 30
                                mem[_4405 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    _4549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4549 + 68] = mem[_4405 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4549 + -mem[64] + 100
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor6[address(msg.sender)] -= arg2
                                mem[32] = 5
                                _5186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5186] = 30
                                mem[_5186 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    _5322 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5322 + 68] = mem[_5186 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5322 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5322 + -mem[64] + 100
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if arg2 > stor6[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor6[address(msg.sender)] -= arg2
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 > stor6[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor6[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * t / s
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * t / s
                    else:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if arg2 > stor6[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor6[address(msg.sender)] -= arg2
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 > stor6[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor6[address(msg.sender)] -= arg2
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * stor16 / totalSupply
        else:
            mem[0] = arg1
            mem[32] = 11
            if stor11[address(arg1)]:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _3426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3426] = 26
                        mem[_3426 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _3498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3498 + 68] = mem[_3426 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3498 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3498 + -mem[64] + 100
                        if not arg2:
                            mem[0] = msg.sender
                            mem[32] = 5
                            _3965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3965] = 30
                            mem[_3965 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(msg.sender)]:
                                _4030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4030 + 68] = mem[_3965 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4030 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4030 + -mem[64] + 100
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4261] = 30
                            mem[_4261 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                _4428 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4428 + 68] = mem[_4261 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4428 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4428 + -mem[64] + 100
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * stor16 / totalSupply
                    else:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _3499 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3499] = 30
                            mem[_3499 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _3552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3552 + 68] = mem[_3499 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3552 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3552 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _3851 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3851] = 30
                            mem[_3851 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _3966 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3966 + 68] = mem[_3851 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3966 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3966 + -mem[64] + 100
                        _3500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3500] = 26
                        mem[_3500 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _3553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3553 + 68] = mem[_3500 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3553 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3553 + -mem[64] + 100
                        if not arg2:
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4032] = 30
                            mem[_4032 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(msg.sender)]:
                                _4130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4130 + 68] = mem[_4032 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4130 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4130 + -mem[64] + 100
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4430 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4430] = 30
                            mem[_4430 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                _4580 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4580 + 68] = mem[_4430 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4580 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4580 + -mem[64] + 100
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * stor16 / totalSupply
                    emit Transfer(arg2, msg.sender, arg1);
                    return 1
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if 0 > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor6[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg1)] += arg2
                        if stor5[address(arg1)] > -1:
                            revert with 0, 17
                        if stor5[address(arg1)] < stor5[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * t / s > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < arg2 * t / s:
                            revert with 0, 17
                        stor5[address(msg.sender)] += -1 * arg2 * t / s
                        if stor6[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg1)] += arg2
                        if stor5[address(arg1)] > !(arg2 * t / s):
                            revert with 0, 17
                        if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] += arg2 * t / s
                else:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if 0 > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor6[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg1)] += arg2
                        if stor5[address(arg1)] > -1:
                            revert with 0, 17
                        if stor5[address(arg1)] < stor5[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 and stor16 / totalSupply > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                        if stor6[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg1)] += arg2
                        if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] += arg2 * stor16 / totalSupply
            else:
                mem[0] = msg.sender
                mem[32] = 11
                if not stor11[address(msg.sender)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _3420 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3420] = 26
                            mem[_3420 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3486 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3486 + 68] = mem[_3420 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3486 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3486 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _3959 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3959] = 30
                                mem[_3959 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4015 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4015 + 68] = mem[_3959 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4015 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4015 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4243 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4243] = 30
                            mem[_4243 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4409 + 68] = mem[_4243 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4409 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] > s:
                            _3488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3488] = 26
                            mem[_3488 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3544 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3544 + 68] = mem[_3488 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3544 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3544 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4017 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4017] = 30
                                mem[_4017 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4118 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4118 + 68] = mem[_4017 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4118 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4118 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4411] = 30
                            mem[_4411 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4557 + 68] = mem[_4411 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4557 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4557 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _3487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3487] = 30
                        mem[_3487 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _3543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3543 + 68] = mem[_3487 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3543 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _3842 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3842] = 30
                        mem[_3842 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _3960 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3960 + 68] = mem[_3842 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3960 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3960 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * t / s > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * t / s
                            if stor5[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                    else:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                else:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _3422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3422] = 26
                                mem[_3422 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3490 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3490 + 68] = mem[_3422 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3490 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3490 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _3961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3961] = 30
                                    mem[_3961 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4020 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4020 + 68] = mem[_3961 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4020 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4020 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4249] = 30
                                mem[_4249 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4415 + 68] = mem[_4249 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4415 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4415 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] > s:
                                _3492 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3492] = 26
                                mem[_3492 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3547 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3547 + 68] = mem[_3492 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3547 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3547 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _4022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4022] = 30
                                    mem[_4022 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4122 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4122 + 68] = mem[_4022 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4122 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4122 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4417] = 30
                                mem[_4417 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4564 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4564 + 68] = mem[_4417 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4564 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4564 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _3491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3491] = 30
                            mem[_3491 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _3546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3546 + 68] = mem[_3491 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3546 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3546 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _3845 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3845] = 30
                            mem[_3845 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _3962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3962 + 68] = mem[_3845 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3962 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3962 + -mem[64] + 100
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * t / s > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * t / s
                                if stor5[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                        else:
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                    else:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _3424 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3424] = 26
                                mem[_3424 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3494 + 68] = mem[_3424 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3494 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3494 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _3963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3963] = 30
                                    mem[_3963 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4025 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4025 + 68] = mem[_3963 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4025 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4025 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _4422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4422] = 30
                                    mem[_4422 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(msg.sender)]:
                                        _4570 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4570 + 68] = mem[_4422 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4570 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4570 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4255] = 30
                                    mem[_4255 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4421 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4421 + 68] = mem[_4255 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4421 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4421 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _4995 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4995] = 30
                                    mem[_4995 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        _5206 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5206 + 68] = mem[_4995 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5206 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5206 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * stor16 / totalSupply
                            else:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _3495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3495] = 30
                                    mem[_3495 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _3549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3549 + 68] = mem[_3495 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3549 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3549 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _3848 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3848] = 30
                                    mem[_3848 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _3964 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3964 + 68] = mem[_3848 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3964 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3964 + -mem[64] + 100
                                _3496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3496] = 26
                                mem[_3496 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3550 + 68] = mem[_3496 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3550 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3550 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4027] = 30
                                    mem[_4027 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4126 + 68] = mem[_4027 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4126 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4126 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _4573 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4573] = 30
                                    mem[_4573 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(msg.sender)]:
                                        _4766 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4766 + 68] = mem[_4573 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4766 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4766 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4424] = 30
                                    mem[_4424 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4572 + 68] = mem[_4424 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4572 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4572 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _5208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5208] = 30
                                    mem[_5208 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        _5342 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5342 + 68] = mem[_5208 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5342 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5342 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * stor16 / totalSupply
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if arg2 * t / s > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * t / s
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * t / s
                        else:
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
    else:
        mem[0] = arg1
        mem[32] = 11
        if not stor11[address(arg1)]:
            idx = 0
            s = totalSupply
            t = stor16
            while idx < stor12.length:
                mem[0] = stor12[idx]
                mem[32] = 5
                if stor5[stor12[idx]] > t:
                    _3442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3442] = 26
                    mem[_3442 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _3530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3530 + 68] = mem[_3442 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3530 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3530 + -mem[64] + 100
                    if not arg2:
                        mem[0] = msg.sender
                        mem[32] = 6
                        _3981 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3981] = 30
                        mem[_3981 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor6[address(msg.sender)]:
                            _4070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4070 + 68] = mem[_3981 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4070 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4070 + -mem[64] + 100
                        if stor6[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor6[address(msg.sender)] -= arg2
                        mem[32] = 5
                        _4479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4479] = 30
                        mem[_4479 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor5[address(msg.sender)]:
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _4639 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4639 + 68] = mem[_4479 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4639 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4639 + -mem[64] + 100
                    if arg2 and stor16 / totalSupply > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = msg.sender
                    mem[32] = 6
                    _4309 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4309] = 30
                    mem[_4309 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor6[address(msg.sender)]:
                        _4478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4478 + 68] = mem[_4309 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4478 + -mem[64] + 100
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor6[address(msg.sender)] -= arg2
                    mem[32] = 5
                    _5047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5047] = 30
                    mem[_5047 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                        if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _5270 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5270 + 68] = mem[_5047 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5270 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5270 + -mem[64] + 100
                if idx >= stor12.length:
                    revert with 0, 50
                mem[0] = stor12[idx]
                mem[32] = 6
                if stor6[stor12[idx]] <= s:
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    _3531 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3531] = 30
                    mem[_3531 + 32] = 'SafeMath: subtraction overflow'
                    if stor5[stor12[idx]] > t:
                        _3576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3576 + 68] = mem[_3531 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3576 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3576 + -mem[64] + 100
                    if t < stor5[stor12[idx]]:
                        revert with 0, 17
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    _3875 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3875] = 30
                    mem[_3875 + 32] = 'SafeMath: subtraction overflow'
                    if stor6[stor12[idx]] <= s:
                        if s < stor6[stor12[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor6[stor12[idx]]
                        t = t - stor5[stor12[idx]]
                        continue 
                    _3982 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3982 + 68] = mem[_3875 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3982 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3982 + -mem[64] + 100
                _3532 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3532] = 26
                mem[_3532 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _3577 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3577 + 68] = mem[_3532 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3577 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3577 + -mem[64] + 100
                if not arg2:
                    mem[0] = msg.sender
                    mem[32] = 6
                    _4072 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4072] = 30
                    mem[_4072 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor6[address(msg.sender)]:
                        _4162 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4162 + 68] = mem[_4072 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4162 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4162 + -mem[64] + 100
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor6[address(msg.sender)] -= arg2
                    mem[32] = 5
                    _4642 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4642] = 30
                    mem[_4642 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor5[address(msg.sender)]:
                        if stor5[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor5[arg1] > -1:
                            revert with 0, 17
                        if stor5[arg1] < stor5[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor5[address(arg1)] = stor5[arg1]
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _4841 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4841 + 68] = mem[_4642 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4841 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4841 + -mem[64] + 100
                if arg2 and stor16 / totalSupply > -1 / arg2:
                    revert with 0, 17
                if not arg2:
                    revert with 0, 18
                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[0] = msg.sender
                mem[32] = 6
                _4481 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4481] = 30
                mem[_4481 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor6[address(msg.sender)]:
                    _4641 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4641 + 68] = mem[_4481 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4641 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4641 + -mem[64] + 100
                if stor6[address(msg.sender)] < arg2:
                    revert with 0, 17
                mem[0] = msg.sender
                stor6[address(msg.sender)] -= arg2
                mem[32] = 5
                _5272 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5272] = 30
                mem[_5272 + 32] = 'SafeMath: subtraction overflow'
                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                    emit Transfer(arg2, msg.sender, arg1);
                    return 1
                _5404 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5404 + 68] = mem[_5272 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5404 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5404 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor16 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg2:
                    if arg2 > stor6[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    stor6[address(msg.sender)] -= arg2
                    if 0 > stor5[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(msg.sender)] < 0:
                        revert with 0, 17
                    if stor5[arg1] > -1:
                        revert with 0, 17
                    if stor5[arg1] < stor5[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(arg1)] = stor5[arg1]
                else:
                    if arg2 and t / s > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * t / s / arg2 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg2 > stor6[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    stor6[address(msg.sender)] -= arg2
                    if arg2 * t / s > stor5[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(msg.sender)] < arg2 * t / s:
                        revert with 0, 17
                    stor5[address(msg.sender)] += -1 * arg2 * t / s
                    if stor5[arg1] > !(arg2 * t / s):
                        revert with 0, 17
                    if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
            else:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg2:
                    if arg2 > stor6[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    stor6[address(msg.sender)] -= arg2
                    if 0 > stor5[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(msg.sender)] < 0:
                        revert with 0, 17
                    if stor5[arg1] > -1:
                        revert with 0, 17
                    if stor5[arg1] < stor5[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(arg1)] = stor5[arg1]
                else:
                    if arg2 and stor16 / totalSupply > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg2 > stor6[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(msg.sender)] < arg2:
                        revert with 0, 17
                    stor6[address(msg.sender)] -= arg2
                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
        else:
            if stor11[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 11
                if not stor11[address(msg.sender)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _3428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3428] = 26
                            mem[_3428 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3502 + 68] = mem[_3428 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3502 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3502 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _3967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3967] = 30
                                mem[_3967 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4035 + 68] = mem[_3967 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4035 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4035 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4267] = 30
                            mem[_4267 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4434 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4434 + 68] = mem[_4267 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4434 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4434 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] > s:
                            _3504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3504] = 26
                            mem[_3504 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3556 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3556 + 68] = mem[_3504 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3556 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3556 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4037 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4037] = 30
                                mem[_4037 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4134 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4134 + 68] = mem[_4037 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4134 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4134 + -mem[64] + 100
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = msg.sender
                            mem[32] = 5
                            _4436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4436] = 30
                            mem[_4436 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _4587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4587 + 68] = mem[_4436 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4587 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4587 + -mem[64] + 100
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _3503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3503] = 30
                        mem[_3503 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _3555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3555 + 68] = mem[_3503 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3555 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3555 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _3854 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3854] = 30
                        mem[_3854 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _3968 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3968 + 68] = mem[_3854 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3968 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3968 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * t / s > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * t / s
                            if stor5[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                    else:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor5[arg1] > -1:
                                revert with 0, 17
                            if stor5[arg1] < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1]
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                else:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _3430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3430] = 26
                                mem[_3430 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3506 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3506 + 68] = mem[_3430 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3506 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3506 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _3969 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3969] = 30
                                    mem[_3969 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4040 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4040 + 68] = mem[_3969 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4040 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4040 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4273] = 30
                                mem[_4273 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4440 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4440 + 68] = mem[_4273 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4440 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4440 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] > s:
                                _3508 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3508] = 26
                                mem[_3508 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3559 + 68] = mem[_3508 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3559 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3559 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _4042 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4042] = 30
                                    mem[_4042 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4138 + 68] = mem[_4042 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4138 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4138 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4442] = 30
                                mem[_4442 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4594 + 68] = mem[_4442 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4594 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _3507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3507] = 30
                            mem[_3507 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _3558 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3558 + 68] = mem[_3507 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3558 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3558 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _3857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3857] = 30
                            mem[_3857 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _3970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3970 + 68] = mem[_3857 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3970 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3970 + -mem[64] + 100
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * t / s > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * t / s
                                if stor5[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                        else:
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                    else:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _3432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3432] = 26
                                mem[_3432 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3510 + 68] = mem[_3432 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3510 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3510 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _3971 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3971] = 30
                                    mem[_3971 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4045 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4045 + 68] = mem[_3971 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4045 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4045 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _4447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4447] = 30
                                    mem[_4447 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(msg.sender)]:
                                        _4600 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4600 + 68] = mem[_4447 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4600 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4600 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4279] = 30
                                    mem[_4279 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4446 + 68] = mem[_4279 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4446 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4446 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _5017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5017] = 30
                                    mem[_5017 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        _5233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5233 + 68] = mem[_5017 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5233 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5233 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * stor16 / totalSupply
                            else:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _3511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3511] = 30
                                    mem[_3511 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _3561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3561 + 68] = mem[_3511 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3561 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3561 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _3860 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3860] = 30
                                    mem[_3860 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _3972 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3972 + 68] = mem[_3860 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3972 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3972 + -mem[64] + 100
                                _3512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3512] = 26
                                mem[_3512 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3562 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3562 + 68] = mem[_3512 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3562 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3562 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4047 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4047] = 30
                                    mem[_4047 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4142 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4142 + 68] = mem[_4047 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4142 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4142 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _4603 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4603] = 30
                                    mem[_4603 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(msg.sender)]:
                                        _4799 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4799 + 68] = mem[_4603 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4799 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4799 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 6
                                    _4449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4449] = 30
                                    mem[_4449 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        _4602 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4602 + 68] = mem[_4449 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4602 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4602 + -mem[64] + 100
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    stor6[address(msg.sender)] -= arg2
                                    mem[32] = 5
                                    _5235 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5235] = 30
                                    mem[_5235 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        _5369 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5369 + 68] = mem[_5235 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5369 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5369 + -mem[64] + 100
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * stor16 / totalSupply
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if arg2 * t / s > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * t / s
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * t / s
                        else:
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 > stor6[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                stor6[address(msg.sender)] -= arg2
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
            else:
                mem[0] = arg1
                mem[32] = 11
                if stor11[address(arg1)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _3440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3440] = 26
                            mem[_3440 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3526 + 68] = mem[_3440 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3526 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3526 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _3979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3979] = 30
                                mem[_3979 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(msg.sender)]:
                                    _4065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4065 + 68] = mem[_3979 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4065 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4065 + -mem[64] + 100
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4303] = 30
                                mem[_4303 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    _4472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4472 + 68] = mem[_4303 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4472 + -mem[64] + 100
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
                        else:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _3527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3527] = 30
                                mem[_3527 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _3573 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3573 + 68] = mem[_3527 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3573 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3573 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _3872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3872] = 30
                                mem[_3872 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _3980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3980 + 68] = mem[_3872 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3980 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3980 + -mem[64] + 100
                            _3528 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3528] = 26
                            mem[_3528 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _3574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3574 + 68] = mem[_3528 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3574 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3574 + -mem[64] + 100
                            if not arg2:
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4067 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4067] = 30
                                mem[_4067 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(msg.sender)]:
                                    _4158 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4158 + 68] = mem[_4067 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4158 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4158 + -mem[64] + 100
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg1)] < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4474] = 30
                                mem[_4474 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    _4633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4633 + 68] = mem[_4474 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4633 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4633 + -mem[64] + 100
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor6[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg1)] += arg2
                                if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] += arg2 * stor16 / totalSupply
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * t / s > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * t / s
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * t / s
                    else:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > -1:
                                revert with 0, 17
                            if stor5[address(arg1)] < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor16 / totalSupply > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                            if stor6[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg1)] += arg2
                            if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor5[address(arg1)] += arg2 * stor16 / totalSupply
                else:
                    mem[0] = msg.sender
                    mem[32] = 11
                    if not stor11[address(msg.sender)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _3434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3434] = 26
                                mem[_3434 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3514 + 68] = mem[_3434 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3514 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3514 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _3973 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3973] = 30
                                    mem[_3973 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4050 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4050 + 68] = mem[_3973 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4050 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4050 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4285] = 30
                                mem[_4285 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4453 + 68] = mem[_4285 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4453 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4453 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] > s:
                                _3516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3516] = 26
                                mem[_3516 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _3565 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3565 + 68] = mem[_3516 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3565 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3565 + -mem[64] + 100
                                if not arg2:
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _4052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4052] = 30
                                    mem[_4052 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor5[arg1] > -1:
                                            revert with 0, 17
                                        if stor5[arg1] < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1]
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4146 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4146 + 68] = mem[_4052 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4146 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4146 + -mem[64] + 100
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = msg.sender
                                mem[32] = 5
                                _4455 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4455] = 30
                                mem[_4455 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _4610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4610 + 68] = mem[_4455 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4610 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4610 + -mem[64] + 100
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _3515 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3515] = 30
                            mem[_3515 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _3564 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3564 + 68] = mem[_3515 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3564 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3564 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _3863 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3863] = 30
                            mem[_3863 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _3974 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3974 + 68] = mem[_3863 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3974 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3974 + -mem[64] + 100
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * t / s > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * t / s
                                if stor5[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                        else:
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor5[arg1] > -1:
                                    revert with 0, 17
                                if stor5[arg1] < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1]
                            else:
                                if arg2 and stor16 / totalSupply > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                    else:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _3436 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3436] = 26
                                    mem[_3436 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _3518 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3518 + 68] = mem[_3436 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3518 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3518 + -mem[64] + 100
                                    if not arg2:
                                        mem[0] = msg.sender
                                        mem[32] = 5
                                        _3975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3975] = 30
                                        mem[_3975 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor5[address(msg.sender)]:
                                            if stor5[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor5[arg1] > -1:
                                                revert with 0, 17
                                            if stor5[arg1] < stor5[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor5[address(arg1)] = stor5[arg1]
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _4055 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4055 + 68] = mem[_3975 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4055 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4055 + -mem[64] + 100
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _4291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4291] = 30
                                    mem[_4291 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                        if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4459 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4459 + 68] = mem[_4291 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4459 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4459 + -mem[64] + 100
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] > s:
                                    _3520 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3520] = 26
                                    mem[_3520 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _3568 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3568 + 68] = mem[_3520 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3568 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3568 + -mem[64] + 100
                                    if not arg2:
                                        mem[0] = msg.sender
                                        mem[32] = 5
                                        _4057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4057] = 30
                                        mem[_4057 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor5[address(msg.sender)]:
                                            if stor5[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor5[arg1] > -1:
                                                revert with 0, 17
                                            if stor5[arg1] < stor5[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor5[address(arg1)] = stor5[arg1]
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _4150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4150 + 68] = mem[_4057 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4150 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4150 + -mem[64] + 100
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 5
                                    _4461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4461] = 30
                                    mem[_4461 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor16 / totalSupply <= stor5[address(msg.sender)]:
                                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                        if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _4617 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4617 + 68] = mem[_4461 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4617 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4617 + -mem[64] + 100
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _3519 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3519] = 30
                                mem[_3519 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _3567 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3567 + 68] = mem[_3519 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3567 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3567 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _3866 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3866] = 30
                                mem[_3866 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _3976 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3976 + 68] = mem[_3866 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3976 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3976 + -mem[64] + 100
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg2 * t / s > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor5[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * t / s) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * t / s)
                            else:
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor5[arg1] > -1:
                                        revert with 0, 17
                                    if stor5[arg1] < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1]
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor5[arg1] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg1] + (arg2 * stor16 / totalSupply) < stor5[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] = stor5[arg1] + (arg2 * stor16 / totalSupply)
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _3438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3438] = 26
                                    mem[_3438 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _3522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3522 + 68] = mem[_3438 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3522 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3522 + -mem[64] + 100
                                    if not arg2:
                                        mem[0] = msg.sender
                                        mem[32] = 6
                                        _3977 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3977] = 30
                                        mem[_3977 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor6[address(msg.sender)]:
                                            _4060 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4060 + 68] = mem[_3977 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4060 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4060 + -mem[64] + 100
                                        if stor6[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        stor6[address(msg.sender)] -= arg2
                                        mem[32] = 5
                                        _4466 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4466] = 30
                                        mem[_4466 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(msg.sender)]:
                                            _4623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4623 + 68] = mem[_4466 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4623 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4623 + -mem[64] + 100
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg1)] > !arg2:
                                            revert with 0, 17
                                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg1)] += arg2
                                        if stor5[address(arg1)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg1)] < stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and stor16 / totalSupply > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 6
                                        _4297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4297] = 30
                                        mem[_4297 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor6[address(msg.sender)]:
                                            _4465 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4465 + 68] = mem[_4297 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4465 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4465 + -mem[64] + 100
                                        if stor6[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        stor6[address(msg.sender)] -= arg2
                                        mem[32] = 5
                                        _5035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5035] = 30
                                        mem[_5035 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                            _5255 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _5255 + 68] = mem[_5035 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5255 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5255 + -mem[64] + 100
                                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                        if stor6[address(arg1)] > !arg2:
                                            revert with 0, 17
                                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg1)] += arg2
                                        if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] += arg2 * stor16 / totalSupply
                                else:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _3523 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3523] = 30
                                        mem[_3523 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _3570 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _3570 + 68] = mem[_3523 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3570 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _3570 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _3869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3869] = 30
                                        mem[_3869 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _3978 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3978 + 68] = mem[_3869 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3978 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3978 + -mem[64] + 100
                                    _3524 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3524] = 26
                                    mem[_3524 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _3571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3571 + 68] = mem[_3524 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3571 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3571 + -mem[64] + 100
                                    if not arg2:
                                        mem[0] = msg.sender
                                        mem[32] = 6
                                        _4062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4062] = 30
                                        mem[_4062 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor6[address(msg.sender)]:
                                            _4154 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4154 + 68] = mem[_4062 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4154 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4154 + -mem[64] + 100
                                        if stor6[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        stor6[address(msg.sender)] -= arg2
                                        mem[32] = 5
                                        _4626 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4626] = 30
                                        mem[_4626 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(msg.sender)]:
                                            _4824 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4824 + 68] = mem[_4626 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4824 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4824 + -mem[64] + 100
                                        if stor5[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg1)] > !arg2:
                                            revert with 0, 17
                                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg1)] += arg2
                                        if stor5[address(arg1)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg1)] < stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and stor16 / totalSupply > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 6
                                        _4468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4468] = 30
                                        mem[_4468 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor6[address(msg.sender)]:
                                            _4625 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _4625 + 68] = mem[_4468 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_4625 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _4625 + -mem[64] + 100
                                        if stor6[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        stor6[address(msg.sender)] -= arg2
                                        mem[32] = 5
                                        _5257 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5257] = 30
                                        mem[_5257 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                            _5389 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _5389 + 68] = mem[_5257 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5389 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5389 + -mem[64] + 100
                                        if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                        if stor6[address(arg1)] > !arg2:
                                            revert with 0, 17
                                        if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg1)] += arg2
                                        if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor5[address(arg1)] += arg2 * stor16 / totalSupply
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if arg2 > stor6[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    stor6[address(msg.sender)] -= arg2
                                    if 0 > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    stor6[address(msg.sender)] -= arg2
                                    if arg2 * t / s > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * t / s) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * t / s
                            else:
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if arg2 > stor6[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    stor6[address(msg.sender)] -= arg2
                                    if 0 > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg1)] < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor16 / totalSupply > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor16 / totalSupply / arg2 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg2 > stor6[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    stor6[address(msg.sender)] -= arg2
                                    if arg2 * stor16 / totalSupply > stor5[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(msg.sender)] < arg2 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(msg.sender)] += -1 * arg2 * stor16 / totalSupply
                                    if stor6[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor6[address(arg1)] + arg2 < stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg1)] += arg2
                                    if stor5[address(arg1)] > !(arg2 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg1)] + (arg2 * stor16 / totalSupply) < stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor5[address(arg1)] += arg2 * stor16 / totalSupply
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg3 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor11[address(arg1)]:
        if stor11[address(arg1)]:
            mem[0] = arg1
            mem[32] = 11
            if not stor11[address(arg1)]:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5334] = 26
                        mem[_5334 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5394 + 68] = mem[_5334 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5394 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5394 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5873 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5873] = 30
                            mem[_5873 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _5920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5920 + 68] = mem[_5873 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5920 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7194 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7194] = 40
                            mem[_7194 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _7530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _7530 + 68] = mem[_7194 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7530 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _7530 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6145] = 30
                        mem[_6145 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6310 + 68] = mem[_6145 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6310 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _7813 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_7813] = 40
                        mem[_7813 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8104 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8104 + 68] = mem[_7813 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8104 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8104 + -mem[64] + 132
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _5395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5395] = 30
                        mem[_5395 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _5454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5454 + 68] = mem[_5395 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5454 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _5753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5753] = 30
                        mem[_5753 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _5874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5874 + 68] = mem[_5753 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5874 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5874 + -mem[64] + 100
                    _5396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5396] = 26
                    mem[_5396 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5455 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5455 + 68] = mem[_5396 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5455 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5455 + -mem[64] + 100
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _5922 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5922] = 30
                        mem[_5922 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            _6026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6026 + 68] = mem[_5922 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6026 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6026 + -mem[64] + 100
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _7363 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_7363] = 40
                        mem[_7363 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _7736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _7736 + 68] = mem[_7363 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7736 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _7736 + -mem[64] + 132
                    if arg3 and stor16 / totalSupply > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 5
                    _6312 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6312] = 30
                    mem[_6312 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                        _6454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6454 + 68] = mem[_6312 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6454 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6454 + -mem[64] + 100
                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                    emit Transfer(arg3, arg1, arg2);
                    _8001 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8001] = 40
                    mem[_8001 + 32 len 40] = code.data[20398 len 40]
                    mem[32] = sha3(address(arg1), 7)
                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] -= arg3
                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                        return 1
                    _8357 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _8357 + 68] = mem[_8001 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8357 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _8357 + -mem[64] + 132
                _5243 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5243] = 26
                mem[_5243 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    _5513 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5513] = 26
                    mem[_5513 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _6143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6143] = 30
                        mem[_6143 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _7809 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_7809] = 40
                        mem[_7809 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7809 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and t / s > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * t / s / arg3 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6638] = 30
                        mem[_6638 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * t / s > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * t / s:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * t / s
                        if stor5[arg2] > !(arg3 * t / s):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                        emit Transfer(arg3, arg1, arg2);
                        _8432 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8432] = 40
                        mem[_8432 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8432 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    _5514 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5514] = 26
                    mem[_5514 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _6144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6144] = 30
                        mem[_6144 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _7811 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_7811] = 40
                        mem[_7811 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7811 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6640 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6640] = 30
                        mem[_6640 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _8434 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8434] = 40
                        mem[_8434 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8434 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 11
                if not stor11[address(arg2)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _5336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5336] = 26
                            mem[_5336 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5398 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5398 + 68] = mem[_5336 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5398 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5398 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5875 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5875] = 30
                                mem[_5875 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _5925 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5925 + 68] = mem[_5875 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5925 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5925 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7197 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7197] = 40
                                mem[_7197 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7536 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7536 + 68] = mem[_7197 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7536 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7536 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6151] = 30
                            mem[_6151 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6316 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6316 + 68] = mem[_6151 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6316 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6316 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _7819 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7819] = 40
                            mem[_7819 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8112 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8112 + 68] = mem[_7819 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8112 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8112 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5399 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5399] = 30
                            mem[_5399 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5457 + 68] = mem[_5399 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5457 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5457 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5756] = 30
                            mem[_5756 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5876 + 68] = mem[_5756 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5876 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5876 + -mem[64] + 100
                        _5400 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5400] = 26
                        mem[_5400 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5458 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5458 + 68] = mem[_5400 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5458 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5458 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5927 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5927] = 30
                            mem[_5927 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _6030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6030 + 68] = mem[_5927 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6030 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6030 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7378 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7378] = 40
                            mem[_7378 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _7741 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _7741 + 68] = mem[_7378 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7741 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _7741 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6318] = 30
                        mem[_6318 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6461 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6461 + 68] = mem[_6318 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6461 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6461 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _8009 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8009] = 40
                        mem[_8009 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8364 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8364 + 68] = mem[_8009 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8364 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8364 + -mem[64] + 132
                    _5246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5246] = 26
                    mem[_5246 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _5519 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5519] = 26
                        mem[_5519 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6149] = 30
                            mem[_6149 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7815 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7815] = 40
                            mem[_7815 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7815 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6646 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6646] = 30
                            mem[_6646 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _8444 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8444] = 40
                            mem[_8444 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8444 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _5520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5520] = 26
                        mem[_5520 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6150] = 30
                            mem[_6150 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7817 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7817] = 40
                            mem[_7817 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7817 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6648 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6648] = 30
                            mem[_6648 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8446 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8446] = 40
                            mem[_8446 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8446 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _5338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5338] = 26
                            mem[_5338 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5402 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5402 + 68] = mem[_5338 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5402 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5402 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _5877 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5877] = 30
                                mem[_5877 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _5930 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5930 + 68] = mem[_5877 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5930 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5930 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6323] = 30
                                mem[_6323 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6467 + 68] = mem[_6323 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6467 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6467 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _8682 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8682] = 40
                                mem[_8682 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9100 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9100 + 68] = mem[_8682 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9100 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9100 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _6157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6157] = 30
                            mem[_6157 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _6322 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6322 + 68] = mem[_6157 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6322 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6322 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _6897 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6897] = 30
                            mem[_6897 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _7104 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7104 + 68] = mem[_6897 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7104 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7104 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _9419 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9419] = 40
                            mem[_9419 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _9733 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _9733 + 68] = mem[_9419 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9733 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _9733 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5403] = 30
                            mem[_5403 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5460 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5460 + 68] = mem[_5403 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5460 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5460 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5759] = 30
                            mem[_5759 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5878 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5878 + 68] = mem[_5759 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5878 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5878 + -mem[64] + 100
                        _5404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5404] = 26
                        mem[_5404 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5461 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5461 + 68] = mem[_5404 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5461 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5461 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _5932 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5932] = 30
                            mem[_5932 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _6034 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6034 + 68] = mem[_5932 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6034 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6034 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _6470 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6470] = 30
                            mem[_6470 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _6661 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6661 + 68] = mem[_6470 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6661 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6661 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _8878 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8878] = 40
                            mem[_8878 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _9336 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _9336 + 68] = mem[_8878 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9336 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _9336 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _6325 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6325] = 30
                        mem[_6325 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _6469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6469 + 68] = mem[_6325 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6469 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6469 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _7106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7106] = 30
                        mem[_7106 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _7260 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7260 + 68] = mem[_7106 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7260 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _7260 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                        emit Transfer(arg3, arg1, arg2);
                        _9568 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_9568] = 40
                        mem[_9568 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _9904 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _9904 + 68] = mem[_9568 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9904 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _9904 + -mem[64] + 132
                    _5249 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5249] = 26
                    mem[_5249 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _5525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5525] = 26
                        mem[_5525 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _6155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6155] = 30
                            mem[_6155 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _6894 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6894] = 30
                            mem[_6894 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _9415 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9415] = 40
                            mem[_9415 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9415 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _6654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6654] = 30
                            mem[_6654 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _7539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7539] = 30
                            mem[_7539 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * t / s
                            emit Transfer(arg3, arg1, arg2);
                            _9962 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9962] = 40
                            mem[_9962 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9962 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _5526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5526] = 26
                        mem[_5526 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _6156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6156] = 30
                            mem[_6156 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _6896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6896] = 30
                            mem[_6896 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _9417 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9417] = 40
                            mem[_9417 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9417 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _6656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6656] = 30
                            mem[_6656 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _7541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7541] = 30
                            mem[_7541 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _9964 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9964] = 40
                            mem[_9964 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9964 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            mem[0] = arg2
            mem[32] = 11
            if stor11[address(arg2)]:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _5346 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5346] = 26
                        mem[_5346 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5418 + 68] = mem[_5346 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5418 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5418 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5885 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5885] = 30
                            mem[_5885 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _5950 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5950 + 68] = mem[_5885 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5950 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5950 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _7849 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7849] = 40
                            mem[_7849 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8149 + 68] = mem[_7849 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8149 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8149 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6181 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6181] = 30
                        mem[_6181 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6348 + 68] = mem[_6181 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6348 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6348 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                        emit Transfer(arg3, arg1, arg2);
                        _8500 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8500] = 40
                        mem[_8500 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8762 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8762 + 68] = mem[_8500 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8762 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8762 + -mem[64] + 132
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _5419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5419] = 30
                        mem[_5419 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _5472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5472 + 68] = mem[_5419 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5472 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5472 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _5771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5771] = 30
                        mem[_5771 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _5886 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5886 + 68] = mem[_5771 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5886 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5886 + -mem[64] + 100
                    _5420 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5420] = 26
                    mem[_5420 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5473 + 68] = mem[_5420 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5473 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5473 + -mem[64] + 100
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _5952 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5952] = 30
                        mem[_5952 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            _6050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6050 + 68] = mem[_5952 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6050 + -mem[64] + 100
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > -1:
                            revert with 0, 17
                        if stor5[address(arg2)] < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        emit Transfer(arg3, arg1, arg2);
                        _8044 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8044] = 40
                        mem[_8044 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8388 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8388 + 68] = mem[_8044 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8388 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8388 + -mem[64] + 132
                    if arg3 and stor16 / totalSupply > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 5
                    _6350 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6350] = 30
                    mem[_6350 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                        _6500 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6500 + 68] = mem[_6350 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6500 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6500 + -mem[64] + 100
                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                    if stor6[address(arg2)] > !arg3:
                        revert with 0, 17
                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor6[address(arg2)] += arg3
                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                    emit Transfer(arg3, arg1, arg2);
                    _8694 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8694] = 40
                    mem[_8694 + 32 len 40] = code.data[20398 len 40]
                    mem[32] = sha3(address(arg1), 7)
                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] -= arg3
                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                        return 1
                    _9132 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _9132 + 68] = mem[_8694 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9132 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _9132 + -mem[64] + 132
                _5261 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5261] = 26
                mem[_5261 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    _5549 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5549] = 26
                    mem[_5549 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _6179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6179] = 30
                        mem[_6179 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > -1:
                            revert with 0, 17
                        if stor5[address(arg2)] < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        emit Transfer(arg3, arg1, arg2);
                        _8496 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8496] = 40
                        mem[_8496 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8496 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and t / s > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * t / s / arg3 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6688] = 30
                        mem[_6688 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * t / s > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * t / s:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * t / s
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * t / s):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * t / s
                        emit Transfer(arg3, arg1, arg2);
                        _9243 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_9243] = 40
                        mem[_9243 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9243 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    _5550 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5550] = 26
                    mem[_5550 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 5
                        _6180 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6180] = 30
                        mem[_6180 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > -1:
                            revert with 0, 17
                        if stor5[address(arg2)] < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        emit Transfer(arg3, arg1, arg2);
                        _8498 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8498] = 40
                        mem[_8498 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8498 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6690 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6690] = 30
                        mem[_6690 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                        emit Transfer(arg3, arg1, arg2);
                        _9245 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_9245] = 40
                        mem[_9245 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9245 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg1
                mem[32] = 11
                if not stor11[address(arg1)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _5340 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5340] = 26
                            mem[_5340 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5406 + 68] = mem[_5340 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5406 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5406 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5879 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5879] = 30
                                mem[_5879 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _5935 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5935 + 68] = mem[_5879 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5935 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5935 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7204 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7204] = 40
                                mem[_7204 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7550 + 68] = mem[_7204 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7550 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7550 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6163] = 30
                            mem[_6163 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6329 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6329 + 68] = mem[_6163 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6329 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6329 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _7833 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7833] = 40
                            mem[_7833 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8127 + 68] = mem[_7833 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8127 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8127 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5407] = 30
                            mem[_5407 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5463 + 68] = mem[_5407 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5463 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5762] = 30
                            mem[_5762 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5880 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5880 + 68] = mem[_5762 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5880 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5880 + -mem[64] + 100
                        _5408 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5408] = 26
                        mem[_5408 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5464 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5464 + 68] = mem[_5408 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5464 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5464 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5937 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5937] = 30
                            mem[_5937 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _6038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6038 + 68] = mem[_5937 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6038 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6038 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7398 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7398] = 40
                            mem[_7398 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _7752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _7752 + 68] = mem[_7398 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7752 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _7752 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6331] = 30
                        mem[_6331 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6477 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6477 + 68] = mem[_6331 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6477 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6477 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _8018 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8018] = 40
                        mem[_8018 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8374 + 68] = mem[_8018 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8374 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8374 + -mem[64] + 132
                    _5252 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5252] = 26
                    mem[_5252 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _5531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5531] = 26
                        mem[_5531 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6161 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6161] = 30
                            mem[_6161 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7829 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7829] = 40
                            mem[_7829 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7829 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6663] = 30
                            mem[_6663 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _8464 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8464] = 40
                            mem[_8464 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8464 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _5532 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5532] = 26
                        mem[_5532 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6162 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6162] = 30
                            mem[_6162 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7831 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7831] = 40
                            mem[_7831 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7831 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6665] = 30
                            mem[_6665 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8466 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8466] = 40
                            mem[_8466 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8466 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if not stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _5342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5342] = 26
                                mem[_5342 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5410 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5410 + 68] = mem[_5342 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5410 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5410 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _5881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5881] = 30
                                    mem[_5881 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _5940 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5940 + 68] = mem[_5881 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5940 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5940 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7207 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7207] = 40
                                    mem[_7207 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _7556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _7556 + 68] = mem[_7207 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7556 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7556 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6169] = 30
                                mem[_6169 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _6335 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6335 + 68] = mem[_6169 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6335 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6335 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _7839 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7839] = 40
                                mem[_7839 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _8135 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _8135 + 68] = mem[_7839 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8135 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _8135 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _5411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5411] = 30
                                mem[_5411 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _5466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5466 + 68] = mem[_5411 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5466 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5466 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _5765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5765] = 30
                                mem[_5765 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _5882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5882 + 68] = mem[_5765 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5882 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5882 + -mem[64] + 100
                            _5412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5412] = 26
                            mem[_5412 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5467 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5467 + 68] = mem[_5412 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5467 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5467 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5942 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5942] = 30
                                mem[_5942 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6042 + 68] = mem[_5942 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6042 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6042 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7413 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7413] = 40
                                mem[_7413 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7757 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7757 + 68] = mem[_7413 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7757 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7757 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6337 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6337] = 30
                            mem[_6337 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6484 + 68] = mem[_6337 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6484 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6484 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8026 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8026] = 40
                            mem[_8026 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8381 + 68] = mem[_8026 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8381 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8381 + -mem[64] + 132
                        _5255 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5255] = 26
                        mem[_5255 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _5537 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5537] = 26
                            mem[_5537 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6167] = 30
                                mem[_6167 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7835 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7835] = 40
                                mem[_7835 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7835 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6671] = 30
                                mem[_6671 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _8476 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8476] = 40
                                mem[_8476 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8476 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _5538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5538] = 26
                            mem[_5538 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6168 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6168] = 30
                                mem[_6168 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7837 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7837] = 40
                                mem[_7837 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7837 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6673 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6673] = 30
                                mem[_6673 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _8478 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8478] = 40
                                mem[_8478 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8478 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _5344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5344] = 26
                                mem[_5344 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5414 + 68] = mem[_5344 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5414 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5414 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _5883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5883] = 30
                                    mem[_5883 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _5945 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5945 + 68] = mem[_5883 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5945 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5945 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6342 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6342] = 30
                                    mem[_6342 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _6490 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6490 + 68] = mem[_6342 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6490 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6490 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _8686 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_8686] = 40
                                    mem[_8686 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _9124 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _9124 + 68] = mem[_8686 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9124 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9124 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6175] = 30
                                mem[_6175 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _6341 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6341 + 68] = mem[_6175 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6341 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6341 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6915 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6915] = 30
                                mem[_6915 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _7126 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7126 + 68] = mem[_6915 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7126 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7126 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _9427 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9427] = 40
                                mem[_9427 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9749 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9749 + 68] = mem[_9427 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9749 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9749 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _5415 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5415] = 30
                                mem[_5415 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _5469 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5469 + 68] = mem[_5415 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5469 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5469 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _5768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5768] = 30
                                mem[_5768 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _5884 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5884 + 68] = mem[_5768 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5884 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5884 + -mem[64] + 100
                            _5416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5416] = 26
                            mem[_5416 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5470 + 68] = mem[_5416 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5470 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5470 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _5947 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5947] = 30
                                mem[_5947 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _6046 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6046 + 68] = mem[_5947 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6046 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6046 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6493] = 30
                                mem[_6493 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6686 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6686 + 68] = mem[_6493 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6686 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6686 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _8937 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8937] = 40
                                mem[_8937 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9353 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9353 + 68] = mem[_8937 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9353 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9353 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _6344 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6344] = 30
                            mem[_6344 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _6492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6492 + 68] = mem[_6344 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6492 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6492 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _7128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7128] = 30
                            mem[_7128 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _7282 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7282 + 68] = mem[_7128 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7282 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7282 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _9604 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9604] = 40
                            mem[_9604 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _9915 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _9915 + 68] = mem[_9604 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9915 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _9915 + -mem[64] + 132
                        _5258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5258] = 26
                        mem[_5258 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _5543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5543] = 26
                            mem[_5543 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _6173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6173] = 30
                                mem[_6173 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6912 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6912] = 30
                                mem[_6912 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _9423 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9423] = 40
                                mem[_9423 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9423 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6679] = 30
                                mem[_6679 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _7559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7559] = 30
                                mem[_7559 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _9974 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9974] = 40
                                mem[_9974 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9974 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _5544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5544] = 26
                            mem[_5544 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _6174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6174] = 30
                                mem[_6174 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6914 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6914] = 30
                                mem[_6914 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _9425 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9425] = 40
                                mem[_9425 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9425 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6681] = 30
                                mem[_6681 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _7561 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7561] = 30
                                mem[_7561 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _9976 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9976] = 40
                                mem[_9976 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9976 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    else:
        mem[0] = arg2
        mem[32] = 11
        if not stor11[address(arg2)]:
            idx = 0
            s = totalSupply
            t = stor16
            while idx < stor12.length:
                mem[0] = stor12[idx]
                mem[32] = 5
                if stor5[stor12[idx]] > t:
                    _5362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5362] = 26
                    mem[_5362 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _5450 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5450 + 68] = mem[_5362 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5450 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5450 + -mem[64] + 100
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 6
                        _5901 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5901] = 30
                        mem[_5901 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _5990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5990 + 68] = mem[_5901 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5990 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5990 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _6399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6399] = 30
                        mem[_6399 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            _6559 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6559 + 68] = mem[_6399 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6559 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6559 + -mem[64] + 100
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _8097 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8097] = 40
                        mem[_8097 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8429 + 68] = mem[_8097 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8429 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8429 + -mem[64] + 132
                    if arg3 and stor16 / totalSupply > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 6
                    _6229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6229] = 30
                    mem[_6229 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        _6398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6398 + 68] = mem[_6229 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6398 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6398 + -mem[64] + 100
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _6967 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6967] = 30
                    mem[_6967 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                        _7190 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _7190 + 68] = mem[_6967 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7190 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _7190 + -mem[64] + 100
                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                    emit Transfer(arg3, arg1, arg2);
                    _8716 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8716] = 40
                    mem[_8716 + 32 len 40] = code.data[20398 len 40]
                    mem[32] = sha3(address(arg1), 7)
                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] -= arg3
                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                        return 1
                    _9193 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _9193 + 68] = mem[_8716 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9193 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _9193 + -mem[64] + 132
                if idx >= stor12.length:
                    revert with 0, 50
                mem[0] = stor12[idx]
                mem[32] = 6
                if stor6[stor12[idx]] <= s:
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    _5451 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5451] = 30
                    mem[_5451 + 32] = 'SafeMath: subtraction overflow'
                    if stor5[stor12[idx]] > t:
                        _5496 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5496 + 68] = mem[_5451 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5496 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5496 + -mem[64] + 100
                    if t < stor5[stor12[idx]]:
                        revert with 0, 17
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    _5795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5795] = 30
                    mem[_5795 + 32] = 'SafeMath: subtraction overflow'
                    if stor6[stor12[idx]] <= s:
                        if s < stor6[stor12[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor6[stor12[idx]]
                        t = t - stor5[stor12[idx]]
                        continue 
                    _5902 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5902 + 68] = mem[_5795 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5902 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5902 + -mem[64] + 100
                _5452 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5452] = 26
                mem[_5452 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _5497 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5497 + 68] = mem[_5452 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5497 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5497 + -mem[64] + 100
                if not arg3:
                    mem[0] = arg1
                    mem[32] = 6
                    _5992 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5992] = 30
                    mem[_5992 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        _6082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6082 + 68] = mem[_5992 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6082 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6082 + -mem[64] + 100
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _6562 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6562] = 30
                    mem[_6562 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor5[address(arg1)]:
                        _6761 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6761 + 68] = mem[_6562 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_6761 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6761 + -mem[64] + 100
                    if stor5[address(arg1)] < 0:
                        revert with 0, 17
                    if stor5[arg2] > -1:
                        revert with 0, 17
                    if stor5[arg2] < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2]
                    emit Transfer(arg3, arg1, arg2);
                    _8350 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8350] = 40
                    mem[_8350 + 32 len 40] = code.data[20398 len 40]
                    mem[32] = sha3(address(arg1), 7)
                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] -= arg3
                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                        return 1
                    _8679 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _8679 + 68] = mem[_8350 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8679 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _8679 + -mem[64] + 132
                if arg3 and stor16 / totalSupply > -1 / arg3:
                    revert with 0, 17
                if not arg3:
                    revert with 0, 18
                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[0] = arg1
                mem[32] = 6
                _6401 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6401] = 30
                mem[_6401 + 32] = 'SafeMath: subtraction overflow'
                if arg3 > stor6[address(arg1)]:
                    _6561 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _6561 + 68] = mem[_6401 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_6561 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6561 + -mem[64] + 100
                if stor6[address(arg1)] < arg3:
                    revert with 0, 17
                mem[0] = arg1
                stor6[address(arg1)] -= arg3
                mem[32] = 5
                _7192 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7192] = 30
                mem[_7192 + 32] = 'SafeMath: subtraction overflow'
                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                    _7348 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _7348 + 68] = mem[_7192 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7348 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _7348 + -mem[64] + 100
                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                    revert with 0, 17
                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                    revert with 0, 17
                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg2
                mem[32] = 5
                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                emit Transfer(arg3, arg1, arg2);
                _9077 = mem[64]
                mem[64] = mem[64] + 96
                mem[_9077] = 40
                mem[_9077 + 32 len 40] = code.data[20398 len 40]
                mem[32] = sha3(address(arg1), 7)
                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not msg.sender:
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(arg1)][address(msg.sender)] -= arg3
                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                    return 1
                _9411 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 40
                idx = 0
                while idx < 40:
                    mem[idx + _9411 + 68] = mem[_9077 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9411 + 108] = 0
                revert with memory
                  from mem[64]
                   len _9411 + -mem[64] + 132
            _5285 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5285] = 26
            mem[_5285 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor16 / totalSupply:
                _5597 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5597] = 26
                mem[_5597 + 32] = 'SafeMath: division by zero'
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg3:
                    mem[0] = arg1
                    mem[32] = 6
                    _6227 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6227] = 30
                    mem[_6227 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _6964 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6964] = 30
                    mem[_6964 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor5[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(arg1)] < 0:
                        revert with 0, 17
                    if stor5[arg2] > -1:
                        revert with 0, 17
                    if stor5[arg2] < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2]
                    emit Transfer(arg3, arg1, arg2);
                    _8712 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8712] = 40
                    mem[_8712 + 32 len 40] = code.data[20398 len 40]
                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8712 + 72 len 24]
                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if arg3 and t / s > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * t / s / arg3 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 6
                    _6754 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6754] = 30
                    mem[_6754 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _7613 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7613] = 30
                    mem[_7613 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * t / s > stor5[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(arg1)] < arg3 * t / s:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * t / s
                    if stor5[arg2] > !(arg3 * t / s):
                        revert with 0, 17
                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                    emit Transfer(arg3, arg1, arg2);
                    _9447 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_9447] = 40
                    mem[_9447 + 32 len 40] = code.data[20398 len 40]
                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9447 + 72 len 24]
                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                _5598 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5598] = 26
                mem[_5598 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg3:
                    mem[0] = arg1
                    mem[32] = 6
                    _6228 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6228] = 30
                    mem[_6228 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _6966 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6966] = 30
                    mem[_6966 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor5[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(arg1)] < 0:
                        revert with 0, 17
                    if stor5[arg2] > -1:
                        revert with 0, 17
                    if stor5[arg2] < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2]
                    emit Transfer(arg3, arg1, arg2);
                    _8714 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_8714] = 40
                    mem[_8714 + 32 len 40] = code.data[20398 len 40]
                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8714 + 72 len 24]
                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if arg3 and stor16 / totalSupply > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 6
                    _6756 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6756] = 30
                    mem[_6756 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _7615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7615] = 30
                    mem[_7615 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                    emit Transfer(arg3, arg1, arg2);
                    _9449 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_9449] = 40
                    mem[_9449 + 32 len 40] = code.data[20398 len 40]
                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9449 + 72 len 24]
                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            if stor11[address(arg1)]:
                mem[0] = arg1
                mem[32] = 11
                if not stor11[address(arg1)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _5348 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5348] = 26
                            mem[_5348 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5422 + 68] = mem[_5348 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5422 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5422 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5887] = 30
                                mem[_5887 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _5955 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5955 + 68] = mem[_5887 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5955 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5955 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7215 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7215] = 40
                                mem[_7215 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7573 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7573 + 68] = mem[_7215 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7573 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7573 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6187] = 30
                            mem[_6187 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6354 + 68] = mem[_6187 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6354 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _7855 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7855] = 40
                            mem[_7855 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8156 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8156 + 68] = mem[_7855 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8156 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8156 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5423] = 30
                            mem[_5423 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5475 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5475 + 68] = mem[_5423 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5475 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5475 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5774] = 30
                            mem[_5774 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5888 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5888 + 68] = mem[_5774 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5888 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5888 + -mem[64] + 100
                        _5424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5424] = 26
                        mem[_5424 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5476 + 68] = mem[_5424 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5476 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5476 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5957 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5957] = 30
                            mem[_5957 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _6054 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6054 + 68] = mem[_5957 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6054 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6054 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7449 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7449] = 40
                            mem[_7449 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _7771 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _7771 + 68] = mem[_7449 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7771 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _7771 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6356] = 30
                        mem[_6356 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6507 + 68] = mem[_6356 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6507 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6507 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _8052 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8052] = 40
                        mem[_8052 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _8394 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _8394 + 68] = mem[_8052 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_8394 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _8394 + -mem[64] + 132
                    _5264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5264] = 26
                    mem[_5264 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _5555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5555] = 26
                        mem[_5555 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6185] = 30
                            mem[_6185 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7851 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7851] = 40
                            mem[_7851 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7851 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6696] = 30
                            mem[_6696 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _8502 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8502] = 40
                            mem[_8502 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8502 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _5556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5556] = 26
                        mem[_5556 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6186] = 30
                            mem[_6186 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _7853 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7853] = 40
                            mem[_7853 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7853 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6698] = 30
                            mem[_6698 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8504 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8504] = 40
                            mem[_8504 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8504 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if not stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _5350 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5350] = 26
                                mem[_5350 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5426 + 68] = mem[_5350 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5426 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5426 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _5889 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5889] = 30
                                    mem[_5889 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _5960 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5960 + 68] = mem[_5889 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5960 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5960 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7218 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7218] = 40
                                    mem[_7218 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _7579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _7579 + 68] = mem[_7218 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7579 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7579 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6193] = 30
                                mem[_6193 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _6360 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6360 + 68] = mem[_6193 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6360 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6360 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _7861 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7861] = 40
                                mem[_7861 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _8164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _8164 + 68] = mem[_7861 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8164 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _8164 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _5427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5427] = 30
                                mem[_5427 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _5478 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5478 + 68] = mem[_5427 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5478 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5478 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _5777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5777] = 30
                                mem[_5777 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _5890 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5890 + 68] = mem[_5777 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5890 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5890 + -mem[64] + 100
                            _5428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5428] = 26
                            mem[_5428 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5479 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5479 + 68] = mem[_5428 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5479 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5479 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5962 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5962] = 30
                                mem[_5962 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6058 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6058 + 68] = mem[_5962 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6058 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6058 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7464 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7464] = 40
                                mem[_7464 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7776 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7776 + 68] = mem[_7464 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7776 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7776 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6362] = 30
                            mem[_6362 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6514 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6514 + 68] = mem[_6362 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6514 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6514 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8060 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8060] = 40
                            mem[_8060 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8401 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8401 + 68] = mem[_8060 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8401 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8401 + -mem[64] + 132
                        _5267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5267] = 26
                        mem[_5267 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _5561 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5561] = 26
                            mem[_5561 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6191] = 30
                                mem[_6191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7857 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7857] = 40
                                mem[_7857 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7857 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6704 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6704] = 30
                                mem[_6704 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _8514 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8514] = 40
                                mem[_8514 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8514 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _5562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5562] = 26
                            mem[_5562 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6192] = 30
                                mem[_6192 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7859 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7859] = 40
                                mem[_7859 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7859 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6706] = 30
                                mem[_6706 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _8516 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8516] = 40
                                mem[_8516 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8516 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _5352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5352] = 26
                                mem[_5352 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5430 + 68] = mem[_5352 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5430 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5430 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _5891 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5891] = 30
                                    mem[_5891 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _5965 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5965 + 68] = mem[_5891 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5965 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5965 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6367] = 30
                                    mem[_6367 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _6520 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6520 + 68] = mem[_6367 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6520 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6520 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _8698 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_8698] = 40
                                    mem[_8698 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _9155 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _9155 + 68] = mem[_8698 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9155 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9155 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6199] = 30
                                mem[_6199 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _6366 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6366 + 68] = mem[_6199 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6366 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6366 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6937] = 30
                                mem[_6937 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _7153 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7153 + 68] = mem[_6937 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7153 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7153 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _9436 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9436] = 40
                                mem[_9436 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9774 + 68] = mem[_9436 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9774 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9774 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _5431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5431] = 30
                                mem[_5431 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _5481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5481 + 68] = mem[_5431 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5481 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5481 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _5780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5780] = 30
                                mem[_5780 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _5892 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5892 + 68] = mem[_5780 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5892 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5892 + -mem[64] + 100
                            _5432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5432] = 26
                            mem[_5432 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5482 + 68] = mem[_5432 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5482 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5482 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _5967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5967] = 30
                                mem[_5967 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _6062 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6062 + 68] = mem[_5967 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6062 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6062 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6523] = 30
                                mem[_6523 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6719 + 68] = mem[_6523 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6719 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _9003 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9003] = 40
                                mem[_9003 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9379 + 68] = mem[_9003 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9379 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9379 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _6369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6369] = 30
                            mem[_6369 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _6522 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6522 + 68] = mem[_6369 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6522 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6522 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _7155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7155] = 30
                            mem[_7155 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _7311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7311 + 68] = mem[_7155 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7311 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _7311 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _9661 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9661] = 40
                            mem[_9661 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _9933 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _9933 + 68] = mem[_9661 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_9933 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _9933 + -mem[64] + 132
                        _5270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5270] = 26
                        mem[_5270 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _5567 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5567] = 26
                            mem[_5567 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _6197 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6197] = 30
                                mem[_6197 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6934] = 30
                                mem[_6934 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _9432 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9432] = 40
                                mem[_9432 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9432 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6712 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6712] = 30
                                mem[_6712 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _7582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7582] = 30
                                mem[_7582 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _9987 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9987] = 40
                                mem[_9987 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9987 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _5568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5568] = 26
                            mem[_5568 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _6198 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6198] = 30
                                mem[_6198 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _6936 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6936] = 30
                                mem[_6936 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _9434 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9434] = 40
                                mem[_9434 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9434 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6714 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6714] = 30
                                mem[_6714 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _7584 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7584] = 30
                                mem[_7584 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _9989 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9989] = 40
                                mem[_9989 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9989 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 11
                if stor11[address(arg2)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _5360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5360] = 26
                            mem[_5360 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5446 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5446 + 68] = mem[_5360 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5446 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5446 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5899] = 30
                                mem[_5899 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _5985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5985 + 68] = mem[_5899 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5985 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5985 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _7891 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7891] = 40
                                mem[_7891 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _8201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _8201 + 68] = mem[_7891 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8201 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _8201 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6223 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6223] = 30
                            mem[_6223 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6392 + 68] = mem[_6223 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6392 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6392 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _8570 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8570] = 40
                            mem[_8570 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8810 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8810 + 68] = mem[_8570 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8810 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8810 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _5447 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5447] = 30
                            mem[_5447 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _5493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5493 + 68] = mem[_5447 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5493 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5493 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _5792 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5792] = 30
                            mem[_5792 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _5900 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5900 + 68] = mem[_5792 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5900 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5900 + -mem[64] + 100
                        _5448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5448] = 26
                        mem[_5448 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _5494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5494 + 68] = mem[_5448 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5494 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5494 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _5987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5987] = 30
                            mem[_5987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _6078 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6078 + 68] = mem[_5987 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6078 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6078 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _8095 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8095] = 40
                            mem[_8095 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8425 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8425 + 68] = mem[_8095 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8425 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8425 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _6394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6394] = 30
                        mem[_6394 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _6553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6553 + 68] = mem[_6394 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_6553 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6553 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                        emit Transfer(arg3, arg1, arg2);
                        _8710 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_8710] = 40
                        mem[_8710 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _9187 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _9187 + 68] = mem[_8710 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_9187 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _9187 + -mem[64] + 132
                    _5282 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5282] = 26
                    mem[_5282 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _5591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5591] = 26
                        mem[_5591 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6221 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6221] = 30
                            mem[_6221 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _8566 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8566] = 40
                            mem[_8566 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8566 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6746] = 30
                            mem[_6746 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * t / s
                            emit Transfer(arg3, arg1, arg2);
                            _9301 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9301] = 40
                            mem[_9301 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9301 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _5592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5592] = 26
                        mem[_5592 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _6222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6222] = 30
                            mem[_6222 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _8568 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8568] = 40
                            mem[_8568 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8568 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6748] = 30
                            mem[_6748 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _9303 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_9303] = 40
                            mem[_9303 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9303 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _5354 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5354] = 26
                                mem[_5354 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5434 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5434 + 68] = mem[_5354 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5434 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5434 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _5893 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5893] = 30
                                    mem[_5893 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _5970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5970 + 68] = mem[_5893 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5970 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5970 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7225 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7225] = 40
                                    mem[_7225 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _7593 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _7593 + 68] = mem[_7225 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7593 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7593 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6205] = 30
                                mem[_6205 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _6373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6373 + 68] = mem[_6205 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6373 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6373 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _7875 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7875] = 40
                                mem[_7875 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _8179 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _8179 + 68] = mem[_7875 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8179 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _8179 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _5435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5435] = 30
                                mem[_5435 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _5484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5484 + 68] = mem[_5435 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5484 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _5783 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5783] = 30
                                mem[_5783 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _5894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5894 + 68] = mem[_5783 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5894 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5894 + -mem[64] + 100
                            _5436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5436] = 26
                            mem[_5436 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _5485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5485 + 68] = mem[_5436 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5485 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5485 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _5972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5972] = 30
                                mem[_5972 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _6066 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6066 + 68] = mem[_5972 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6066 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6066 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7484 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7484] = 40
                                mem[_7484 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _7787 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _7787 + 68] = mem[_7484 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7787 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _7787 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _6375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6375] = 30
                            mem[_6375 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _6530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _6530 + 68] = mem[_6375 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_6530 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _6530 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _8069 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_8069] = 40
                            mem[_8069 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _8411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _8411 + 68] = mem[_8069 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_8411 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _8411 + -mem[64] + 132
                        _5273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5273] = 26
                        mem[_5273 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _5573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5573] = 26
                            mem[_5573 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6203 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6203] = 30
                                mem[_6203 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7871 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7871] = 40
                                mem[_7871 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7871 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6721 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6721] = 30
                                mem[_6721 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _8534 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8534] = 40
                                mem[_8534 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8534 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _5574 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5574] = 26
                            mem[_5574 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _6204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6204] = 30
                                mem[_6204 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _7873 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_7873] = 40
                                mem[_7873 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7873 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6723] = 30
                                mem[_6723 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _8536 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8536] = 40
                                mem[_8536 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8536 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if not stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _5356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5356] = 26
                                    mem[_5356 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _5438 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5438 + 68] = mem[_5356 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5438 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5438 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _5895 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5895] = 30
                                        mem[_5895 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _5975 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _5975 + 68] = mem[_5895 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5975 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5975 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _7228 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_7228] = 40
                                        mem[_7228 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _7599 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _7599 + 68] = mem[_7228 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7599 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _7599 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _6211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6211] = 30
                                    mem[_6211 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _6379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6379 + 68] = mem[_6211 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6379 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6379 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _7881 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7881] = 40
                                    mem[_7881 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _8187 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _8187 + 68] = mem[_7881 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8187 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8187 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _5439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5439] = 30
                                    mem[_5439 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _5487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5487 + 68] = mem[_5439 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5487 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5487 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _5786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5786] = 30
                                    mem[_5786 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _5896 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5896 + 68] = mem[_5786 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5896 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5896 + -mem[64] + 100
                                _5440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5440] = 26
                                mem[_5440 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5488 + 68] = mem[_5440 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5488 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5488 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _5977 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5977] = 30
                                    mem[_5977 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _6070 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6070 + 68] = mem[_5977 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6070 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6070 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7499 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7499] = 40
                                    mem[_7499 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _7792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _7792 + 68] = mem[_7499 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7792 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7792 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _6381 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6381] = 30
                                mem[_6381 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _6537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6537 + 68] = mem[_6381 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6537 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6537 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _8077 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_8077] = 40
                                mem[_8077 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _8418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _8418 + 68] = mem[_8077 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8418 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _8418 + -mem[64] + 132
                            _5276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5276] = 26
                            mem[_5276 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _5579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5579] = 26
                                mem[_5579 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _6209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6209] = 30
                                    mem[_6209 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7877 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7877] = 40
                                    mem[_7877 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7877 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _6729 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6729] = 30
                                    mem[_6729 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _8546 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_8546] = 40
                                    mem[_8546 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8546 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _5580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5580] = 26
                                mem[_5580 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _6210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6210] = 30
                                    mem[_6210 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _7879 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7879] = 40
                                    mem[_7879 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_7879 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _6731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6731] = 30
                                    mem[_6731 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _8548 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_8548] = 40
                                    mem[_8548 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_8548 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _5358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5358] = 26
                                    mem[_5358 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _5442 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5442 + 68] = mem[_5358 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5442 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5442 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _5897 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5897] = 30
                                        mem[_5897 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _5980 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _5980 + 68] = mem[_5897 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_5980 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _5980 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _6386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6386] = 30
                                        mem[_6386 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _6543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _6543 + 68] = mem[_6386 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_6543 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _6543 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _8702 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_8702] = 40
                                        mem[_8702 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _9179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _9179 + 68] = mem[_8702 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9179 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9179 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _6217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6217] = 30
                                    mem[_6217 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _6385 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6385 + 68] = mem[_6217 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6385 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6385 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6955] = 30
                                    mem[_6955 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _7175 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _7175 + 68] = mem[_6955 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_7175 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _7175 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _9444 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_9444] = 40
                                    mem[_9444 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _9790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _9790 + 68] = mem[_9444 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9790 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9790 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _5443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5443] = 30
                                    mem[_5443 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _5490 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5490 + 68] = mem[_5443 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5490 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5490 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _5789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5789] = 30
                                    mem[_5789 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _5898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5898 + 68] = mem[_5789 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5898 + -mem[64] + 100
                                _5444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5444] = 26
                                mem[_5444 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _5491 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5491 + 68] = mem[_5444 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5491 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5491 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _5982 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5982] = 30
                                    mem[_5982 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _6074 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6074 + 68] = mem[_5982 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6074 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6074 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6546] = 30
                                    mem[_6546 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _6744 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _6744 + 68] = mem[_6546 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_6744 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _6744 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _9062 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_9062] = 40
                                    mem[_9062 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _9396 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _9396 + 68] = mem[_9062 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9396 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9396 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _6388 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6388] = 30
                                mem[_6388 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _6545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _6545 + 68] = mem[_6388 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_6545 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _6545 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _7177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7177] = 30
                                mem[_7177 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _7333 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7333 + 68] = mem[_7177 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7333 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _7333 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _9697 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_9697] = 40
                                mem[_9697 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _9944 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _9944 + 68] = mem[_9697 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9944 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _9944 + -mem[64] + 132
                            _5279 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5279] = 26
                            mem[_5279 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _5585 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5585] = 26
                                mem[_5585 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _6215 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6215] = 30
                                    mem[_6215 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6952] = 30
                                    mem[_6952 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _9440 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_9440] = 40
                                    mem[_9440 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9440 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _6737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6737] = 30
                                    mem[_6737 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _7602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7602] = 30
                                    mem[_7602 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _9999 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_9999] = 40
                                    mem[_9999 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9999 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _5586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5586] = 26
                                mem[_5586 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _6216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6216] = 30
                                    mem[_6216 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _6954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6954] = 30
                                    mem[_6954 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _9442 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_9442] = 40
                                    mem[_9442 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_9442 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _6739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6739] = 30
                                    mem[_6739 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _7604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7604] = 30
                                    mem[_7604 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _10001 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_10001] = 40
                                    mem[_10001 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_10001 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    ('le', ('param', 'arg3'), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'allowance', 7)))))
    if allowance[address(arg1)][address(msg.sender)] < arg3:
        revert with 0, 17
    if not arg1:
        revert with 0, 'ERC20: approve from the zero address'
    if not msg.sender:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(arg1)][address(msg.sender)] -= arg3
    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
    return 1
}

function transferFromWithPermit(address arg1, address arg2, uint256 arg3, uint256 arg4, uint8 arg5, bytes32 arg6, bytes32 arg7) payable {
    require calldata.size - 4 >= 224
    require arg1 == arg1
    require arg2 == arg2
    require arg5 == arg5
    if arg4 < block.timestamp:
        revert with 0, 'EverStake: EXPIRED'
    if nonces[address(arg1)] == -1:
        revert with 0, 17
    nonces[address(arg1)]++
    mem[128] = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9
    mem[160] = arg1
    mem[192] = msg.sender
    mem[224] = arg3
    mem[256] = nonces[address(arg1)]
    mem[288] = arg4
    mem[96] = 192
    mem[352] = 0x1901000000000000000000000000000000000000000000000000000000000000
    mem[354] = DOMAIN_SEPARATOR
    mem[386] = sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), msg.sender, arg3, nonces[address(arg1)], arg4)
    mem[320] = 66
    if arg5 < 27:
        if arg5 > 228:
            revert with 0, 17
        mem[64] = 450
        mem[482] = uint8(arg5 + 27)
        mem[514] = arg6
        mem[546] = arg7
        signer = erecover(sha3(0, DOMAIN_SEPARATOR, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), msg.sender, arg3, nonces[address(arg1)], arg4)), arg5 + 27 << 248, arg6, arg7) 
        mem[418] = signer
        if not erecover.result:
            revert with ext_call.return_data[0 len return_data.size]
        if not address(signer):
            revert with 0, 'EverStake: INVALID_SIGNATURE'
        if address(signer) != arg1:
            revert with 0, 'EverStake: INVALID_SIGNATURE'
        if not arg1:
            revert with 0, 'ERC20: approve from the zero address'
        if not msg.sender:
            revert with 0, 'ERC20: approve to the zero address'
        allowance[address(arg1)][address(msg.sender)] = arg3
        mem[450] = arg3
        emit Approval(arg3, arg1, msg.sender);
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not arg2:
            revert with 0, 'ERC20: transfer to the zero address'
        if arg3 <= 0:
            revert with 0, 'Transfer amount must be greater than zero'
        if not stor11[address(arg1)]:
            if stor11[address(arg1)]:
                mem[0] = arg1
                mem[32] = 11
                if not stor11[address(arg1)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _16121 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16121] = 26
                            mem[_16121 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16361 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16361 + 68] = mem[_16121 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16361 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16361 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17740 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17740] = 30
                                mem[_17740 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _17967 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17967 + 68] = mem[_17740 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17967 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17967 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _21735 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_21735] = 40
                                mem[_21735 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _22833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _22833 + 68] = mem[_21735 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22833 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _22833 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _18672 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18672] = 30
                            mem[_18672 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19177 + 68] = mem[_18672 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19177 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19177 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _23676 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_23676] = 40
                            mem[_23676 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _24587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _24587 + 68] = mem[_23676 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24587 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _24587 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _16362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16362] = 30
                            mem[_16362 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _16511 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16511 + 68] = mem[_16362 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16511 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16511 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _17410 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17410] = 30
                            mem[_17410 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _17741 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17741 + 68] = mem[_17410 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17741 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17741 + -mem[64] + 100
                        _16363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16363] = 26
                        mem[_16363 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _16512 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16512 + 68] = mem[_16363 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16512 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16512 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _17969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17969] = 30
                            mem[_17969 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _18253 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18253 + 68] = mem[_17969 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18253 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18253 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _22478 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_22478] = 40
                            mem[_22478 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _23415 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _23415 + 68] = mem[_22478 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23415 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _23415 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _19179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19179] = 30
                        mem[_19179 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _19641 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19641 + 68] = mem[_19179 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19641 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19641 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _24262 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_24262] = 40
                        mem[_24262 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _25282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _25282 + 68] = mem[_24262 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_25282 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _25282 + -mem[64] + 132
                    _15880 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15880] = 26
                    mem[_15880 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _16780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16780] = 26
                        mem[_16780 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _18670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18670] = 30
                            mem[_18670 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _23672 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_23672] = 40
                            mem[_23672 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23672 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _20225 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20225] = 30
                            mem[_20225 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _25647 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_25647] = 40
                            mem[_25647 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25647 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _16781 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16781] = 26
                        mem[_16781 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _18671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18671] = 30
                            mem[_18671 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _23674 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_23674] = 40
                            mem[_23674 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23674 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _20227 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20227] = 30
                            mem[_20227 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _25649 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_25649] = 40
                            mem[_25649 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25649 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if not stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16123] = 26
                                mem[_16123 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16365 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16365 + 68] = mem[_16123 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16365 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16365 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17742] = 30
                                    mem[_17742 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17972 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17972 + 68] = mem[_17742 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17972 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17972 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _21738 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21738] = 40
                                    mem[_21738 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _22839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _22839 + 68] = mem[_21738 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22839 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22839 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18678] = 30
                                mem[_18678 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19183 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19183 + 68] = mem[_18678 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19183 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19183 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _23682 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23682] = 40
                                mem[_23682 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24595 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24595 + 68] = mem[_23682 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24595 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24595 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16366] = 30
                                mem[_16366 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16514 + 68] = mem[_16366 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16514 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16514 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17413] = 30
                                mem[_17413 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17743 + 68] = mem[_17413 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17743 + -mem[64] + 100
                            _16367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16367] = 26
                            mem[_16367 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16515 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16515 + 68] = mem[_16367 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16515 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16515 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17974 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17974] = 30
                                mem[_17974 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18257 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18257 + 68] = mem[_17974 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18257 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18257 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _22493 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_22493] = 40
                                mem[_22493 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _23420 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _23420 + 68] = mem[_22493 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23420 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _23420 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19185] = 30
                            mem[_19185 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19648 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19648 + 68] = mem[_19185 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19648 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19648 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _24270 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24270] = 40
                            mem[_24270 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25289 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25289 + 68] = mem[_24270 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25289 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25289 + -mem[64] + 132
                        _15883 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15883] = 26
                        mem[_15883 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16786 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16786] = 26
                            mem[_16786 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18676 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18676] = 30
                                mem[_18676 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23678 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23678] = 40
                                mem[_23678 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23678 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20233 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20233] = 30
                                mem[_20233 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _25659 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25659] = 40
                                mem[_25659 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25659 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16787 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16787] = 26
                            mem[_16787 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18677] = 30
                                mem[_18677 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23680 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23680] = 40
                                mem[_23680 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23680 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20235 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20235] = 30
                                mem[_20235 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _25661 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25661] = 40
                                mem[_25661 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25661 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16125] = 26
                                mem[_16125 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16369 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16369 + 68] = mem[_16125 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16369 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16369 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _17744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17744] = 30
                                    mem[_17744 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _17977 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17977 + 68] = mem[_17744 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17977 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17977 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _19190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19190] = 30
                                    mem[_19190 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _19654 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19654 + 68] = mem[_19190 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19654 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19654 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _26179 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_26179] = 40
                                    mem[_26179 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _27555 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27555 + 68] = mem[_26179 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27555 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27555 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _18684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18684] = 30
                                mem[_18684 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _19189 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19189 + 68] = mem[_18684 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19189 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19189 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _20900 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20900] = 30
                                mem[_20900 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _21553 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21553 + 68] = mem[_20900 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21553 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21553 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _28398 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28398] = 40
                                mem[_28398 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _29414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29414 + 68] = mem[_28398 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29414 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29414 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16370] = 30
                                mem[_16370 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16517 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16517 + 68] = mem[_16370 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16517 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16517 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17416] = 30
                                mem[_17416 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17745 + 68] = mem[_17416 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17745 + -mem[64] + 100
                            _16371 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16371] = 26
                            mem[_16371 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16518 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16518 + 68] = mem[_16371 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16518 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16518 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _17979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17979] = 30
                                mem[_17979 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _18261 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18261 + 68] = mem[_17979 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18261 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18261 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _19657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19657] = 30
                                mem[_19657 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _20248 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20248 + 68] = mem[_19657 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20248 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20248 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _27097 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27097] = 40
                                mem[_27097 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _28223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28223 + 68] = mem[_27097 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28223 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28223 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _19192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19192] = 30
                            mem[_19192 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _19656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19656 + 68] = mem[_19192 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19656 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _21555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21555] = 30
                            mem[_21555 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _22021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22021 + 68] = mem[_21555 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22021 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22021 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _29071 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29071] = 40
                            mem[_29071 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _29889 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29889 + 68] = mem[_29071 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_29889 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29889 + -mem[64] + 132
                        _15886 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15886] = 26
                        mem[_15886 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16792 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16792] = 26
                            mem[_16792 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _18682 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18682] = 30
                                mem[_18682 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _20897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20897] = 30
                                mem[_20897 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _28394 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28394] = 40
                                mem[_28394 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28394 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _20241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20241] = 30
                                mem[_20241 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _22842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22842] = 30
                                mem[_22842 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _30067 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30067] = 40
                                mem[_30067 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30067 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16793] = 26
                            mem[_16793 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _18683 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18683] = 30
                                mem[_18683 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _20899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20899] = 30
                                mem[_20899 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _28396 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28396] = 40
                                mem[_28396 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28396 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _20243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20243] = 30
                                mem[_20243 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _22844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22844] = 30
                                mem[_22844 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _30069 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30069] = 40
                                mem[_30069 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30069 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 11
                if stor11[address(arg2)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _16133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16133] = 26
                            mem[_16133 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16385 + 68] = mem[_16133 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16385 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16385 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17752 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17752] = 30
                                mem[_17752 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _17997 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17997 + 68] = mem[_17752 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17997 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17997 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _23712 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23712] = 40
                                mem[_23712 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24632 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24632 + 68] = mem[_23712 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24632 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24632 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _18708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18708] = 30
                            mem[_18708 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19215 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19215 + 68] = mem[_18708 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19215 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19215 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _25715 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_25715] = 40
                            mem[_25715 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _26465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _26465 + 68] = mem[_25715 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_26465 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _26465 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _16386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16386] = 30
                            mem[_16386 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _16529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16529 + 68] = mem[_16386 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16529 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16529 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _17428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17428] = 30
                            mem[_17428 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _17753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17753 + 68] = mem[_17428 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17753 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17753 + -mem[64] + 100
                        _16387 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16387] = 26
                        mem[_16387 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _16530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16530 + 68] = mem[_16387 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16530 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16530 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _17999 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17999] = 30
                            mem[_17999 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _18277 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18277 + 68] = mem[_17999 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18277 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18277 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _24305 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24305] = 40
                            mem[_24305 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25313 + 68] = mem[_24305 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25313 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25313 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 5
                        _19217 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19217] = 30
                        mem[_19217 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _19687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19687 + 68] = mem[_19217 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19687 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor6[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor6[address(arg2)] += arg3
                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                        emit Transfer(arg3, arg1, arg2);
                        _26191 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_26191] = 40
                        mem[_26191 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _27587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _27587 + 68] = mem[_26191 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_27587 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _27587 + -mem[64] + 132
                    _15898 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15898] = 26
                    mem[_15898 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _16816 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16816] = 26
                        mem[_16816 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _18706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18706] = 30
                            mem[_18706 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _25711 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_25711] = 40
                            mem[_25711 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25711 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _20275 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20275] = 30
                            mem[_20275 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * t / s
                            emit Transfer(arg3, arg1, arg2);
                            _27944 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_27944] = 40
                            mem[_27944 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27944 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _16817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16817] = 26
                        mem[_16817 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 5
                            _18707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18707] = 30
                            mem[_18707 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > -1:
                                revert with 0, 17
                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            emit Transfer(arg3, arg1, arg2);
                            _25713 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_25713] = 40
                            mem[_25713 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25713 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _20277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20277] = 30
                            mem[_20277 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _27946 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_27946] = 40
                            mem[_27946 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27946 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16127] = 26
                                mem[_16127 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16373 + 68] = mem[_16127 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16373 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16373 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17746 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17746] = 30
                                    mem[_17746 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17982 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17982 + 68] = mem[_17746 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17982 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17982 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _21745 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21745] = 40
                                    mem[_21745 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _22853 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _22853 + 68] = mem[_21745 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22853 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22853 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18690] = 30
                                mem[_18690 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19196 + 68] = mem[_18690 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19196 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19196 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _23696 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23696] = 40
                                mem[_23696 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24610 + 68] = mem[_23696 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24610 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24610 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16374] = 30
                                mem[_16374 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16520 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16520 + 68] = mem[_16374 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16520 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16520 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17419] = 30
                                mem[_17419 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17747 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17747 + 68] = mem[_17419 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17747 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17747 + -mem[64] + 100
                            _16375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16375] = 26
                            mem[_16375 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16521 + 68] = mem[_16375 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16521 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16521 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17984 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17984] = 30
                                mem[_17984 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18265 + 68] = mem[_17984 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18265 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18265 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _22513 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_22513] = 40
                                mem[_22513 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _23431 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _23431 + 68] = mem[_22513 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23431 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _23431 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19198] = 30
                            mem[_19198 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19664 + 68] = mem[_19198 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19664 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19664 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _24279 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24279] = 40
                            mem[_24279 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25299 + 68] = mem[_24279 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25299 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25299 + -mem[64] + 132
                        _15889 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15889] = 26
                        mem[_15889 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16798] = 26
                            mem[_16798 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18688] = 30
                                mem[_18688 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23692 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23692] = 40
                                mem[_23692 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23692 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20250] = 30
                                mem[_20250 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _25679 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25679] = 40
                                mem[_25679 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25679 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16799] = 26
                            mem[_16799 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18689] = 30
                                mem[_18689 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23694 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23694] = 40
                                mem[_23694 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23694 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20252] = 30
                                mem[_20252 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _25681 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25681] = 40
                                mem[_25681 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25681 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if not stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16129] = 26
                                    mem[_16129 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16377 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16377 + 68] = mem[_16129 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16377 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16377 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17748 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17748] = 30
                                        mem[_17748 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17987 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17987 + 68] = mem[_17748 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17987 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17987 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21748 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21748] = 40
                                        mem[_21748 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22859 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22859 + 68] = mem[_21748 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22859 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22859 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18696 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18696] = 30
                                    mem[_18696 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19202 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19202 + 68] = mem[_18696 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19202 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19202 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23702 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23702] = 40
                                    mem[_23702 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24618 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24618 + 68] = mem[_23702 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24618 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24618 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16378] = 30
                                    mem[_16378 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16523 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16523 + 68] = mem[_16378 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16523 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16523 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17422] = 30
                                    mem[_17422 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17749 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17749 + 68] = mem[_17422 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17749 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17749 + -mem[64] + 100
                                _16379 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16379] = 26
                                mem[_16379 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16524 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16524 + 68] = mem[_16379 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16524 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16524 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17989] = 30
                                    mem[_17989 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18269 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18269 + 68] = mem[_17989 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18269 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18269 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22528 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22528] = 40
                                    mem[_22528 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23436 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23436 + 68] = mem[_22528 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23436 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23436 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19204] = 30
                                mem[_19204 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19671 + 68] = mem[_19204 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19671 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24287 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24287] = 40
                                mem[_24287 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25306 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25306 + 68] = mem[_24287 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25306 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25306 + -mem[64] + 132
                            _15892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15892] = 26
                            mem[_15892 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16804 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16804] = 26
                                mem[_16804 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18694] = 30
                                    mem[_18694 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23698 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23698] = 40
                                    mem[_23698 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23698 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20258 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20258] = 30
                                    mem[_20258 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25691 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25691] = 40
                                    mem[_25691 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25691 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16805] = 26
                                mem[_16805 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18695 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18695] = 30
                                    mem[_18695 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23700 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23700] = 40
                                    mem[_23700 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23700 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20260 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20260] = 30
                                    mem[_20260 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25693 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25693] = 40
                                    mem[_25693 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25693 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16131 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16131] = 26
                                    mem[_16131 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16381 + 68] = mem[_16131 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16381 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16381 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17750] = 30
                                        mem[_17750 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _17992 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17992 + 68] = mem[_17750 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17992 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17992 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19209 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19209] = 30
                                        mem[_19209 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _19677 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19677 + 68] = mem[_19209 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19677 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19677 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26183 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26183] = 40
                                        mem[_26183 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _27579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27579 + 68] = mem[_26183 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27579 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27579 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18702] = 30
                                    mem[_18702 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19208 + 68] = mem[_18702 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19208 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19208 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20918] = 30
                                    mem[_20918 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21575 + 68] = mem[_20918 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21575 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21575 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28406 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28406] = 40
                                    mem[_28406 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29430 + 68] = mem[_28406 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29430 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29430 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16382] = 30
                                    mem[_16382 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16526 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16526 + 68] = mem[_16382 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16526 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16526 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17425] = 30
                                    mem[_17425 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17751 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17751 + 68] = mem[_17425 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17751 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17751 + -mem[64] + 100
                                _16383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16383] = 26
                                mem[_16383 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16527 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16527 + 68] = mem[_16383 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16527 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16527 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _17994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17994] = 30
                                    mem[_17994 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _18273 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18273 + 68] = mem[_17994 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18273 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18273 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _19680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19680] = 30
                                    mem[_19680 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _20273 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20273 + 68] = mem[_19680 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20273 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20273 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _27156 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27156] = 40
                                    mem[_27156 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _28240 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28240 + 68] = mem[_27156 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28240 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28240 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _19211 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19211] = 30
                                mem[_19211 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _19679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19679 + 68] = mem[_19211 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19679 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19679 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _21577 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21577] = 30
                                mem[_21577 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _22043 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22043 + 68] = mem[_21577 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22043 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22043 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _29107 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29107] = 40
                                mem[_29107 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _29900 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29900 + 68] = mem[_29107 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29900 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29900 + -mem[64] + 132
                            _15895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15895] = 26
                            mem[_15895 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16810 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16810] = 26
                                mem[_16810 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18700 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18700] = 30
                                    mem[_18700 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20915 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20915] = 30
                                    mem[_20915 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28402 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28402] = 40
                                    mem[_28402 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28402 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20266] = 30
                                    mem[_20266 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22862] = 30
                                    mem[_22862 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _30079 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30079] = 40
                                    mem[_30079 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30079 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16811] = 26
                                mem[_16811 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18701 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18701] = 30
                                    mem[_18701 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20917 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20917] = 30
                                    mem[_20917 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28404 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28404] = 40
                                    mem[_28404 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28404 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20268 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20268] = 30
                                    mem[_20268 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22864 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22864] = 30
                                    mem[_22864 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _30081 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30081] = 40
                                    mem[_30081 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30081 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            mem[0] = arg2
            mem[32] = 11
            if not stor11[address(arg2)]:
                idx = 0
                s = totalSupply
                t = stor16
                while idx < stor12.length:
                    mem[0] = stor12[idx]
                    mem[32] = 5
                    if stor5[stor12[idx]] > t:
                        _16149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16149] = 26
                        mem[_16149 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _16417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16417 + 68] = mem[_16149 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16417 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16417 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _17768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17768] = 30
                            mem[_17768 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _18037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18037 + 68] = mem[_17768 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18037 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18037 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _19266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19266] = 30
                            mem[_19266 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _19746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19746 + 68] = mem[_19266 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19746 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19746 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _24358 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24358] = 40
                            mem[_24358 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25354 + 68] = mem[_24358 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25354 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25354 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _18756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18756] = 30
                        mem[_18756 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _19265 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19265 + 68] = mem[_18756 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19265 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19265 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _20970 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20970] = 30
                        mem[_20970 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _21639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21639 + 68] = mem[_20970 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21639 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _26213 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_26213] = 40
                        mem[_26213 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _27648 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _27648 + 68] = mem[_26213 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_27648 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _27648 + -mem[64] + 132
                    if idx >= stor12.length:
                        revert with 0, 50
                    mem[0] = stor12[idx]
                    mem[32] = 6
                    if stor6[stor12[idx]] <= s:
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        _16418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16418] = 30
                        mem[_16418 + 32] = 'SafeMath: subtraction overflow'
                        if stor5[stor12[idx]] > t:
                            _16553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16553 + 68] = mem[_16418 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16553 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16553 + -mem[64] + 100
                        if t < stor5[stor12[idx]]:
                            revert with 0, 17
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        _17452 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17452] = 30
                        mem[_17452 + 32] = 'SafeMath: subtraction overflow'
                        if stor6[stor12[idx]] <= s:
                            if s < stor6[stor12[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor6[stor12[idx]]
                            t = t - stor5[stor12[idx]]
                            continue 
                        _17769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17769 + 68] = mem[_17452 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_17769 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17769 + -mem[64] + 100
                    _16419 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16419] = 26
                    mem[_16419 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _16554 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16554 + 68] = mem[_16419 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16554 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16554 + -mem[64] + 100
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 6
                        _18039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18039] = 30
                        mem[_18039 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _18309 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18309 + 68] = mem[_18039 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18309 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18309 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _19749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19749] = 30
                        mem[_19749 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            _20348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20348 + 68] = mem[_19749 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20348 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20348 + -mem[64] + 100
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _25115 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_25115] = 40
                        mem[_25115 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _26100 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _26100 + 68] = mem[_25115 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_26100 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _26100 + -mem[64] + 132
                    if arg3 and stor16 / totalSupply > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[0] = arg1
                    mem[32] = 6
                    _19268 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19268] = 30
                    mem[_19268 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor6[address(arg1)]:
                        _19748 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19748 + 68] = mem[_19268 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_19748 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19748 + -mem[64] + 100
                    if stor6[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor6[address(arg1)] -= arg3
                    mem[32] = 5
                    _21641 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21641] = 30
                    mem[_21641 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                        _22109 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22109 + 68] = mem[_21641 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_22109 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22109 + -mem[64] + 100
                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                        revert with 0, 17
                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                        revert with 0, 17
                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 5
                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                    emit Transfer(arg3, arg1, arg2);
                    _27296 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_27296] = 40
                    mem[_27296 + 32 len 40] = code.data[20398 len 40]
                    mem[32] = sha3(address(arg1), 7)
                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] -= arg3
                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                        return 1
                    _28298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _28298 + 68] = mem[_27296 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_28298 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _28298 + -mem[64] + 132
                _15922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15922] = 26
                mem[_15922 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor16 / totalSupply:
                    _16864 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16864] = 26
                    mem[_16864 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 6
                        _18754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18754] = 30
                        mem[_18754 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _20967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20967] = 30
                        mem[_20967 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _26209 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_26209] = 40
                        mem[_26209 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26209 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and t / s > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * t / s / arg3 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _20341 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20341] = 30
                        mem[_20341 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _22916 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22916] = 30
                        mem[_22916 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * t / s > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * t / s:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * t / s
                        if stor5[arg2] > !(arg3 * t / s):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                        emit Transfer(arg3, arg1, arg2);
                        _28426 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_28426] = 40
                        mem[_28426 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28426 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    _16865 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16865] = 26
                    mem[_16865 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        mem[0] = arg1
                        mem[32] = 6
                        _18755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18755] = 30
                        mem[_18755 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _20969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20969] = 30
                        mem[_20969 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < 0:
                            revert with 0, 17
                        if stor5[arg2] > -1:
                            revert with 0, 17
                        if stor5[arg2] < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2]
                        emit Transfer(arg3, arg1, arg2);
                        _26211 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_26211] = 40
                        mem[_26211 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26211 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _20343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20343] = 30
                        mem[_20343 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _22918 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22918] = 30
                        mem[_22918 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _28428 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_28428] = 40
                        mem[_28428 + 32 len 40] = code.data[20398 len 40]
                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28428 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                if stor11[address(arg1)]:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16135 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16135] = 26
                                mem[_16135 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16389 + 68] = mem[_16135 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16389 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16389 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17754 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17754] = 30
                                    mem[_17754 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18002 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18002 + 68] = mem[_17754 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18002 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18002 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _21756 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21756] = 40
                                    mem[_21756 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _22876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _22876 + 68] = mem[_21756 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22876 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22876 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18714 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18714] = 30
                                mem[_18714 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19221 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19221 + 68] = mem[_18714 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19221 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19221 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _23718 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23718] = 40
                                mem[_23718 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24639 + 68] = mem[_23718 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24639 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24639 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16390] = 30
                                mem[_16390 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16532 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16532 + 68] = mem[_16390 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16532 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16532 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17431] = 30
                                mem[_17431 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17755 + 68] = mem[_17431 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17755 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17755 + -mem[64] + 100
                            _16391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16391] = 26
                            mem[_16391 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16533 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16533 + 68] = mem[_16391 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16533 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16533 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18004] = 30
                                mem[_18004 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18281 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18281 + 68] = mem[_18004 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18281 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18281 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _22564 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_22564] = 40
                                mem[_22564 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _23450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _23450 + 68] = mem[_22564 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23450 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _23450 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19223 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19223] = 30
                            mem[_19223 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19694 + 68] = mem[_19223 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19694 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _24313 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24313] = 40
                            mem[_24313 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25319 + 68] = mem[_24313 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25319 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25319 + -mem[64] + 132
                        _15901 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15901] = 26
                        mem[_15901 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16822] = 26
                            mem[_16822 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18712 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18712] = 30
                                mem[_18712 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23714 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23714] = 40
                                mem[_23714 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23714 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20283] = 30
                                mem[_20283 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _25717 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25717] = 40
                                mem[_25717 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25717 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16823 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16823] = 26
                            mem[_16823 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18713 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18713] = 30
                                mem[_18713 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23716 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23716] = 40
                                mem[_23716 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23716 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20285] = 30
                                mem[_20285 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _25719 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25719] = 40
                                mem[_25719 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25719 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if not stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16137 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16137] = 26
                                    mem[_16137 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16393 + 68] = mem[_16137 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16393 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16393 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17756] = 30
                                        mem[_17756 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18007 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18007 + 68] = mem[_17756 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18007 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18007 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21759 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21759] = 40
                                        mem[_21759 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22882 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22882 + 68] = mem[_21759 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22882 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22882 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18720] = 30
                                    mem[_18720 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19227 + 68] = mem[_18720 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19227 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19227 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23724 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23724] = 40
                                    mem[_23724 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24647 + 68] = mem[_23724 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24647 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24647 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16394 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16394] = 30
                                    mem[_16394 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16535 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16535 + 68] = mem[_16394 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16535 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16535 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17434] = 30
                                    mem[_17434 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17757 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17757 + 68] = mem[_17434 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17757 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17757 + -mem[64] + 100
                                _16395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16395] = 26
                                mem[_16395 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16536 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16536 + 68] = mem[_16395 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16536 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16536 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18009] = 30
                                    mem[_18009 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18285 + 68] = mem[_18009 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18285 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18285 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22579 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22579] = 40
                                    mem[_22579 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23455 + 68] = mem[_22579 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23455 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23455 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19229] = 30
                                mem[_19229 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19701 + 68] = mem[_19229 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19701 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19701 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24321 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24321] = 40
                                mem[_24321 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25326 + 68] = mem[_24321 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25326 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25326 + -mem[64] + 132
                            _15904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15904] = 26
                            mem[_15904 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16828 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16828] = 26
                                mem[_16828 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18718] = 30
                                    mem[_18718 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23720 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23720] = 40
                                    mem[_23720 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23720 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20291] = 30
                                    mem[_20291 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25729 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25729] = 40
                                    mem[_25729 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25729 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16829 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16829] = 26
                                mem[_16829 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18719] = 30
                                    mem[_18719 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23722 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23722] = 40
                                    mem[_23722 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23722 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20293] = 30
                                    mem[_20293 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25731 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25731] = 40
                                    mem[_25731 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25731 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16139] = 26
                                    mem[_16139 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16397 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16397 + 68] = mem[_16139 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16397 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16397 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17758] = 30
                                        mem[_17758 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18012 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18012 + 68] = mem[_17758 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18012 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18012 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19234 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19234] = 30
                                        mem[_19234 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _19707 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19707 + 68] = mem[_19234 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19707 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19707 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26195 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26195] = 40
                                        mem[_26195 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _27610 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27610 + 68] = mem[_26195 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27610 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27610 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18726] = 30
                                    mem[_18726 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19233 + 68] = mem[_18726 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19233 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19233 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20940 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20940] = 30
                                    mem[_20940 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21602 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21602 + 68] = mem[_20940 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21602 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21602 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28415 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28415] = 40
                                    mem[_28415 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29455 + 68] = mem[_28415 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29455 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29455 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16398 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16398] = 30
                                    mem[_16398 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16538 + 68] = mem[_16398 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16538 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16538 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17437] = 30
                                    mem[_17437 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17759 + 68] = mem[_17437 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17759 + -mem[64] + 100
                                _16399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16399] = 26
                                mem[_16399 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16539 + 68] = mem[_16399 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16539 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16539 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18014] = 30
                                    mem[_18014 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _18289 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18289 + 68] = mem[_18014 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18289 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18289 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _19710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19710] = 30
                                    mem[_19710 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _20306 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20306 + 68] = mem[_19710 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20306 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20306 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _27222 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27222] = 40
                                    mem[_27222 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _28266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28266 + 68] = mem[_27222 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28266 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28266 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _19236 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19236] = 30
                                mem[_19236 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _19709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19709 + 68] = mem[_19236 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19709 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19709 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _21604 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21604] = 30
                                mem[_21604 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _22072 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22072 + 68] = mem[_21604 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22072 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22072 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _29164 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29164] = 40
                                mem[_29164 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _29918 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29918 + 68] = mem[_29164 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29918 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29918 + -mem[64] + 132
                            _15907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15907] = 26
                            mem[_15907 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16834] = 26
                                mem[_16834 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18724] = 30
                                    mem[_18724 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20937] = 30
                                    mem[_20937 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28411 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28411] = 40
                                    mem[_28411 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28411 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20299] = 30
                                    mem[_20299 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22885] = 30
                                    mem[_22885 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _30092 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30092] = 40
                                    mem[_30092 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30092 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16835] = 26
                                mem[_16835 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18725 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18725] = 30
                                    mem[_18725 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20939 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20939] = 30
                                    mem[_20939 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28413 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28413] = 40
                                    mem[_28413 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28413 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20301] = 30
                                    mem[_20301 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22887 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22887] = 30
                                    mem[_22887 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _30094 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30094] = 40
                                    mem[_30094 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30094 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16147] = 26
                                mem[_16147 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16413 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16413 + 68] = mem[_16147 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16413 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16413 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17766] = 30
                                    mem[_17766 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18032 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18032 + 68] = mem[_17766 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18032 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18032 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _23754 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23754] = 40
                                    mem[_23754 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24684 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24684 + 68] = mem[_23754 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24684 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24684 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18750] = 30
                                mem[_18750 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19259 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19259 + 68] = mem[_18750 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19259 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19259 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _25785 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25785] = 40
                                mem[_25785 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _26513 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _26513 + 68] = mem[_25785 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26513 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _26513 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16414] = 30
                                mem[_16414 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16550 + 68] = mem[_16414 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16550 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16550 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17449 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17449] = 30
                                mem[_17449 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17767 + 68] = mem[_17449 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17767 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17767 + -mem[64] + 100
                            _16415 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16415] = 26
                            mem[_16415 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16551 + 68] = mem[_16415 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16551 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16551 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18034] = 30
                                mem[_18034 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18305 + 68] = mem[_18034 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18305 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _24356 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24356] = 40
                                mem[_24356 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25350 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25350 + 68] = mem[_24356 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25350 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25350 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19261] = 30
                            mem[_19261 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19740 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19740 + 68] = mem[_19261 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19740 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19740 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _26207 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26207] = 40
                            mem[_26207 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _27642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _27642 + 68] = mem[_26207 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27642 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _27642 + -mem[64] + 132
                        _15919 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15919] = 26
                        mem[_15919 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16858 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16858] = 26
                            mem[_16858 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18748] = 30
                                mem[_18748 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25781 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25781] = 40
                                mem[_25781 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25781 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20333] = 30
                                mem[_20333 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _28002 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28002] = 40
                                mem[_28002 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28002 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16859 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16859] = 26
                            mem[_16859 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18749 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18749] = 30
                                mem[_18749 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25783 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25783] = 40
                                mem[_25783 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25783 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20335] = 30
                                mem[_20335 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _28004 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28004] = 40
                                mem[_28004 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28004 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16141] = 26
                                    mem[_16141 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16401 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16401 + 68] = mem[_16141 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16401 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16401 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17760 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17760] = 30
                                        mem[_17760 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18017 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18017 + 68] = mem[_17760 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18017 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18017 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21766 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21766] = 40
                                        mem[_21766 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22896 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22896 + 68] = mem[_21766 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22896 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22896 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18732 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18732] = 30
                                    mem[_18732 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19240 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19240 + 68] = mem[_18732 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19240 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19240 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23738 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23738] = 40
                                    mem[_23738 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24662 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24662 + 68] = mem[_23738 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24662 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24662 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16402] = 30
                                    mem[_16402 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16541 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16541 + 68] = mem[_16402 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16541 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16541 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17440] = 30
                                    mem[_17440 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17761 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17761 + 68] = mem[_17440 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17761 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17761 + -mem[64] + 100
                                _16403 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16403] = 26
                                mem[_16403 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16542 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16542 + 68] = mem[_16403 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16542 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16542 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18019] = 30
                                    mem[_18019 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18293 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18293 + 68] = mem[_18019 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18293 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18293 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22599 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22599] = 40
                                    mem[_22599 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23466 + 68] = mem[_22599 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23466 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23466 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19242] = 30
                                mem[_19242 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19717 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19717 + 68] = mem[_19242 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19717 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19717 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24330 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24330] = 40
                                mem[_24330 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25336 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25336 + 68] = mem[_24330 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25336 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25336 + -mem[64] + 132
                            _15910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15910] = 26
                            mem[_15910 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16840] = 26
                                mem[_16840 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18730 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18730] = 30
                                    mem[_18730 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23734 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23734] = 40
                                    mem[_23734 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23734 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20308] = 30
                                    mem[_20308 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25749 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25749] = 40
                                    mem[_25749 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25749 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16841] = 26
                                mem[_16841 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18731] = 30
                                    mem[_18731 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23736 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23736] = 40
                                    mem[_23736 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23736 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20310] = 30
                                    mem[_20310 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25751 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25751] = 40
                                    mem[_25751 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25751 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg2
                            mem[32] = 11
                            if not stor11[address(arg2)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16143] = 26
                                        mem[_16143 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16405 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16405 + 68] = mem[_16143 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16405 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16405 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17762] = 30
                                            mem[_17762 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _18022 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18022 + 68] = mem[_17762 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18022 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18022 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21769 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21769] = 40
                                            mem[_21769 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22902 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22902 + 68] = mem[_21769 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22902 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22902 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18738 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18738] = 30
                                        mem[_18738 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19246 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19246 + 68] = mem[_18738 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19246 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19246 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23744 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23744] = 40
                                        mem[_23744 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24670 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24670 + 68] = mem[_23744 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24670 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24670 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16406 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16406] = 30
                                        mem[_16406 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16544 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16544 + 68] = mem[_16406 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16544 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16544 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17443] = 30
                                        mem[_17443 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17763 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17763 + 68] = mem[_17443 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17763 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17763 + -mem[64] + 100
                                    _16407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16407] = 26
                                    mem[_16407 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16545 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16545 + 68] = mem[_16407 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16545 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16545 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18024] = 30
                                        mem[_18024 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18297 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18297 + 68] = mem[_18024 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18297 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18297 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22614 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22614] = 40
                                        mem[_22614 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23471 + 68] = mem[_22614 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23471 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23471 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19248 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19248] = 30
                                    mem[_19248 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19724 + 68] = mem[_19248 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19724 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19724 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24338 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24338] = 40
                                    mem[_24338 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25343 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25343 + 68] = mem[_24338 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25343 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25343 + -mem[64] + 132
                                _15913 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15913] = 26
                                mem[_15913 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16846] = 26
                                    mem[_16846 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18736 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18736] = 30
                                        mem[_18736 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23740 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23740] = 40
                                        mem[_23740 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23740 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20316 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20316] = 30
                                        mem[_20316 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25761 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25761] = 40
                                        mem[_25761 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25761 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16847] = 26
                                    mem[_16847 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18737 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18737] = 30
                                        mem[_18737 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23742 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23742] = 40
                                        mem[_23742 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23742 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20318] = 30
                                        mem[_20318 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25763 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25763] = 40
                                        mem[_25763 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25763 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16145 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16145] = 26
                                        mem[_16145 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16409 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16409 + 68] = mem[_16145 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16409 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16409 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17764 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17764] = 30
                                            mem[_17764 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _18027 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18027 + 68] = mem[_17764 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18027 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18027 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19253 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19253] = 30
                                            mem[_19253 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _19730 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19730 + 68] = mem[_19253 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19730 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19730 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26199 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26199] = 40
                                            mem[_26199 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _27634 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27634 + 68] = mem[_26199 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27634 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27634 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18744 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18744] = 30
                                        mem[_18744 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19252 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19252 + 68] = mem[_18744 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19252 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19252 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20958 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20958] = 30
                                        mem[_20958 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21624 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21624 + 68] = mem[_20958 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21624 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21624 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28423 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28423] = 40
                                        mem[_28423 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29471 + 68] = mem[_28423 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29471 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29471 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16410] = 30
                                        mem[_16410 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16547 + 68] = mem[_16410 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16547 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16547 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17446 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17446] = 30
                                        mem[_17446 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17765 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17765 + 68] = mem[_17446 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17765 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17765 + -mem[64] + 100
                                    _16411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16411] = 26
                                    mem[_16411 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16548 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16548 + 68] = mem[_16411 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16548 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16548 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18029] = 30
                                        mem[_18029 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18301 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18301 + 68] = mem[_18029 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18301 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18301 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19733 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19733] = 30
                                        mem[_19733 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _20331 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20331 + 68] = mem[_19733 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20331 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20331 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _27281 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27281] = 40
                                        mem[_27281 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _28283 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28283 + 68] = mem[_27281 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28283 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28283 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19255] = 30
                                    mem[_19255 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19732 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19732 + 68] = mem[_19255 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19732 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19732 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _21626 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21626] = 30
                                    mem[_21626 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _22094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22094 + 68] = mem[_21626 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22094 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22094 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _29200 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29200] = 40
                                    mem[_29200 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29929 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29929 + 68] = mem[_29200 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29929 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29929 + -mem[64] + 132
                                _15916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15916] = 26
                                mem[_15916 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16852] = 26
                                    mem[_16852 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18742 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18742] = 30
                                        mem[_18742 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20955] = 30
                                        mem[_20955 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28419 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28419] = 40
                                        mem[_28419 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28419 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20324] = 30
                                        mem[_20324 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22905 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22905] = 30
                                        mem[_22905 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * t / s
                                        emit Transfer(arg3, arg1, arg2);
                                        _30104 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30104] = 40
                                        mem[_30104 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30104 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16853] = 26
                                    mem[_16853 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18743 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18743] = 30
                                        mem[_18743 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20957] = 30
                                        mem[_20957 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28421 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28421] = 40
                                        mem[_28421 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28421 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20326 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20326] = 30
                                        mem[_20326 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22907 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22907] = 30
                                        mem[_22907 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _30106 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30106] = 40
                                        mem[_30106 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30106 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    else:
        if arg5 <= 30:
            mem[64] = 450
            mem[482] = arg5
            mem[514] = arg6
            mem[546] = arg7
            signer = erecover(sha3(0, DOMAIN_SEPARATOR, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), msg.sender, arg3, nonces[address(arg1)], arg4)), arg5 << 248, arg6, arg7) 
            mem[418] = signer
            if not erecover.result:
                revert with ext_call.return_data[0 len return_data.size]
            if not address(signer):
                revert with 0, 'EverStake: INVALID_SIGNATURE'
            if address(signer) != arg1:
                revert with 0, 'EverStake: INVALID_SIGNATURE'
            if not arg1:
                revert with 0, 'ERC20: approve from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(arg1)][address(msg.sender)] = arg3
            mem[450] = arg3
            emit Approval(arg3, arg1, msg.sender);
            if not arg1:
                revert with 0, 'ERC20: transfer from the zero address'
            if not arg2:
                revert with 0, 'ERC20: transfer to the zero address'
            if arg3 <= 0:
                revert with 0, 'Transfer amount must be greater than zero'
            if not stor11[address(arg1)]:
                if stor11[address(arg1)]:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16061 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16061] = 26
                                mem[_16061 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16241 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16241 + 68] = mem[_16061 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16241 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16241 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17680] = 30
                                    mem[_17680 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17817 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17817 + 68] = mem[_17680 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17817 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17817 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _21643 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21643] = 40
                                    mem[_21643 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _22645 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _22645 + 68] = mem[_21643 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22645 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22645 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18492 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18492] = 30
                                mem[_18492 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _18987 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18987 + 68] = mem[_18492 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18987 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18987 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _23492 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23492] = 40
                                mem[_23492 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24365 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24365 + 68] = mem[_23492 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24365 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24365 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16242] = 30
                                mem[_16242 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16421 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16421 + 68] = mem[_16242 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16421 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16421 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17320] = 30
                                mem[_17320 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17681 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17681 + 68] = mem[_17320 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17681 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17681 + -mem[64] + 100
                            _16243 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16243] = 26
                            mem[_16243 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16422 + 68] = mem[_16243 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16422 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16422 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17819] = 30
                                mem[_17819 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18133 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18133 + 68] = mem[_17819 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18133 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18133 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _22124 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_22124] = 40
                                mem[_22124 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _23261 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _23261 + 68] = mem[_22124 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23261 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _23261 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _18989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18989] = 30
                            mem[_18989 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19411 + 68] = mem[_18989 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19411 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19411 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _24052 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24052] = 40
                            mem[_24052 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25122 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25122 + 68] = mem[_24052 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25122 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25122 + -mem[64] + 132
                        _15790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15790] = 26
                        mem[_15790 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16600] = 26
                            mem[_16600 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18490] = 30
                                mem[_18490 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23488 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23488] = 40
                                mem[_23488 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23488 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19975] = 30
                                mem[_19975 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _25357 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25357] = 40
                                mem[_25357 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25357 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16601] = 26
                            mem[_16601 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18491] = 30
                                mem[_18491 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23490 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23490] = 40
                                mem[_23490 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23490 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19977 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19977] = 30
                                mem[_19977 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _25359 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25359] = 40
                                mem[_25359 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25359 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if not stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16063 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16063] = 26
                                    mem[_16063 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16245 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16245 + 68] = mem[_16063 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16245 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16245 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17682] = 30
                                        mem[_17682 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17822 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17822 + 68] = mem[_17682 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17822 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17822 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21646 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21646] = 40
                                        mem[_21646 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22651 + 68] = mem[_21646 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22651 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22651 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18498 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18498] = 30
                                    mem[_18498 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _18993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18993 + 68] = mem[_18498 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18993 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18993 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23498 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23498] = 40
                                    mem[_23498 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24373 + 68] = mem[_23498 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24373 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24373 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16246 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16246] = 30
                                    mem[_16246 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16424 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16424 + 68] = mem[_16246 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16424 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16424 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17323] = 30
                                    mem[_17323 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17683 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17683 + 68] = mem[_17323 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17683 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17683 + -mem[64] + 100
                                _16247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16247] = 26
                                mem[_16247 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16425 + 68] = mem[_16247 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16425 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16425 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17824] = 30
                                    mem[_17824 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18137 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18137 + 68] = mem[_17824 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18137 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18137 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22139 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22139] = 40
                                    mem[_22139 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23266 + 68] = mem[_22139 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23266 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23266 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18995 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18995] = 30
                                mem[_18995 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19418 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19418 + 68] = mem[_18995 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19418 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19418 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24060 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24060] = 40
                                mem[_24060 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25129 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25129 + 68] = mem[_24060 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25129 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25129 + -mem[64] + 132
                            _15793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15793] = 26
                            mem[_15793 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16606 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16606] = 26
                                mem[_16606 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18496 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18496] = 30
                                    mem[_18496 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23494 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23494] = 40
                                    mem[_23494 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23494 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19983 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19983] = 30
                                    mem[_19983 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25369 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25369] = 40
                                    mem[_25369 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25369 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16607] = 26
                                mem[_16607 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18497] = 30
                                    mem[_18497 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23496 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23496] = 40
                                    mem[_23496 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23496 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19985 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19985] = 30
                                    mem[_19985 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25371 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25371] = 40
                                    mem[_25371 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25371 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16065] = 26
                                    mem[_16065 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16249 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16249 + 68] = mem[_16065 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16249 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16249 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17684] = 30
                                        mem[_17684 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _17827 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17827 + 68] = mem[_17684 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17827 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17827 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19000 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19000] = 30
                                        mem[_19000 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _19424 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19424 + 68] = mem[_19000 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19424 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19424 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26103 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26103] = 40
                                        mem[_26103 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _27319 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27319 + 68] = mem[_26103 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27319 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27319 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18504] = 30
                                    mem[_18504 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _18999 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18999 + 68] = mem[_18504 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18999 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18999 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20724] = 30
                                    mem[_20724 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21337 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21337 + 68] = mem[_20724 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21337 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21337 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28306 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28306] = 40
                                    mem[_28306 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29236 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29236 + 68] = mem[_28306 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29236 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29236 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16250] = 30
                                    mem[_16250 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16427 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16427 + 68] = mem[_16250 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16427 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16427 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17326 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17326] = 30
                                    mem[_17326 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17685 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17685 + 68] = mem[_17326 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17685 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17685 + -mem[64] + 100
                                _16251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16251] = 26
                                mem[_16251 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16428 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16428 + 68] = mem[_16251 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16428 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16428 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _17829 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17829] = 30
                                    mem[_17829 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _18141 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18141 + 68] = mem[_17829 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18141 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18141 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _19427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19427] = 30
                                    mem[_19427 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _19998 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19998 + 68] = mem[_19427 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19998 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19998 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _26581 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_26581] = 40
                                    mem[_26581 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _28037 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28037 + 68] = mem[_26581 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28037 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28037 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _19002 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19002] = 30
                                mem[_19002 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _19426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19426 + 68] = mem[_19002 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19426 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19426 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _21339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21339] = 30
                                mem[_21339 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _21801 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21801 + 68] = mem[_21339 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21801 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21801 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _28697 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28697] = 40
                                mem[_28697 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _29755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29755 + 68] = mem[_28697 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29755 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29755 + -mem[64] + 132
                            _15796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15796] = 26
                            mem[_15796 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16612] = 26
                                mem[_16612 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18502] = 30
                                    mem[_18502 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20721 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20721] = 30
                                    mem[_20721 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28302 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28302] = 40
                                    mem[_28302 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28302 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19991 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19991] = 30
                                    mem[_19991 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22654] = 30
                                    mem[_22654 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _29947 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29947] = 40
                                    mem[_29947 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29947 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16613 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16613] = 26
                                mem[_16613 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18503] = 30
                                    mem[_18503 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20723] = 30
                                    mem[_20723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28304 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28304] = 40
                                    mem[_28304 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28304 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19993 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19993] = 30
                                    mem[_19993 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22656 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22656] = 30
                                    mem[_22656 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _29949 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29949] = 40
                                    mem[_29949 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29949 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16073] = 26
                                mem[_16073 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16265 + 68] = mem[_16073 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16265 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16265 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17692 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17692] = 30
                                    mem[_17692 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17847 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17847 + 68] = mem[_17692 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17847 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17847 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _23528 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23528] = 40
                                    mem[_23528 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24410 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24410 + 68] = mem[_23528 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24410 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24410 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18528] = 30
                                mem[_18528 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19025 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19025 + 68] = mem[_18528 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19025 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19025 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _25425 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25425] = 40
                                mem[_25425 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _26259 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _26259 + 68] = mem[_25425 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26259 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _26259 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16266] = 30
                                mem[_16266 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16439 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16439 + 68] = mem[_16266 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16439 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16439 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17338 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17338] = 30
                                mem[_17338 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17693 + 68] = mem[_17338 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17693 + -mem[64] + 100
                            _16267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16267] = 26
                            mem[_16267 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16440 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16440 + 68] = mem[_16267 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16440 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16440 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17849 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17849] = 30
                                mem[_17849 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18157 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18157 + 68] = mem[_17849 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18157 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18157 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _24095 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24095] = 40
                                mem[_24095 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25153 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25153 + 68] = mem[_24095 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25153 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25153 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19027] = 30
                            mem[_19027 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19457 + 68] = mem[_19027 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19457 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19457 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _26115 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26115] = 40
                            mem[_26115 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _27351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _27351 + 68] = mem[_26115 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27351 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _27351 + -mem[64] + 132
                        _15808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15808] = 26
                        mem[_15808 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16636] = 26
                            mem[_16636 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18526 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18526] = 30
                                mem[_18526 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25421 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25421] = 40
                                mem[_25421 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25421 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20025 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20025] = 30
                                mem[_20025 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _27698 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27698] = 40
                                mem[_27698 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27698 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16637] = 26
                            mem[_16637 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18527] = 30
                                mem[_18527 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25423 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25423] = 40
                                mem[_25423 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25423 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20027 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20027] = 30
                                mem[_20027 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _27700 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27700] = 40
                                mem[_27700 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27700 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16067] = 26
                                    mem[_16067 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16253 + 68] = mem[_16067 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16253 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16253 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17686] = 30
                                        mem[_17686 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17832 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17832 + 68] = mem[_17686 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17832 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17832 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21653 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21653] = 40
                                        mem[_21653 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22665 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22665 + 68] = mem[_21653 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22665 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22665 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18510 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18510] = 30
                                    mem[_18510 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19006 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19006 + 68] = mem[_18510 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19006 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19006 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23512 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23512] = 40
                                    mem[_23512 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24388 + 68] = mem[_23512 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24388 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24388 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16254] = 30
                                    mem[_16254 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16430 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16430 + 68] = mem[_16254 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16430 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16430 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17329] = 30
                                    mem[_17329 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17687 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17687 + 68] = mem[_17329 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17687 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17687 + -mem[64] + 100
                                _16255 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16255] = 26
                                mem[_16255 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16431 + 68] = mem[_16255 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16431 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16431 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17834] = 30
                                    mem[_17834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18145 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18145 + 68] = mem[_17834 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18145 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18145 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22159 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22159] = 40
                                    mem[_22159 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23277 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23277 + 68] = mem[_22159 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23277 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23277 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19008] = 30
                                mem[_19008 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19434 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19434 + 68] = mem[_19008 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19434 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19434 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24069 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24069] = 40
                                mem[_24069 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25139 + 68] = mem[_24069 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25139 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25139 + -mem[64] + 132
                            _15799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15799] = 26
                            mem[_15799 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16618] = 26
                                mem[_16618 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18508] = 30
                                    mem[_18508 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23508 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23508] = 40
                                    mem[_23508 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23508 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20000 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20000] = 30
                                    mem[_20000 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25389 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25389] = 40
                                    mem[_25389 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25389 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16619] = 26
                                mem[_16619 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18509 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18509] = 30
                                    mem[_18509 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23510 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23510] = 40
                                    mem[_23510 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23510 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20002 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20002] = 30
                                    mem[_20002 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25391 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25391] = 40
                                    mem[_25391 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25391 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg2
                            mem[32] = 11
                            if not stor11[address(arg2)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16069] = 26
                                        mem[_16069 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16257 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16257 + 68] = mem[_16069 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16257 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16257 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17688 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17688] = 30
                                            mem[_17688 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17837 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17837 + 68] = mem[_17688 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17837 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17837 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21656 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21656] = 40
                                            mem[_21656 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22671 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22671 + 68] = mem[_21656 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22671 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22671 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18516 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18516] = 30
                                        mem[_18516 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19012 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19012 + 68] = mem[_18516 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19012 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19012 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23518 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23518] = 40
                                        mem[_23518 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24396 + 68] = mem[_23518 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24396 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24396 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16258 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16258] = 30
                                        mem[_16258 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16433 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16433 + 68] = mem[_16258 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16433 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16433 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17332] = 30
                                        mem[_17332 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17689 + 68] = mem[_17332 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17689 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17689 + -mem[64] + 100
                                    _16259 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16259] = 26
                                    mem[_16259 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16434 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16434 + 68] = mem[_16259 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16434 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16434 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17839 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17839] = 30
                                        mem[_17839 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18149 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18149 + 68] = mem[_17839 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18149 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18149 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22174 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22174] = 40
                                        mem[_22174 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23282 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23282 + 68] = mem[_22174 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23282 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23282 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19014] = 30
                                    mem[_19014 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19441 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19441 + 68] = mem[_19014 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19441 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19441 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24077 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24077] = 40
                                    mem[_24077 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25146 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25146 + 68] = mem[_24077 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25146 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25146 + -mem[64] + 132
                                _15802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15802] = 26
                                mem[_15802 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16624] = 26
                                    mem[_16624 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18514] = 30
                                        mem[_18514 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23514 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23514] = 40
                                        mem[_23514 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23514 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20008] = 30
                                        mem[_20008 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25401 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25401] = 40
                                        mem[_25401 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25401 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16625] = 26
                                    mem[_16625 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18515 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18515] = 30
                                        mem[_18515 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23516 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23516] = 40
                                        mem[_23516 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23516 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20010] = 30
                                        mem[_20010 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25403 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25403] = 40
                                        mem[_25403 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25403 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16071] = 26
                                        mem[_16071 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16261 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16261 + 68] = mem[_16071 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16261 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16261 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17690] = 30
                                            mem[_17690 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _17842 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17842 + 68] = mem[_17690 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17842 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17842 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19019 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19019] = 30
                                            mem[_19019 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _19447 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19447 + 68] = mem[_19019 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19447 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19447 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26107 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26107] = 40
                                            mem[_26107 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _27343 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27343 + 68] = mem[_26107 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27343 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27343 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18522 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18522] = 30
                                        mem[_18522 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19018 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19018 + 68] = mem[_18522 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19018 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19018 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20742 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20742] = 30
                                        mem[_20742 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21359 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21359 + 68] = mem[_20742 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21359 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21359 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28314 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28314] = 40
                                        mem[_28314 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29252 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29252 + 68] = mem[_28314 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29252 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29252 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16262 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16262] = 30
                                        mem[_16262 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16436 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16436 + 68] = mem[_16262 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16436 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16436 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17335 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17335] = 30
                                        mem[_17335 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17691 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17691 + 68] = mem[_17335 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17691 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17691 + -mem[64] + 100
                                    _16263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16263] = 26
                                    mem[_16263 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16437 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16437 + 68] = mem[_16263 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16437 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16437 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17844 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17844] = 30
                                        mem[_17844 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18153 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18153 + 68] = mem[_17844 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18153 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18153 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19450] = 30
                                        mem[_19450 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _20023 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20023 + 68] = mem[_19450 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20023 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20023 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26640 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26640] = 40
                                        mem[_26640 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _28054 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28054 + 68] = mem[_26640 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28054 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28054 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19021] = 30
                                    mem[_19021 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19449 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19449 + 68] = mem[_19021 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19449 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19449 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _21361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21361] = 30
                                    mem[_21361 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21823 + 68] = mem[_21361 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21823 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21823 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28733 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28733] = 40
                                    mem[_28733 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29766 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29766 + 68] = mem[_28733 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29766 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29766 + -mem[64] + 132
                                _15805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15805] = 26
                                mem[_15805 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16630 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16630] = 26
                                    mem[_16630 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18520 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18520] = 30
                                        mem[_18520 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20739] = 30
                                        mem[_20739 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28310 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28310] = 40
                                        mem[_28310 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28310 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20016 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20016] = 30
                                        mem[_20016 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22674] = 30
                                        mem[_22674 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * t / s
                                        emit Transfer(arg3, arg1, arg2);
                                        _29959 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29959] = 40
                                        mem[_29959 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29959 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16631 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16631] = 26
                                    mem[_16631 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18521 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18521] = 30
                                        mem[_18521 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20741 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20741] = 30
                                        mem[_20741 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28312 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28312] = 40
                                        mem[_28312 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28312 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20018] = 30
                                        mem[_20018 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22676 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22676] = 30
                                        mem[_22676 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _29961 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29961] = 40
                                        mem[_29961 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29961 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 11
                if not stor11[address(arg2)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _16089 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16089] = 26
                            mem[_16089 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16297 + 68] = mem[_16089 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16297 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16297 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _17708 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17708] = 30
                                mem[_17708 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _17887 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17887 + 68] = mem[_17708 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17887 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17887 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _19076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19076] = 30
                                mem[_19076 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _19516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19516 + 68] = mem[_19076 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19516 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19516 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _24148 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24148] = 40
                                mem[_24148 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25194 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25194 + 68] = mem[_24148 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25194 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25194 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _18576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18576] = 30
                            mem[_18576 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _19075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19075 + 68] = mem[_18576 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19075 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19075 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20794] = 30
                            mem[_20794 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _21423 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21423 + 68] = mem[_20794 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21423 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21423 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _26137 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26137] = 40
                            mem[_26137 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _27412 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _27412 + 68] = mem[_26137 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27412 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _27412 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _16298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16298] = 30
                            mem[_16298 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _16463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16463 + 68] = mem[_16298 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16463 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _17362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17362] = 30
                            mem[_17362 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _17709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17709 + 68] = mem[_17362 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17709 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17709 + -mem[64] + 100
                        _16299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16299] = 26
                        mem[_16299 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _16464 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16464 + 68] = mem[_16299 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16464 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16464 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _17889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17889] = 30
                            mem[_17889 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _18189 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18189 + 68] = mem[_17889 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18189 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18189 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _19519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19519] = 30
                            mem[_19519 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _20098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20098 + 68] = mem[_19519 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20098 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20098 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _24833 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24833] = 40
                            mem[_24833 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25894 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25894 + 68] = mem[_24833 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25894 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25894 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _19078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19078] = 30
                        mem[_19078 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _19518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19518 + 68] = mem[_19078 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19518 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19518 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _21425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21425] = 30
                        mem[_21425 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _21889 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21889 + 68] = mem[_21425 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21889 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21889 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _26780 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_26780] = 40
                        mem[_26780 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _28112 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _28112 + 68] = mem[_26780 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_28112 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _28112 + -mem[64] + 132
                    _15832 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15832] = 26
                    mem[_15832 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _16684 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16684] = 26
                        mem[_16684 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _18574 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18574] = 30
                            mem[_18574 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20791] = 30
                            mem[_20791 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _26133 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26133] = 40
                            mem[_26133 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26133 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _20091 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20091] = 30
                            mem[_20091 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _22728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22728] = 30
                            mem[_22728 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _28334 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28334] = 40
                            mem[_28334 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28334 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _16685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16685] = 26
                        mem[_16685 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _18575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18575] = 30
                            mem[_18575 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20793] = 30
                            mem[_20793 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _26135 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26135] = 40
                            mem[_26135 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26135 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _20093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20093] = 30
                            mem[_20093 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _22730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22730] = 30
                            mem[_22730 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _28336 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28336] = 40
                            mem[_28336 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28336 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if stor11[address(arg1)]:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16075] = 26
                                    mem[_16075 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16269 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16269 + 68] = mem[_16075 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16269 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16269 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17694] = 30
                                        mem[_17694 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17852 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17852 + 68] = mem[_17694 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17852 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17852 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21664 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21664] = 40
                                        mem[_21664 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22688 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22688 + 68] = mem[_21664 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22688 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22688 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18534 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18534] = 30
                                    mem[_18534 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19031 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19031 + 68] = mem[_18534 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19031 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19031 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23534 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23534] = 40
                                    mem[_23534 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24417 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24417 + 68] = mem[_23534 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24417 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24417 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16270] = 30
                                    mem[_16270 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16442 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16442 + 68] = mem[_16270 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16442 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16442 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17341] = 30
                                    mem[_17341 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17695 + 68] = mem[_17341 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17695 + -mem[64] + 100
                                _16271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16271] = 26
                                mem[_16271 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16443 + 68] = mem[_16271 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16443 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16443 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17854] = 30
                                    mem[_17854 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18161 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18161 + 68] = mem[_17854 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18161 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18161 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22210 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22210] = 40
                                    mem[_22210 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23296 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23296 + 68] = mem[_22210 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23296 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23296 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19033] = 30
                                mem[_19033 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19464 + 68] = mem[_19033 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19464 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19464 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24103 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24103] = 40
                                mem[_24103 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25159 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25159 + 68] = mem[_24103 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25159 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25159 + -mem[64] + 132
                            _15811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15811] = 26
                            mem[_15811 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16642] = 26
                                mem[_16642 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18532] = 30
                                    mem[_18532 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23530 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23530] = 40
                                    mem[_23530 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23530 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20033] = 30
                                    mem[_20033 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25427 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25427] = 40
                                    mem[_25427 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25427 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16643] = 26
                                mem[_16643 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18533 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18533] = 30
                                    mem[_18533 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23532 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23532] = 40
                                    mem[_23532 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23532 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20035 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20035] = 30
                                    mem[_20035 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25429 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25429] = 40
                                    mem[_25429 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25429 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg2
                            mem[32] = 11
                            if not stor11[address(arg2)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16077 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16077] = 26
                                        mem[_16077 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16273 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16273 + 68] = mem[_16077 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16273 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16273 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17696] = 30
                                            mem[_17696 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17857 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17857 + 68] = mem[_17696 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17857 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17857 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21667 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21667] = 40
                                            mem[_21667 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22694 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22694 + 68] = mem[_21667 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22694 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22694 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18540 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18540] = 30
                                        mem[_18540 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19037 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19037 + 68] = mem[_18540 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19037 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19037 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23540 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23540] = 40
                                        mem[_23540 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24425 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24425 + 68] = mem[_23540 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24425 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24425 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16274] = 30
                                        mem[_16274 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16445 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16445 + 68] = mem[_16274 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16445 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16445 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17344] = 30
                                        mem[_17344 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17697 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17697 + 68] = mem[_17344 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17697 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17697 + -mem[64] + 100
                                    _16275 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16275] = 26
                                    mem[_16275 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16446 + 68] = mem[_16275 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16446 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16446 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17859] = 30
                                        mem[_17859 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18165 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18165 + 68] = mem[_17859 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18165 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18165 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22225 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22225] = 40
                                        mem[_22225 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23301 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23301 + 68] = mem[_22225 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23301 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23301 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19039] = 30
                                    mem[_19039 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19471 + 68] = mem[_19039 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19471 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19471 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24111 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24111] = 40
                                    mem[_24111 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25166 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25166 + 68] = mem[_24111 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25166 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25166 + -mem[64] + 132
                                _15814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15814] = 26
                                mem[_15814 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16648 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16648] = 26
                                    mem[_16648 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18538 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18538] = 30
                                        mem[_18538 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23536 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23536] = 40
                                        mem[_23536 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23536 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20041 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20041] = 30
                                        mem[_20041 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25439 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25439] = 40
                                        mem[_25439 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25439 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16649 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16649] = 26
                                    mem[_16649 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18539 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18539] = 30
                                        mem[_18539 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23538 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23538] = 40
                                        mem[_23538 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23538 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20043] = 30
                                        mem[_20043 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25441 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25441] = 40
                                        mem[_25441 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25441 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16079] = 26
                                        mem[_16079 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16277 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16277 + 68] = mem[_16079 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16277 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16277 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17698] = 30
                                            mem[_17698 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _17862 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17862 + 68] = mem[_17698 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17862 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17862 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19044 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19044] = 30
                                            mem[_19044 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _19477 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19477 + 68] = mem[_19044 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19477 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19477 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26119 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26119] = 40
                                            mem[_26119 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _27374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27374 + 68] = mem[_26119 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27374 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27374 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18546 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18546] = 30
                                        mem[_18546 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19043 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19043 + 68] = mem[_18546 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19043 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19043 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20764 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20764] = 30
                                        mem[_20764 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21386 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21386 + 68] = mem[_20764 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21386 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21386 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28323 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28323] = 40
                                        mem[_28323 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29277 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29277 + 68] = mem[_28323 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29277 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29277 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16278] = 30
                                        mem[_16278 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16448 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16448 + 68] = mem[_16278 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16448 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16448 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17347] = 30
                                        mem[_17347 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17699 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17699 + 68] = mem[_17347 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17699 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17699 + -mem[64] + 100
                                    _16279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16279] = 26
                                    mem[_16279 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16449 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16449 + 68] = mem[_16279 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16449 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16449 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17864 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17864] = 30
                                        mem[_17864 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18169 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18169 + 68] = mem[_17864 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18169 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18169 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19480] = 30
                                        mem[_19480 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _20056 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20056 + 68] = mem[_19480 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20056 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20056 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26706 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26706] = 40
                                        mem[_26706 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _28080 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28080 + 68] = mem[_26706 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28080 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28080 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19046 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19046] = 30
                                    mem[_19046 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19479 + 68] = mem[_19046 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19479 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19479 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _21388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21388] = 30
                                    mem[_21388 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21852 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21852 + 68] = mem[_21388 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21852 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21852 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28790 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28790] = 40
                                    mem[_28790 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29784 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29784 + 68] = mem[_28790 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29784 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29784 + -mem[64] + 132
                                _15817 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15817] = 26
                                mem[_15817 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16654] = 26
                                    mem[_16654 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18544 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18544] = 30
                                        mem[_18544 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20761 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20761] = 30
                                        mem[_20761 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28319 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28319] = 40
                                        mem[_28319 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28319 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20049] = 30
                                        mem[_20049 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22697 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22697] = 30
                                        mem[_22697 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * t / s
                                        emit Transfer(arg3, arg1, arg2);
                                        _29972 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29972] = 40
                                        mem[_29972 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29972 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16655 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16655] = 26
                                    mem[_16655 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18545 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18545] = 30
                                        mem[_18545 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20763 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20763] = 30
                                        mem[_20763 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28321 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28321] = 40
                                        mem[_28321 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28321 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20051 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20051] = 30
                                        mem[_20051 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22699] = 30
                                        mem[_22699 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _29974 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29974] = 40
                                        mem[_29974 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29974 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16087 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16087] = 26
                                    mem[_16087 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16293 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16293 + 68] = mem[_16087 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16293 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16293 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17706] = 30
                                        mem[_17706 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17882 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17882 + 68] = mem[_17706 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17882 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17882 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _23570 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23570] = 40
                                        mem[_23570 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24462 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24462 + 68] = mem[_23570 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24462 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24462 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18570 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18570] = 30
                                    mem[_18570 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19069 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19069 + 68] = mem[_18570 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19069 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19069 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _25495 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25495] = 40
                                    mem[_25495 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _26307 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _26307 + 68] = mem[_25495 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26307 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26307 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16294] = 30
                                    mem[_16294 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16460 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16460 + 68] = mem[_16294 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16460 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16460 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17359] = 30
                                    mem[_17359 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17707 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17707 + 68] = mem[_17359 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17707 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17707 + -mem[64] + 100
                                _16295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16295] = 26
                                mem[_16295 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16461 + 68] = mem[_16295 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16461 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16461 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17884] = 30
                                    mem[_17884 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18185 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18185 + 68] = mem[_17884 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18185 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18185 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _24146 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24146] = 40
                                    mem[_24146 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25190 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25190 + 68] = mem[_24146 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25190 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25190 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19071] = 30
                                mem[_19071 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19510 + 68] = mem[_19071 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19510 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19510 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _26131 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_26131] = 40
                                mem[_26131 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _27406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _27406 + 68] = mem[_26131 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27406 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _27406 + -mem[64] + 132
                            _15829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15829] = 26
                            mem[_15829 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16678] = 26
                                mem[_16678 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18568 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18568] = 30
                                    mem[_18568 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _25491 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25491] = 40
                                    mem[_25491 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25491 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20083 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20083] = 30
                                    mem[_20083 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _27756 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27756] = 40
                                    mem[_27756 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27756 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16679] = 26
                                mem[_16679 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18569 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18569] = 30
                                    mem[_18569 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _25493 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25493] = 40
                                    mem[_25493 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25493 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20085] = 30
                                    mem[_20085 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _27758 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27758] = 40
                                    mem[_27758 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27758 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg1
                            mem[32] = 11
                            if not stor11[address(arg1)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16081] = 26
                                        mem[_16081 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16281 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16281 + 68] = mem[_16081 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16281 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16281 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17700] = 30
                                            mem[_17700 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17867 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17867 + 68] = mem[_17700 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17867 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17867 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21674 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21674] = 40
                                            mem[_21674 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22708 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22708 + 68] = mem[_21674 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22708 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22708 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18552] = 30
                                        mem[_18552 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19050 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19050 + 68] = mem[_18552 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19050 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19050 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23554 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23554] = 40
                                        mem[_23554 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24440 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24440 + 68] = mem[_23554 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24440 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24440 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16282 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16282] = 30
                                        mem[_16282 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16451 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16451 + 68] = mem[_16282 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16451 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16451 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17350] = 30
                                        mem[_17350 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17701 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17701 + 68] = mem[_17350 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17701 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17701 + -mem[64] + 100
                                    _16283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16283] = 26
                                    mem[_16283 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16452 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16452 + 68] = mem[_16283 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16452 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16452 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17869] = 30
                                        mem[_17869 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18173 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18173 + 68] = mem[_17869 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18173 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18173 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22245 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22245] = 40
                                        mem[_22245 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23312 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23312 + 68] = mem[_22245 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23312 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23312 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19052] = 30
                                    mem[_19052 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19487 + 68] = mem[_19052 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19487 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19487 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24120 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24120] = 40
                                    mem[_24120 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25176 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25176 + 68] = mem[_24120 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25176 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25176 + -mem[64] + 132
                                _15820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15820] = 26
                                mem[_15820 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16660] = 26
                                    mem[_16660 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18550] = 30
                                        mem[_18550 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23550 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23550] = 40
                                        mem[_23550 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23550 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20058] = 30
                                        mem[_20058 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25459 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25459] = 40
                                        mem[_25459 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25459 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16661 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16661] = 26
                                    mem[_16661 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18551 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18551] = 30
                                        mem[_18551 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23552 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23552] = 40
                                        mem[_23552 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23552 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20060 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20060] = 30
                                        mem[_20060 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25461 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25461] = 40
                                        mem[_25461 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25461 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                mem[0] = arg2
                                mem[32] = 11
                                if not stor11[address(arg2)]:
                                    idx = 0
                                    s = totalSupply
                                    t = stor16
                                    while idx < stor12.length:
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        if stor5[stor12[idx]] > t:
                                            _16083 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16083] = 26
                                            mem[_16083 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                _16285 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _16285 + 68] = mem[_16083 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16285 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16285 + -mem[64] + 100
                                            if not arg3:
                                                mem[0] = arg1
                                                mem[32] = 5
                                                _17702 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17702] = 30
                                                mem[_17702 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor5[address(arg1)]:
                                                    _17872 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _17872 + 68] = mem[_17702 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17872 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17872 + -mem[64] + 100
                                                if stor5[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor5[arg2] > -1:
                                                    revert with 0, 17
                                                if stor5[arg2] < stor5[arg2]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 5
                                                stor5[address(arg2)] = stor5[arg2]
                                                emit Transfer(arg3, arg1, arg2);
                                                _21677 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_21677] = 40
                                                mem[_21677 + 32 len 40] = code.data[20398 len 40]
                                                mem[32] = sha3(address(arg1), 7)
                                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                    return 1
                                                _22714 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _22714 + 68] = mem[_21677 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_22714 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _22714 + -mem[64] + 132
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18558 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18558] = 30
                                            mem[_18558 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                _19056 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19056 + 68] = mem[_18558 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19056 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19056 + -mem[64] + 100
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                            emit Transfer(arg3, arg1, arg2);
                                            _23560 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23560] = 40
                                            mem[_23560 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _24448 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _24448 + 68] = mem[_23560 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24448 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24448 + -mem[64] + 132
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        if stor6[stor12[idx]] <= s:
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 5
                                            _16286 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16286] = 30
                                            mem[_16286 + 32] = 'SafeMath: subtraction overflow'
                                            if stor5[stor12[idx]] > t:
                                                _16454 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _16454 + 68] = mem[_16286 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16454 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16454 + -mem[64] + 100
                                            if t < stor5[stor12[idx]]:
                                                revert with 0, 17
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 6
                                            _17353 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17353] = 30
                                            mem[_17353 + 32] = 'SafeMath: subtraction overflow'
                                            if stor6[stor12[idx]] <= s:
                                                if s < stor6[stor12[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor6[stor12[idx]]
                                                t = t - stor5[stor12[idx]]
                                                continue 
                                            _17703 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17703 + 68] = mem[_17353 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17703 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17703 + -mem[64] + 100
                                        _16287 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16287] = 26
                                        mem[_16287 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16455 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16455 + 68] = mem[_16287 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16455 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16455 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17874] = 30
                                            mem[_17874 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _18177 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18177 + 68] = mem[_17874 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18177 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18177 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _22260 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22260] = 40
                                            mem[_22260 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _23317 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _23317 + 68] = mem[_22260 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23317 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23317 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _19058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19058] = 30
                                        mem[_19058 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19494 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19494 + 68] = mem[_19058 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19494 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19494 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _24128 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24128] = 40
                                        mem[_24128 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _25183 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _25183 + 68] = mem[_24128 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25183 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25183 + -mem[64] + 132
                                    _15823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15823] = 26
                                    mem[_15823 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if t >= stor16 / totalSupply:
                                        _16666 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16666] = 26
                                        mem[_16666 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18556 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18556] = 30
                                            mem[_18556 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _23556 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23556] = 40
                                            mem[_23556 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23556 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and t / s > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * t / s / arg3 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _20066 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20066] = 30
                                            mem[_20066 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * t / s
                                            if stor5[arg2] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                            emit Transfer(arg3, arg1, arg2);
                                            _25471 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25471] = 40
                                            mem[_25471 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25471 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        _16667 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16667] = 26
                                        mem[_16667 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18557 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18557] = 30
                                            mem[_18557 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _23558 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23558] = 40
                                            mem[_23558 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23558 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _20068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20068] = 30
                                            mem[_20068 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                            emit Transfer(arg3, arg1, arg2);
                                            _25473 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25473] = 40
                                            mem[_25473 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25473 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    idx = 0
                                    s = totalSupply
                                    t = stor16
                                    while idx < stor12.length:
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        if stor5[stor12[idx]] > t:
                                            _16085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16085] = 26
                                            mem[_16085 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                _16289 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _16289 + 68] = mem[_16085 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16289 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16289 + -mem[64] + 100
                                            if not arg3:
                                                mem[0] = arg1
                                                mem[32] = 6
                                                _17704 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17704] = 30
                                                mem[_17704 + 32] = 'SafeMath: subtraction overflow'
                                                if arg3 > stor6[address(arg1)]:
                                                    _17877 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _17877 + 68] = mem[_17704 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17877 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17877 + -mem[64] + 100
                                                if stor6[address(arg1)] < arg3:
                                                    revert with 0, 17
                                                mem[0] = arg1
                                                stor6[address(arg1)] -= arg3
                                                mem[32] = 5
                                                _19063 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19063] = 30
                                                mem[_19063 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor5[address(arg1)]:
                                                    _19500 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _19500 + 68] = mem[_19063 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19500 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19500 + -mem[64] + 100
                                                if stor5[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor6[address(arg2)] > !arg3:
                                                    revert with 0, 17
                                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor6[address(arg2)] += arg3
                                                if stor5[address(arg2)] > -1:
                                                    revert with 0, 17
                                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 5
                                                emit Transfer(arg3, arg1, arg2);
                                                _26123 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26123] = 40
                                                mem[_26123 + 32 len 40] = code.data[20398 len 40]
                                                mem[32] = sha3(address(arg1), 7)
                                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                    return 1
                                                _27398 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _27398 + 68] = mem[_26123 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_27398 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _27398 + -mem[64] + 132
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18564 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18564] = 30
                                            mem[_18564 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _19062 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19062 + 68] = mem[_18564 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19062 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19062 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20782 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20782] = 30
                                            mem[_20782 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                _21408 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21408 + 68] = mem[_20782 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21408 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21408 + -mem[64] + 100
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                            emit Transfer(arg3, arg1, arg2);
                                            _28331 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28331] = 40
                                            mem[_28331 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _29293 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29293 + 68] = mem[_28331 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29293 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29293 + -mem[64] + 132
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        if stor6[stor12[idx]] <= s:
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 5
                                            _16290 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16290] = 30
                                            mem[_16290 + 32] = 'SafeMath: subtraction overflow'
                                            if stor5[stor12[idx]] > t:
                                                _16457 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _16457 + 68] = mem[_16290 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16457 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16457 + -mem[64] + 100
                                            if t < stor5[stor12[idx]]:
                                                revert with 0, 17
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 6
                                            _17356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17356] = 30
                                            mem[_17356 + 32] = 'SafeMath: subtraction overflow'
                                            if stor6[stor12[idx]] <= s:
                                                if s < stor6[stor12[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor6[stor12[idx]]
                                                t = t - stor5[stor12[idx]]
                                                continue 
                                            _17705 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17705 + 68] = mem[_17356 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17705 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17705 + -mem[64] + 100
                                        _16291 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16291] = 26
                                        mem[_16291 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16458 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16458 + 68] = mem[_16291 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16458 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16458 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17879] = 30
                                            mem[_17879 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _18181 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18181 + 68] = mem[_17879 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18181 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18181 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19503 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19503] = 30
                                            mem[_19503 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _20081 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _20081 + 68] = mem[_19503 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_20081 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _20081 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26765 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26765] = 40
                                            mem[_26765 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _28097 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _28097 + 68] = mem[_26765 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28097 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _28097 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _19065 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19065] = 30
                                        mem[_19065 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19502 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19502 + 68] = mem[_19065 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19502 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19502 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _21410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21410] = 30
                                        mem[_21410 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21874 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21874 + 68] = mem[_21410 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21874 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21874 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28826 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28826] = 40
                                        mem[_28826 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29795 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29795 + 68] = mem[_28826 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29795 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29795 + -mem[64] + 132
                                    _15826 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15826] = 26
                                    mem[_15826 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if t >= stor16 / totalSupply:
                                        _16672 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16672] = 26
                                        mem[_16672 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18562 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18562] = 30
                                            mem[_18562 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20779 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20779] = 30
                                            mem[_20779 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _28327 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28327] = 40
                                            mem[_28327 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28327 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and t / s > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * t / s / arg3 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _20074 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20074] = 30
                                            mem[_20074 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _22717 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22717] = 30
                                            mem[_22717 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * t / s
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * t / s
                                            emit Transfer(arg3, arg1, arg2);
                                            _29984 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29984] = 40
                                            mem[_29984 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29984 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        _16673 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16673] = 26
                                        mem[_16673 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18563 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18563] = 30
                                            mem[_18563 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20781 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20781] = 30
                                            mem[_20781 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _28329 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28329] = 40
                                            mem[_28329 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28329 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _20076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20076] = 30
                                            mem[_20076 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _22719 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22719] = 30
                                            mem[_22719 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                            emit Transfer(arg3, arg1, arg2);
                                            _29986 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_29986] = 40
                                            mem[_29986 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_29986 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            mem[450] = '\x19Ethereum Signed Message:\n32'
            mem[478] = sha3(0, DOMAIN_SEPARATOR, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), msg.sender, arg3, nonces[address(arg1)], arg4))
            mem[418] = 60
            mem[64] = 542
            mem[574] = arg5
            mem[606] = arg6
            mem[638] = arg7
            signer = erecover(sha3(Mask(224, 32, '\x19Ethereum Signed Message:\n32') >> 32, sha3(0, DOMAIN_SEPARATOR, sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), msg.sender, arg3, nonces[address(arg1)], arg4))), arg5 << 248, arg6, arg7) 
            mem[510] = signer
            if not erecover.result:
                revert with ext_call.return_data[0 len return_data.size]
            if not address(signer):
                revert with 0, 'EverStake: INVALID_SIGNATURE'
            if address(signer) != arg1:
                revert with 0, 'EverStake: INVALID_SIGNATURE'
            if not arg1:
                revert with 0, 'ERC20: approve from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(arg1)][address(msg.sender)] = arg3
            mem[542] = arg3
            emit Approval(arg3, arg1, msg.sender);
            if not arg1:
                revert with 0, 'ERC20: transfer from the zero address'
            if not arg2:
                revert with 0, 'ERC20: transfer to the zero address'
            if arg3 <= 0:
                revert with 0, 'Transfer amount must be greater than zero'
            if not stor11[address(arg1)]:
                if stor11[address(arg1)]:
                    mem[0] = arg1
                    mem[32] = 11
                    if not stor11[address(arg1)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16091] = 26
                                mem[_16091 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16301 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16301 + 68] = mem[_16091 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16301 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16301 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17710] = 30
                                    mem[_17710 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17892 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17892 + 68] = mem[_17710 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17892 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17892 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _21689 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_21689] = 40
                                    mem[_21689 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _22739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _22739 + 68] = mem[_21689 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22739 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22739 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18582] = 30
                                mem[_18582 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19082 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19082 + 68] = mem[_18582 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19082 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19082 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _23584 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23584] = 40
                                mem[_23584 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _24476 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _24476 + 68] = mem[_23584 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24476 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _24476 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16302] = 30
                                mem[_16302 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16466 + 68] = mem[_16302 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16466 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16466 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17365] = 30
                                mem[_17365 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17711 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17711 + 68] = mem[_17365 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17711 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17711 + -mem[64] + 100
                            _16303 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16303] = 26
                            mem[_16303 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16467 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16467 + 68] = mem[_16303 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16467 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16467 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17894] = 30
                                mem[_17894 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18193 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18193 + 68] = mem[_17894 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18193 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18193 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _22301 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_22301] = 40
                                mem[_22301 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _23338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _23338 + 68] = mem[_22301 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23338 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _23338 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19084 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19084] = 30
                            mem[_19084 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19526 + 68] = mem[_19084 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19526 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19526 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _24157 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24157] = 40
                            mem[_24157 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25202 + 68] = mem[_24157 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25202 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25202 + -mem[64] + 132
                        _15835 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15835] = 26
                        mem[_15835 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16690] = 26
                            mem[_16690 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18580] = 30
                                mem[_18580 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23580 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23580] = 40
                                mem[_23580 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23580 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20100] = 30
                                mem[_20100 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor5[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                emit Transfer(arg3, arg1, arg2);
                                _25502 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25502] = 40
                                mem[_25502 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25502 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16691 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16691] = 26
                            mem[_16691 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18581] = 30
                                mem[_18581 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _23582 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_23582] = 40
                                mem[_23582 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23582 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20102] = 30
                                mem[_20102 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _25504 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25504] = 40
                                mem[_25504 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25504 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if not stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16093] = 26
                                    mem[_16093 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16305 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16305 + 68] = mem[_16093 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16305 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16305 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17712] = 30
                                        mem[_17712 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17897 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17897 + 68] = mem[_17712 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17897 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17897 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21692 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21692] = 40
                                        mem[_21692 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22745 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22745 + 68] = mem[_21692 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22745 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22745 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18588 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18588] = 30
                                    mem[_18588 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19088 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19088 + 68] = mem[_18588 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19088 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19088 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23590 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23590] = 40
                                    mem[_23590 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24484 + 68] = mem[_23590 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24484 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24484 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16306] = 30
                                    mem[_16306 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16469 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16469 + 68] = mem[_16306 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16469 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16469 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17368 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17368] = 30
                                    mem[_17368 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17713 + 68] = mem[_17368 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17713 + -mem[64] + 100
                                _16307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16307] = 26
                                mem[_16307 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16470 + 68] = mem[_16307 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16470 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16470 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17899 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17899] = 30
                                    mem[_17899 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18197 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18197 + 68] = mem[_17899 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18197 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18197 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22316 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22316] = 40
                                    mem[_22316 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23343 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23343 + 68] = mem[_22316 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23343 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23343 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19090] = 30
                                mem[_19090 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19533 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19533 + 68] = mem[_19090 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19533 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19533 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24165 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24165] = 40
                                mem[_24165 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25209 + 68] = mem[_24165 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25209 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25209 + -mem[64] + 132
                            _15838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15838] = 26
                            mem[_15838 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16696] = 26
                                mem[_16696 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18586] = 30
                                    mem[_18586 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23586 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23586] = 40
                                    mem[_23586 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23586 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20108] = 30
                                    mem[_20108 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25514 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25514] = 40
                                    mem[_25514 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25514 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16697] = 26
                                mem[_16697 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18587] = 30
                                    mem[_18587 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23588 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23588] = 40
                                    mem[_23588 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23588 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20110 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20110] = 30
                                    mem[_20110 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25516 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25516] = 40
                                    mem[_25516 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25516 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16095] = 26
                                    mem[_16095 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16309 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16309 + 68] = mem[_16095 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16309 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16309 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17714] = 30
                                        mem[_17714 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _17902 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17902 + 68] = mem[_17714 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17902 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17902 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19095 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19095] = 30
                                        mem[_19095 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _19539 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19539 + 68] = mem[_19095 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19539 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19539 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26141 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26141] = 40
                                        mem[_26141 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _27437 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27437 + 68] = mem[_26141 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27437 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27437 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18594] = 30
                                    mem[_18594 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19094 + 68] = mem[_18594 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19094 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19094 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20812 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20812] = 30
                                    mem[_20812 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21445 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21445 + 68] = mem[_20812 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21445 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21445 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28352 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28352] = 40
                                    mem[_28352 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29325 + 68] = mem[_28352 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29325 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29325 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16310] = 30
                                    mem[_16310 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16472 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16472 + 68] = mem[_16310 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16472 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16472 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17371] = 30
                                    mem[_17371 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17715 + 68] = mem[_17371 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17715 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17715 + -mem[64] + 100
                                _16311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16311] = 26
                                mem[_16311 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16473 + 68] = mem[_16311 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16473 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16473 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _17904 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17904] = 30
                                    mem[_17904 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _18201 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18201 + 68] = mem[_17904 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18201 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18201 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _19542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19542] = 30
                                    mem[_19542 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _20123 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20123 + 68] = mem[_19542 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20123 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20123 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _26839 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_26839] = 40
                                    mem[_26839 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _28130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28130 + 68] = mem[_26839 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28130 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28130 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 6
                                _19097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19097] = 30
                                mem[_19097 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _19541 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19541 + 68] = mem[_19097 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19541 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19541 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _21447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21447] = 30
                                mem[_21447 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _21911 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21911 + 68] = mem[_21447 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21911 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21911 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _28884 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28884] = 40
                                mem[_28884 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _29822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29822 + 68] = mem[_28884 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29822 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29822 + -mem[64] + 132
                            _15841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15841] = 26
                            mem[_15841 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16702] = 26
                                mem[_16702 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18592] = 30
                                    mem[_18592 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20809 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20809] = 30
                                    mem[_20809 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28348 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28348] = 40
                                    mem[_28348 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28348 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20116] = 30
                                    mem[_20116 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22748 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22748] = 30
                                    mem[_22748 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _30007 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30007] = 40
                                    mem[_30007 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30007 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16703 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16703] = 26
                                mem[_16703 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _18593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18593] = 30
                                    mem[_18593 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _20811 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20811] = 30
                                    mem[_20811 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _28350 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28350] = 40
                                    mem[_28350 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28350 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _20118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20118] = 30
                                    mem[_20118 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _22750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22750] = 30
                                    mem[_22750 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _30009 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30009] = 40
                                    mem[_30009 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30009 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 11
                    if stor11[address(arg2)]:
                        idx = 0
                        s = totalSupply
                        t = stor16
                        while idx < stor12.length:
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            if stor5[stor12[idx]] > t:
                                _16103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16103] = 26
                                mem[_16103 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16325 + 68] = mem[_16103 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16325 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16325 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17722] = 30
                                    mem[_17722 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _17922 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17922 + 68] = mem[_17722 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17922 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17922 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _23620 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23620] = 40
                                    mem[_23620 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24521 + 68] = mem[_23620 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24521 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24521 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _18618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18618] = 30
                                mem[_18618 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19120 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19120 + 68] = mem[_18618 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19120 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19120 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _25570 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25570] = 40
                                mem[_25570 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _26362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _26362 + 68] = mem[_25570 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26362 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _26362 + -mem[64] + 132
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            if stor6[stor12[idx]] <= s:
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                _16326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16326] = 30
                                mem[_16326 + 32] = 'SafeMath: subtraction overflow'
                                if stor5[stor12[idx]] > t:
                                    _16484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16484 + 68] = mem[_16326 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16484 + -mem[64] + 100
                                if t < stor5[stor12[idx]]:
                                    revert with 0, 17
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                _17383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17383] = 30
                                mem[_17383 + 32] = 'SafeMath: subtraction overflow'
                                if stor6[stor12[idx]] <= s:
                                    if s < stor6[stor12[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor6[stor12[idx]]
                                    t = t - stor5[stor12[idx]]
                                    continue 
                                _17723 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17723 + 68] = mem[_17383 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17723 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17723 + -mem[64] + 100
                            _16327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16327] = 26
                            mem[_16327 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16485 + 68] = mem[_16327 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16485 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16485 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _17924 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17924] = 30
                                mem[_17924 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _18217 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18217 + 68] = mem[_17924 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18217 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18217 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _24200 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24200] = 40
                                mem[_24200 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25233 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25233 + 68] = mem[_24200 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25233 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25233 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 5
                            _19122 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19122] = 30
                            mem[_19122 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _19572 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19572 + 68] = mem[_19122 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19572 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19572 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor6[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor6[address(arg2)] += arg3
                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                            emit Transfer(arg3, arg1, arg2);
                            _26153 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26153] = 40
                            mem[_26153 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _27469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _27469 + 68] = mem[_26153 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27469 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _27469 + -mem[64] + 132
                        _15853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15853] = 26
                        mem[_15853 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if t >= stor16 / totalSupply:
                            _16726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16726] = 26
                            mem[_16726 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18616] = 30
                                mem[_18616 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25566 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25566] = 40
                                mem[_25566 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25566 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20150 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20150] = 30
                                mem[_20150 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * t / s
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * t / s
                                emit Transfer(arg3, arg1, arg2);
                                _27821 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27821] = 40
                                mem[_27821 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27821 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _16727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16727] = 26
                            mem[_16727 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 5
                                _18617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18617] = 30
                                mem[_18617 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                emit Transfer(arg3, arg1, arg2);
                                _25568 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_25568] = 40
                                mem[_25568 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25568 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _20152 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20152] = 30
                                mem[_20152 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _27823 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27823] = 40
                                mem[_27823 + 32 len 40] = code.data[20398 len 40]
                                if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27823 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16097 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16097] = 26
                                    mem[_16097 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16313 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16313 + 68] = mem[_16097 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16313 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16313 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17716] = 30
                                        mem[_17716 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17907 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17907 + 68] = mem[_17716 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17907 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17907 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21699 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21699] = 40
                                        mem[_21699 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22759 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22759 + 68] = mem[_21699 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22759 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22759 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18600 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18600] = 30
                                    mem[_18600 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19101 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19101 + 68] = mem[_18600 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19101 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19101 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23604 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23604] = 40
                                    mem[_23604 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24499 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24499 + 68] = mem[_23604 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24499 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24499 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16314] = 30
                                    mem[_16314 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16475 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16475 + 68] = mem[_16314 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16475 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16475 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17374] = 30
                                    mem[_17374 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17717 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17717 + 68] = mem[_17374 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17717 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17717 + -mem[64] + 100
                                _16315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16315] = 26
                                mem[_16315 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16476 + 68] = mem[_16315 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16476 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16476 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17909] = 30
                                    mem[_17909 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18205 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18205 + 68] = mem[_17909 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18205 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18205 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22336 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22336] = 40
                                    mem[_22336 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23354 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23354 + 68] = mem[_22336 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23354 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23354 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19103] = 30
                                mem[_19103 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19549 + 68] = mem[_19103 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19549 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24174 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24174] = 40
                                mem[_24174 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25219 + 68] = mem[_24174 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25219 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25219 + -mem[64] + 132
                            _15844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15844] = 26
                            mem[_15844 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16708 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16708] = 26
                                mem[_16708 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18598 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18598] = 30
                                    mem[_18598 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23600 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23600] = 40
                                    mem[_23600 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23600 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20125 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20125] = 30
                                    mem[_20125 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25534 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25534] = 40
                                    mem[_25534 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25534 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16709] = 26
                                mem[_16709 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18599] = 30
                                    mem[_18599 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23602 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23602] = 40
                                    mem[_23602 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23602 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20127] = 30
                                    mem[_20127 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25536 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25536] = 40
                                    mem[_25536 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25536 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg2
                            mem[32] = 11
                            if not stor11[address(arg2)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16099 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16099] = 26
                                        mem[_16099 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16317 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16317 + 68] = mem[_16099 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16317 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16317 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17718 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17718] = 30
                                            mem[_17718 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17912 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17912 + 68] = mem[_17718 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17912 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17912 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21702 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21702] = 40
                                            mem[_21702 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22765 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22765 + 68] = mem[_21702 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22765 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22765 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18606] = 30
                                        mem[_18606 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19107 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19107 + 68] = mem[_18606 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19107 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19107 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23610 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23610] = 40
                                        mem[_23610 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24507 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24507 + 68] = mem[_23610 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24507 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24507 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16318] = 30
                                        mem[_16318 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16478 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16478 + 68] = mem[_16318 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16478 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16478 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17377 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17377] = 30
                                        mem[_17377 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17719 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17719 + 68] = mem[_17377 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17719 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17719 + -mem[64] + 100
                                    _16319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16319] = 26
                                    mem[_16319 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16479 + 68] = mem[_16319 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16479 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16479 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17914] = 30
                                        mem[_17914 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18209 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18209 + 68] = mem[_17914 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18209 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18209 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22351 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22351] = 40
                                        mem[_22351 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23359 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23359 + 68] = mem[_22351 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23359 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23359 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19109] = 30
                                    mem[_19109 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19556 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19556 + 68] = mem[_19109 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19556 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19556 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24182 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24182] = 40
                                    mem[_24182 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25226 + 68] = mem[_24182 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25226 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25226 + -mem[64] + 132
                                _15847 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15847] = 26
                                mem[_15847 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16714 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16714] = 26
                                    mem[_16714 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18604 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18604] = 30
                                        mem[_18604 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23606 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23606] = 40
                                        mem[_23606 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23606 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20133 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20133] = 30
                                        mem[_20133 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25546 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25546] = 40
                                        mem[_25546 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25546 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16715 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16715] = 26
                                    mem[_16715 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18605 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18605] = 30
                                        mem[_18605 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23608 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23608] = 40
                                        mem[_23608 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23608 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20135 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20135] = 30
                                        mem[_20135 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25548 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25548] = 40
                                        mem[_25548 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25548 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16101] = 26
                                        mem[_16101 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16321 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16321 + 68] = mem[_16101 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16321 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16321 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17720 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17720] = 30
                                            mem[_17720 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _17917 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17917 + 68] = mem[_17720 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17917 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17917 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19114] = 30
                                            mem[_19114 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _19562 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19562 + 68] = mem[_19114 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19562 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19562 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26145 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26145] = 40
                                            mem[_26145 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _27461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27461 + 68] = mem[_26145 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27461 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27461 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18612 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18612] = 30
                                        mem[_18612 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19113 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19113 + 68] = mem[_18612 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19113 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19113 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20830] = 30
                                        mem[_20830 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21467 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21467 + 68] = mem[_20830 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21467 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21467 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28360 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28360] = 40
                                        mem[_28360 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29341 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29341 + 68] = mem[_28360 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29341 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29341 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16322] = 30
                                        mem[_16322 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16481 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16481 + 68] = mem[_16322 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16481 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16481 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17380] = 30
                                        mem[_17380 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17721 + 68] = mem[_17380 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17721 + -mem[64] + 100
                                    _16323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16323] = 26
                                    mem[_16323 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16482 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16482 + 68] = mem[_16323 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16482 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16482 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17919] = 30
                                        mem[_17919 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18213 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18213 + 68] = mem[_17919 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18213 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18213 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19565] = 30
                                        mem[_19565 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _20148 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20148 + 68] = mem[_19565 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20148 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20148 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26898 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26898] = 40
                                        mem[_26898 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _28147 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28147 + 68] = mem[_26898 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28147 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28147 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19116] = 30
                                    mem[_19116 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19564 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19564 + 68] = mem[_19116 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19564 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19564 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _21469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21469] = 30
                                    mem[_21469 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21933 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21933 + 68] = mem[_21469 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21933 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21933 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28920 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28920] = 40
                                    mem[_28920 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29833 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29833 + 68] = mem[_28920 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29833 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29833 + -mem[64] + 132
                                _15850 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15850] = 26
                                mem[_15850 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16720] = 26
                                    mem[_16720 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18610 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18610] = 30
                                        mem[_18610 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20827] = 30
                                        mem[_20827 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28356 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28356] = 40
                                        mem[_28356 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28356 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20141] = 30
                                        mem[_20141 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22768 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22768] = 30
                                        mem[_22768 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * t / s
                                        emit Transfer(arg3, arg1, arg2);
                                        _30019 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30019] = 40
                                        mem[_30019 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30019 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16721 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16721] = 26
                                    mem[_16721 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18611 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18611] = 30
                                        mem[_18611 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20829] = 30
                                        mem[_20829 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28358 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28358] = 40
                                        mem[_28358 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28358 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20143] = 30
                                        mem[_20143 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22770 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22770] = 30
                                        mem[_22770 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _30021 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30021] = 40
                                        mem[_30021 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30021 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 11
                if not stor11[address(arg2)]:
                    idx = 0
                    s = totalSupply
                    t = stor16
                    while idx < stor12.length:
                        mem[0] = stor12[idx]
                        mem[32] = 5
                        if stor5[stor12[idx]] > t:
                            _16119 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16119] = 26
                            mem[_16119 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _16357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16357 + 68] = mem[_16119 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16357 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16357 + -mem[64] + 100
                            if not arg3:
                                mem[0] = arg1
                                mem[32] = 6
                                _17738 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17738] = 30
                                mem[_17738 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor6[address(arg1)]:
                                    _17962 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17962 + 68] = mem[_17738 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17962 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17962 + -mem[64] + 100
                                if stor6[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor6[address(arg1)] -= arg3
                                mem[32] = 5
                                _19171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19171] = 30
                                mem[_19171 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor5[address(arg1)]:
                                    _19631 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19631 + 68] = mem[_19171 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19631 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19631 + -mem[64] + 100
                                if stor5[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor5[arg2] > -1:
                                    revert with 0, 17
                                if stor5[arg2] < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2]
                                emit Transfer(arg3, arg1, arg2);
                                _24253 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24253] = 40
                                mem[_24253 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25274 + 68] = mem[_24253 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25274 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25274 + -mem[64] + 132
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _18666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18666] = 30
                            mem[_18666 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _19170 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19170 + 68] = mem[_18666 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19170 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19170 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20882] = 30
                            mem[_20882 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                _21531 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21531 + 68] = mem[_20882 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21531 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21531 + -mem[64] + 100
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _26175 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26175] = 40
                            mem[_26175 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _27530 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _27530 + 68] = mem[_26175 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27530 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _27530 + -mem[64] + 132
                        if idx >= stor12.length:
                            revert with 0, 50
                        mem[0] = stor12[idx]
                        mem[32] = 6
                        if stor6[stor12[idx]] <= s:
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 5
                            _16358 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16358] = 30
                            mem[_16358 + 32] = 'SafeMath: subtraction overflow'
                            if stor5[stor12[idx]] > t:
                                _16508 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16508 + 68] = mem[_16358 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16508 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16508 + -mem[64] + 100
                            if t < stor5[stor12[idx]]:
                                revert with 0, 17
                            if idx >= stor12.length:
                                revert with 0, 50
                            mem[0] = stor12[idx]
                            mem[32] = 6
                            _17407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17407] = 30
                            mem[_17407 + 32] = 'SafeMath: subtraction overflow'
                            if stor6[stor12[idx]] <= s:
                                if s < stor6[stor12[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor6[stor12[idx]]
                                t = t - stor5[stor12[idx]]
                                continue 
                            _17739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17739 + 68] = mem[_17407 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17739 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17739 + -mem[64] + 100
                        _16359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16359] = 26
                        mem[_16359 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _16509 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16509 + 68] = mem[_16359 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16509 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16509 + -mem[64] + 100
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _17964 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17964] = 30
                            mem[_17964 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                _18249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18249 + 68] = mem[_17964 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18249 + -mem[64] + 100
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _19634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19634] = 30
                            mem[_19634 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                _20223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20223 + 68] = mem[_19634 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20223 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20223 + -mem[64] + 100
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _24974 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_24974] = 40
                            mem[_24974 + 32 len 40] = code.data[20398 len 40]
                            mem[32] = sha3(address(arg1), 7)
                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                return 1
                            _25997 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _25997 + 68] = mem[_24974 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25997 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _25997 + -mem[64] + 132
                        if arg3 and stor16 / totalSupply > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[0] = arg1
                        mem[32] = 6
                        _19173 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19173] = 30
                        mem[_19173 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor6[address(arg1)]:
                            _19633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19633 + 68] = mem[_19173 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19633 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19633 + -mem[64] + 100
                        if stor6[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor6[address(arg1)] -= arg3
                        mem[32] = 5
                        _21533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21533] = 30
                        mem[_21533 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                            _21999 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21999 + 68] = mem[_21533 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21999 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21999 + -mem[64] + 100
                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                            revert with 0, 17
                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                            revert with 0, 17
                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 5
                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                        emit Transfer(arg3, arg1, arg2);
                        _27038 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_27038] = 40
                        mem[_27038 + 32 len 40] = code.data[20398 len 40]
                        mem[32] = sha3(address(arg1), 7)
                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] -= arg3
                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                            return 1
                        _28205 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _28205 + 68] = mem[_27038 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_28205 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _28205 + -mem[64] + 132
                    _15877 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15877] = 26
                    mem[_15877 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor16 / totalSupply:
                        _16774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16774] = 26
                        mem[_16774 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _18664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18664] = 30
                            mem[_18664 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20879] = 30
                            mem[_20879 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _26171 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26171] = 40
                            mem[_26171 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26171 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _20216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20216] = 30
                            mem[_20216 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _22822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22822] = 30
                            mem[_22822 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * t / s
                            if stor5[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                            emit Transfer(arg3, arg1, arg2);
                            _28380 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28380] = 40
                            mem[_28380 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28380 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _16775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16775] = 26
                        mem[_16775 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            mem[0] = arg1
                            mem[32] = 6
                            _18665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18665] = 30
                            mem[_18665 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _20881 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20881] = 30
                            mem[_20881 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < 0:
                                revert with 0, 17
                            if stor5[arg2] > -1:
                                revert with 0, 17
                            if stor5[arg2] < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2]
                            emit Transfer(arg3, arg1, arg2);
                            _26173 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_26173] = 40
                            mem[_26173 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_26173 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[0] = arg1
                            mem[32] = 6
                            _20218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20218] = 30
                            mem[_20218 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor6[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor6[address(arg1)] -= arg3
                            mem[32] = 5
                            _22824 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22824] = 30
                            mem[_22824 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                revert with 0, 17
                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                revert with 0, 17
                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 5
                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                            emit Transfer(arg3, arg1, arg2);
                            _28382 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28382] = 40
                            mem[_28382 + 32 len 40] = code.data[20398 len 40]
                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28382 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if stor11[address(arg1)]:
                        mem[0] = arg1
                        mem[32] = 11
                        if not stor11[address(arg1)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16105] = 26
                                    mem[_16105 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16329 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16329 + 68] = mem[_16105 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16329 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16329 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17724 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17724] = 30
                                        mem[_17724 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17927 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17927 + 68] = mem[_17724 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17927 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17927 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _21710 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_21710] = 40
                                        mem[_21710 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _22782 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _22782 + 68] = mem[_21710 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22782 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22782 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18624] = 30
                                    mem[_18624 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19126 + 68] = mem[_18624 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19126 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19126 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _23626 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23626] = 40
                                    mem[_23626 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _24528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _24528 + 68] = mem[_23626 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24528 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24528 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16330] = 30
                                    mem[_16330 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16487 + 68] = mem[_16330 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16487 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16487 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17386] = 30
                                    mem[_17386 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17725 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17725 + 68] = mem[_17386 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17725 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17725 + -mem[64] + 100
                                _16331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16331] = 26
                                mem[_16331 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16488 + 68] = mem[_16331 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16488 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16488 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17929 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17929] = 30
                                    mem[_17929 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18221 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18221 + 68] = mem[_17929 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18221 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18221 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _22387 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_22387] = 40
                                    mem[_22387 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _23373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _23373 + 68] = mem[_22387 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23373 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23373 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19128 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19128] = 30
                                mem[_19128 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19579 + 68] = mem[_19128 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19579 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19579 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                emit Transfer(arg3, arg1, arg2);
                                _24208 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_24208] = 40
                                mem[_24208 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _25239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _25239 + 68] = mem[_24208 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25239 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _25239 + -mem[64] + 132
                            _15856 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15856] = 26
                            mem[_15856 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16732] = 26
                                mem[_16732 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18622] = 30
                                    mem[_18622 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23622 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23622] = 40
                                    mem[_23622 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23622 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20158] = 30
                                    mem[_20158 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor5[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25572 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25572] = 40
                                    mem[_25572 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25572 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16733] = 26
                                mem[_16733 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18623] = 30
                                    mem[_18623 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor5[arg2] > -1:
                                        revert with 0, 17
                                    if stor5[arg2] < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2]
                                    emit Transfer(arg3, arg1, arg2);
                                    _23624 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_23624] = 40
                                    mem[_23624 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23624 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20160] = 30
                                    mem[_20160 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _25574 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25574] = 40
                                    mem[_25574 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25574 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg2
                            mem[32] = 11
                            if not stor11[address(arg2)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16107] = 26
                                        mem[_16107 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16333 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16333 + 68] = mem[_16107 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16333 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16333 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17726 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17726] = 30
                                            mem[_17726 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17932 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17932 + 68] = mem[_17726 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17932 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17932 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21713 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21713] = 40
                                            mem[_21713 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22788 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22788 + 68] = mem[_21713 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22788 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22788 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18630 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18630] = 30
                                        mem[_18630 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19132 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19132 + 68] = mem[_18630 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19132 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19132 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23632 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23632] = 40
                                        mem[_23632 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24536 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24536 + 68] = mem[_23632 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24536 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24536 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16334 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16334] = 30
                                        mem[_16334 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16490 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16490 + 68] = mem[_16334 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16490 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16490 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17389 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17389] = 30
                                        mem[_17389 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17727 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17727 + 68] = mem[_17389 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17727 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17727 + -mem[64] + 100
                                    _16335 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16335] = 26
                                    mem[_16335 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16491 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16491 + 68] = mem[_16335 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16491 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16491 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17934 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17934] = 30
                                        mem[_17934 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18225 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18225 + 68] = mem[_17934 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18225 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18225 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22402 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22402] = 40
                                        mem[_22402 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23378 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23378 + 68] = mem[_22402 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23378 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23378 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19134] = 30
                                    mem[_19134 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19586 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19586 + 68] = mem[_19134 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19586 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19586 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24216 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24216] = 40
                                    mem[_24216 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25246 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25246 + 68] = mem[_24216 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25246 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25246 + -mem[64] + 132
                                _15859 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15859] = 26
                                mem[_15859 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16738] = 26
                                    mem[_16738 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18628 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18628] = 30
                                        mem[_18628 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23628 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23628] = 40
                                        mem[_23628 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23628 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20166] = 30
                                        mem[_20166 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25584 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25584] = 40
                                        mem[_25584 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25584 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16739] = 26
                                    mem[_16739 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18629] = 30
                                        mem[_18629 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23630 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23630] = 40
                                        mem[_23630 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23630 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20168 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20168] = 30
                                        mem[_20168 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25586 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25586] = 40
                                        mem[_25586 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25586 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16109 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16109] = 26
                                        mem[_16109 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16337 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16337 + 68] = mem[_16109 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16337 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16337 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17728 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17728] = 30
                                            mem[_17728 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _17937 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17937 + 68] = mem[_17728 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17937 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17937 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19139 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19139] = 30
                                            mem[_19139 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _19592 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19592 + 68] = mem[_19139 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19592 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19592 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _26157 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26157] = 40
                                            mem[_26157 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _27492 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27492 + 68] = mem[_26157 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27492 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27492 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18636] = 30
                                        mem[_18636 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19138 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19138 + 68] = mem[_18636 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19138 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19138 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20852] = 30
                                        mem[_20852 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21494 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21494 + 68] = mem[_20852 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21494 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21494 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _28369 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28369] = 40
                                        mem[_28369 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29366 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29366 + 68] = mem[_28369 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29366 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29366 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16338 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16338] = 30
                                        mem[_16338 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16493 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16493 + 68] = mem[_16338 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16493 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16493 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17392 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17392] = 30
                                        mem[_17392 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17729 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17729 + 68] = mem[_17392 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17729 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17729 + -mem[64] + 100
                                    _16339 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16339] = 26
                                    mem[_16339 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16494 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16494 + 68] = mem[_16339 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16494 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16494 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _17939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17939] = 30
                                        mem[_17939 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _18229 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18229 + 68] = mem[_17939 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18229 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18229 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _19595 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19595] = 30
                                        mem[_19595 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _20181 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20181 + 68] = mem[_19595 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20181 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20181 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _26964 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_26964] = 40
                                        mem[_26964 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _28173 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28173 + 68] = mem[_26964 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28173 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28173 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 6
                                    _19141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19141] = 30
                                    mem[_19141 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 > stor6[address(arg1)]:
                                        _19594 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19594 + 68] = mem[_19141 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19594 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19594 + -mem[64] + 100
                                    if stor6[address(arg1)] < arg3:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    stor6[address(arg1)] -= arg3
                                    mem[32] = 5
                                    _21496 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21496] = 30
                                    mem[_21496 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _21962 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21962 + 68] = mem[_21496 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21962 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21962 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _28977 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28977] = 40
                                    mem[_28977 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _29851 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29851 + 68] = mem[_28977 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29851 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29851 + -mem[64] + 132
                                _15862 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15862] = 26
                                mem[_15862 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16744] = 26
                                    mem[_16744 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18634] = 30
                                        mem[_18634 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20849] = 30
                                        mem[_20849 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28365 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28365] = 40
                                        mem[_28365 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28365 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20174] = 30
                                        mem[_20174 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22791 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22791] = 30
                                        mem[_22791 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * t / s
                                        emit Transfer(arg3, arg1, arg2);
                                        _30032 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30032] = 40
                                        mem[_30032 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30032 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16745] = 26
                                    mem[_16745 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _18635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18635] = 30
                                        mem[_18635 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _20851 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20851] = 30
                                        mem[_20851 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _28367 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28367] = 40
                                        mem[_28367 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28367 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _20176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20176] = 30
                                        mem[_20176 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _22793 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22793] = 30
                                        mem[_22793 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _30034 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30034] = 40
                                        mem[_30034 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30034 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 11
                        if stor11[address(arg2)]:
                            idx = 0
                            s = totalSupply
                            t = stor16
                            while idx < stor12.length:
                                mem[0] = stor12[idx]
                                mem[32] = 5
                                if stor5[stor12[idx]] > t:
                                    _16117 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16117] = 26
                                    mem[_16117 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16353 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16353 + 68] = mem[_16117 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16353 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16353 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17736 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17736] = 30
                                        mem[_17736 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _17957 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17957 + 68] = mem[_17736 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17957 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17957 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor5[address(arg2)] < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        emit Transfer(arg3, arg1, arg2);
                                        _23662 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23662] = 40
                                        mem[_23662 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24573 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24573 + 68] = mem[_23662 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24573 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24573 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18660] = 30
                                    mem[_18660 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19164 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19164 + 68] = mem[_18660 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19164 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19164 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _25640 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25640] = 40
                                    mem[_25640 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _26410 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _26410 + 68] = mem[_25640 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26410 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26410 + -mem[64] + 132
                                if idx >= stor12.length:
                                    revert with 0, 50
                                mem[0] = stor12[idx]
                                mem[32] = 6
                                if stor6[stor12[idx]] <= s:
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    _16354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16354] = 30
                                    mem[_16354 + 32] = 'SafeMath: subtraction overflow'
                                    if stor5[stor12[idx]] > t:
                                        _16505 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16505 + 68] = mem[_16354 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16505 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16505 + -mem[64] + 100
                                    if t < stor5[stor12[idx]]:
                                        revert with 0, 17
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    _17404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17404] = 30
                                    mem[_17404 + 32] = 'SafeMath: subtraction overflow'
                                    if stor6[stor12[idx]] <= s:
                                        if s < stor6[stor12[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor6[stor12[idx]]
                                        t = t - stor5[stor12[idx]]
                                        continue 
                                    _17737 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17737 + 68] = mem[_17404 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17737 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17737 + -mem[64] + 100
                                _16355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16355] = 26
                                mem[_16355 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _16506 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _16506 + 68] = mem[_16355 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16506 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16506 + -mem[64] + 100
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _17959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17959] = 30
                                    mem[_17959 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        _18245 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18245 + 68] = mem[_17959 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18245 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18245 + -mem[64] + 100
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _24251 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24251] = 40
                                    mem[_24251 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25270 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25270 + 68] = mem[_24251 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25270 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25270 + -mem[64] + 132
                                if arg3 and stor16 / totalSupply > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[0] = arg1
                                mem[32] = 5
                                _19166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19166] = 30
                                mem[_19166 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                    _19625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19625 + 68] = mem[_19166 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19625 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19625 + -mem[64] + 100
                                if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                    revert with 0, 17
                                stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                if stor6[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor6[address(arg2)] += arg3
                                if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                    revert with 0, 17
                                if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 5
                                stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                emit Transfer(arg3, arg1, arg2);
                                _26169 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_26169] = 40
                                mem[_26169 + 32 len 40] = code.data[20398 len 40]
                                mem[32] = sha3(address(arg1), 7)
                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                    return 1
                                _27524 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _27524 + 68] = mem[_26169 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27524 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _27524 + -mem[64] + 132
                            _15874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15874] = 26
                            mem[_15874 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero', 0
                            if t >= stor16 / totalSupply:
                                _16768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16768] = 26
                                mem[_16768 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18658 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18658] = 30
                                    mem[_18658 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _25636 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25636] = 40
                                    mem[_25636 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25636 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20208] = 30
                                    mem[_20208 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * t / s
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * t / s
                                    emit Transfer(arg3, arg1, arg2);
                                    _27879 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27879] = 40
                                    mem[_27879 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27879 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _16769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16769] = 26
                                mem[_16769 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _18659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18659] = 30
                                    mem[_18659 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor5[address(arg2)] < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    emit Transfer(arg3, arg1, arg2);
                                    _25638 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_25638] = 40
                                    mem[_25638 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25638 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _20210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20210] = 30
                                    mem[_20210 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor6[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor6[address(arg2)] += arg3
                                    if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                    emit Transfer(arg3, arg1, arg2);
                                    _27881 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27881] = 40
                                    mem[_27881 + 32 len 40] = code.data[20398 len 40]
                                    if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_27881 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            mem[0] = arg1
                            mem[32] = 11
                            if not stor11[address(arg1)]:
                                idx = 0
                                s = totalSupply
                                t = stor16
                                while idx < stor12.length:
                                    mem[0] = stor12[idx]
                                    mem[32] = 5
                                    if stor5[stor12[idx]] > t:
                                        _16111 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16111] = 26
                                        mem[_16111 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16341 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16341 + 68] = mem[_16111 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16341 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16341 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17730 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17730] = 30
                                            mem[_17730 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _17942 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17942 + 68] = mem[_17730 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17942 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17942 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _21720 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_21720] = 40
                                            mem[_21720 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _22802 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _22802 + 68] = mem[_21720 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22802 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22802 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18642] = 30
                                        mem[_18642 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19145 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19145 + 68] = mem[_18642 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19145 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19145 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _23646 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23646] = 40
                                        mem[_23646 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _24551 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _24551 + 68] = mem[_23646 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24551 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24551 + -mem[64] + 132
                                    if idx >= stor12.length:
                                        revert with 0, 50
                                    mem[0] = stor12[idx]
                                    mem[32] = 6
                                    if stor6[stor12[idx]] <= s:
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        _16342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16342] = 30
                                        mem[_16342 + 32] = 'SafeMath: subtraction overflow'
                                        if stor5[stor12[idx]] > t:
                                            _16496 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16496 + 68] = mem[_16342 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16496 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16496 + -mem[64] + 100
                                        if t < stor5[stor12[idx]]:
                                            revert with 0, 17
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        _17395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17395] = 30
                                        mem[_17395 + 32] = 'SafeMath: subtraction overflow'
                                        if stor6[stor12[idx]] <= s:
                                            if s < stor6[stor12[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor6[stor12[idx]]
                                            t = t - stor5[stor12[idx]]
                                            continue 
                                        _17731 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17731 + 68] = mem[_17395 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17731 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17731 + -mem[64] + 100
                                    _16343 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16343] = 26
                                    mem[_16343 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        _16497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _16497 + 68] = mem[_16343 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16497 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16497 + -mem[64] + 100
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _17944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17944] = 30
                                        mem[_17944 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            _18233 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18233 + 68] = mem[_17944 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18233 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18233 + -mem[64] + 100
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _22422 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_22422] = 40
                                        mem[_22422 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _23389 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _23389 + 68] = mem[_22422 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23389 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23389 + -mem[64] + 132
                                    if arg3 and stor16 / totalSupply > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[0] = arg1
                                    mem[32] = 5
                                    _19147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19147] = 30
                                    mem[_19147 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                        _19602 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19602 + 68] = mem[_19147 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19602 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19602 + -mem[64] + 100
                                    if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                        revert with 0, 17
                                    stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                    if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                        revert with 0, 17
                                    if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 5
                                    stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                    emit Transfer(arg3, arg1, arg2);
                                    _24225 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_24225] = 40
                                    mem[_24225 + 32 len 40] = code.data[20398 len 40]
                                    mem[32] = sha3(address(arg1), 7)
                                    if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                        if allowance[address(arg1)][address(msg.sender)] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] -= arg3
                                        emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                        return 1
                                    _25256 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _25256 + 68] = mem[_24225 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25256 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25256 + -mem[64] + 132
                                _15865 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15865] = 26
                                mem[_15865 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if t >= stor16 / totalSupply:
                                    _16750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16750] = 26
                                    mem[_16750 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18640] = 30
                                        mem[_18640 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23642 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23642] = 40
                                        mem[_23642 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23642 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20183] = 30
                                        mem[_20183 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * t / s
                                        if stor5[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25604 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25604] = 40
                                        mem[_25604 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25604 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _16751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16751] = 26
                                    mem[_16751 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _18641 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18641] = 30
                                        mem[_18641 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor5[arg2] > -1:
                                            revert with 0, 17
                                        if stor5[arg2] < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2]
                                        emit Transfer(arg3, arg1, arg2);
                                        _23644 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23644] = 40
                                        mem[_23644 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23644 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _20185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20185] = 30
                                        mem[_20185 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _25606 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25606] = 40
                                        mem[_25606 + 32 len 40] = code.data[20398 len 40]
                                        if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25606 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                mem[0] = arg2
                                mem[32] = 11
                                if not stor11[address(arg2)]:
                                    idx = 0
                                    s = totalSupply
                                    t = stor16
                                    while idx < stor12.length:
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        if stor5[stor12[idx]] > t:
                                            _16113 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16113] = 26
                                            mem[_16113 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                _16345 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _16345 + 68] = mem[_16113 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16345 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16345 + -mem[64] + 100
                                            if not arg3:
                                                mem[0] = arg1
                                                mem[32] = 5
                                                _17732 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17732] = 30
                                                mem[_17732 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor5[address(arg1)]:
                                                    _17947 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _17947 + 68] = mem[_17732 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17947 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17947 + -mem[64] + 100
                                                if stor5[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor5[arg2] > -1:
                                                    revert with 0, 17
                                                if stor5[arg2] < stor5[arg2]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 5
                                                stor5[address(arg2)] = stor5[arg2]
                                                emit Transfer(arg3, arg1, arg2);
                                                _21723 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_21723] = 40
                                                mem[_21723 + 32 len 40] = code.data[20398 len 40]
                                                mem[32] = sha3(address(arg1), 7)
                                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                    return 1
                                                _22808 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _22808 + 68] = mem[_21723 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_22808 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _22808 + -mem[64] + 132
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18648] = 30
                                            mem[_18648 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                _19151 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19151 + 68] = mem[_18648 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19151 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19151 + -mem[64] + 100
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                            emit Transfer(arg3, arg1, arg2);
                                            _23652 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23652] = 40
                                            mem[_23652 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _24559 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _24559 + 68] = mem[_23652 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24559 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24559 + -mem[64] + 132
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        if stor6[stor12[idx]] <= s:
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 5
                                            _16346 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16346] = 30
                                            mem[_16346 + 32] = 'SafeMath: subtraction overflow'
                                            if stor5[stor12[idx]] > t:
                                                _16499 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _16499 + 68] = mem[_16346 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16499 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16499 + -mem[64] + 100
                                            if t < stor5[stor12[idx]]:
                                                revert with 0, 17
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 6
                                            _17398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17398] = 30
                                            mem[_17398 + 32] = 'SafeMath: subtraction overflow'
                                            if stor6[stor12[idx]] <= s:
                                                if s < stor6[stor12[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor6[stor12[idx]]
                                                t = t - stor5[stor12[idx]]
                                                continue 
                                            _17733 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17733 + 68] = mem[_17398 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17733 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17733 + -mem[64] + 100
                                        _16347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16347] = 26
                                        mem[_16347 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16500 + 68] = mem[_16347 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16500 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16500 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _17949 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17949] = 30
                                            mem[_17949 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _18237 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18237 + 68] = mem[_17949 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18237 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18237 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _22437 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_22437] = 40
                                            mem[_22437 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _23394 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _23394 + 68] = mem[_22437 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23394 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23394 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 5
                                        _19153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19153] = 30
                                        mem[_19153 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _19609 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19609 + 68] = mem[_19153 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19609 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19609 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                        emit Transfer(arg3, arg1, arg2);
                                        _24233 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24233] = 40
                                        mem[_24233 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _25263 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _25263 + 68] = mem[_24233 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25263 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25263 + -mem[64] + 132
                                    _15868 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15868] = 26
                                    mem[_15868 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if t >= stor16 / totalSupply:
                                        _16756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16756] = 26
                                        mem[_16756 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18646 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18646] = 30
                                            mem[_18646 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _23648 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23648] = 40
                                            mem[_23648 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23648 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and t / s > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * t / s / arg3 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _20191 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20191] = 30
                                            mem[_20191 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * t / s
                                            if stor5[arg2] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * t / s) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * t / s)
                                            emit Transfer(arg3, arg1, arg2);
                                            _25616 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25616] = 40
                                            mem[_25616 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25616 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        _16757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16757] = 26
                                        mem[_16757 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _18647 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18647] = 30
                                            mem[_18647 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor5[arg2] > -1:
                                                revert with 0, 17
                                            if stor5[arg2] < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2]
                                            emit Transfer(arg3, arg1, arg2);
                                            _23650 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23650] = 40
                                            mem[_23650 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_23650 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 5
                                            _20193 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20193] = 30
                                            mem[_20193 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor5[arg2] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[arg2] + (arg3 * stor16 / totalSupply) < stor5[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] = stor5[arg2] + (arg3 * stor16 / totalSupply)
                                            emit Transfer(arg3, arg1, arg2);
                                            _25618 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25618] = 40
                                            mem[_25618 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_25618 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    idx = 0
                                    s = totalSupply
                                    t = stor16
                                    while idx < stor12.length:
                                        mem[0] = stor12[idx]
                                        mem[32] = 5
                                        if stor5[stor12[idx]] > t:
                                            _16115 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16115] = 26
                                            mem[_16115 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                _16349 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _16349 + 68] = mem[_16115 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16349 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16349 + -mem[64] + 100
                                            if not arg3:
                                                mem[0] = arg1
                                                mem[32] = 6
                                                _17734 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17734] = 30
                                                mem[_17734 + 32] = 'SafeMath: subtraction overflow'
                                                if arg3 > stor6[address(arg1)]:
                                                    _17952 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _17952 + 68] = mem[_17734 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17952 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17952 + -mem[64] + 100
                                                if stor6[address(arg1)] < arg3:
                                                    revert with 0, 17
                                                mem[0] = arg1
                                                stor6[address(arg1)] -= arg3
                                                mem[32] = 5
                                                _19158 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19158] = 30
                                                mem[_19158 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor5[address(arg1)]:
                                                    _19615 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _19615 + 68] = mem[_19158 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19615 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19615 + -mem[64] + 100
                                                if stor5[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor6[address(arg2)] > !arg3:
                                                    revert with 0, 17
                                                if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor6[address(arg2)] += arg3
                                                if stor5[address(arg2)] > -1:
                                                    revert with 0, 17
                                                if stor5[address(arg2)] < stor5[address(arg2)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 5
                                                emit Transfer(arg3, arg1, arg2);
                                                _26161 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26161] = 40
                                                mem[_26161 + 32 len 40] = code.data[20398 len 40]
                                                mem[32] = sha3(address(arg1), 7)
                                                if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                    if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] -= arg3
                                                    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                    return 1
                                                _27516 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _27516 + 68] = mem[_26161 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_27516 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _27516 + -mem[64] + 132
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18654 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18654] = 30
                                            mem[_18654 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _19157 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19157 + 68] = mem[_18654 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19157 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19157 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20870 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20870] = 30
                                            mem[_20870 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                _21516 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21516 + 68] = mem[_20870 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21516 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21516 + -mem[64] + 100
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                            emit Transfer(arg3, arg1, arg2);
                                            _28377 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28377] = 40
                                            mem[_28377 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _29382 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29382 + 68] = mem[_28377 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29382 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29382 + -mem[64] + 132
                                        if idx >= stor12.length:
                                            revert with 0, 50
                                        mem[0] = stor12[idx]
                                        mem[32] = 6
                                        if stor6[stor12[idx]] <= s:
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 5
                                            _16350 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16350] = 30
                                            mem[_16350 + 32] = 'SafeMath: subtraction overflow'
                                            if stor5[stor12[idx]] > t:
                                                _16502 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _16502 + 68] = mem[_16350 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16502 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _16502 + -mem[64] + 100
                                            if t < stor5[stor12[idx]]:
                                                revert with 0, 17
                                            if idx >= stor12.length:
                                                revert with 0, 50
                                            mem[0] = stor12[idx]
                                            mem[32] = 6
                                            _17401 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17401] = 30
                                            mem[_17401 + 32] = 'SafeMath: subtraction overflow'
                                            if stor6[stor12[idx]] <= s:
                                                if s < stor6[stor12[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor6[stor12[idx]]
                                                t = t - stor5[stor12[idx]]
                                                continue 
                                            _17735 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17735 + 68] = mem[_17401 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17735 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17735 + -mem[64] + 100
                                        _16351 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16351] = 26
                                        mem[_16351 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            _16503 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _16503 + 68] = mem[_16351 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16503 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16503 + -mem[64] + 100
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _17954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17954] = 30
                                            mem[_17954 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                _18241 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _18241 + 68] = mem[_17954 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18241 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18241 + -mem[64] + 100
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _19618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19618] = 30
                                            mem[_19618 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                _20206 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _20206 + 68] = mem[_19618 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_20206 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _20206 + -mem[64] + 100
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _27023 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27023] = 40
                                            mem[_27023 + 32 len 40] = code.data[20398 len 40]
                                            mem[32] = sha3(address(arg1), 7)
                                            if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                                if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] -= arg3
                                                emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                                return 1
                                            _28190 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _28190 + 68] = mem[_27023 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28190 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _28190 + -mem[64] + 132
                                        if arg3 and stor16 / totalSupply > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[0] = arg1
                                        mem[32] = 6
                                        _19160 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19160] = 30
                                        mem[_19160 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 > stor6[address(arg1)]:
                                            _19617 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19617 + 68] = mem[_19160 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19617 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19617 + -mem[64] + 100
                                        if stor6[address(arg1)] < arg3:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        stor6[address(arg1)] -= arg3
                                        mem[32] = 5
                                        _21518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21518] = 30
                                        mem[_21518 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                            _21984 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21984 + 68] = mem[_21518 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21984 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21984 + -mem[64] + 100
                                        if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                            revert with 0, 17
                                        stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                        if stor6[address(arg2)] > !arg3:
                                            revert with 0, 17
                                        if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor6[address(arg2)] += arg3
                                        if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                            revert with 0, 17
                                        if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 5
                                        stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                        emit Transfer(arg3, arg1, arg2);
                                        _29013 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29013] = 40
                                        mem[_29013 + 32 len 40] = code.data[20398 len 40]
                                        mem[32] = sha3(address(arg1), 7)
                                        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
                                            if allowance[address(arg1)][address(msg.sender)] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] -= arg3
                                            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
                                            return 1
                                        _29862 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29862 + 68] = mem[_29013 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29862 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29862 + -mem[64] + 132
                                    _15871 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15871] = 26
                                    mem[_15871 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if t >= stor16 / totalSupply:
                                        _16762 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16762] = 26
                                        mem[_16762 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18652 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18652] = 30
                                            mem[_18652 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20867 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20867] = 30
                                            mem[_20867 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _28373 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28373] = 40
                                            mem[_28373 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28373 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and t / s > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * t / s / arg3 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _20199 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20199] = 30
                                            mem[_20199 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _22811 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22811] = 30
                                            mem[_22811 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * t / s
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * t / s) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * t / s
                                            emit Transfer(arg3, arg1, arg2);
                                            _30044 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30044] = 40
                                            mem[_30044 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30044 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        _16763 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16763] = 26
                                        mem[_16763 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not arg3:
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _18653 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18653] = 30
                                            mem[_18653 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _20869 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20869] = 30
                                            mem[_20869 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > -1:
                                                revert with 0, 17
                                            if stor5[address(arg2)] < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            emit Transfer(arg3, arg1, arg2);
                                            _28375 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28375] = 40
                                            mem[_28375 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_28375 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if arg3 and stor16 / totalSupply > -1 / arg3:
                                                revert with 0, 17
                                            if not arg3:
                                                revert with 0, 18
                                            if arg3 * stor16 / totalSupply / arg3 != stor16 / totalSupply:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[0] = arg1
                                            mem[32] = 6
                                            _20201 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20201] = 30
                                            mem[_20201 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 > stor6[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6[address(arg1)] < arg3:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            stor6[address(arg1)] -= arg3
                                            mem[32] = 5
                                            _22813 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22813] = 30
                                            mem[_22813 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor16 / totalSupply > stor5[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor5[address(arg1)] < arg3 * stor16 / totalSupply:
                                                revert with 0, 17
                                            stor5[address(arg1)] += -1 * arg3 * stor16 / totalSupply
                                            if stor6[address(arg2)] > !arg3:
                                                revert with 0, 17
                                            if stor6[address(arg2)] + arg3 < stor6[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor6[address(arg2)] += arg3
                                            if stor5[address(arg2)] > !(arg3 * stor16 / totalSupply):
                                                revert with 0, 17
                                            if stor5[address(arg2)] + (arg3 * stor16 / totalSupply) < stor5[address(arg2)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 5
                                            stor5[address(arg2)] += arg3 * stor16 / totalSupply
                                            emit Transfer(arg3, arg1, arg2);
                                            _30046 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30046] = 40
                                            mem[_30046 + 32 len 40] = code.data[20398 len 40]
                                            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = code.data[20398 len 40], mem[_30046 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    ('le', ('param', 'arg3'), ('stor', ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'allowance', 7)))))
    if allowance[address(arg1)][address(msg.sender)] < arg3:
        revert with 0, 17
    if not arg1:
        revert with 0, 'ERC20: approve from the zero address'
    if not msg.sender:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(arg1)][address(msg.sender)] -= arg3
    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
    return 1
}



}

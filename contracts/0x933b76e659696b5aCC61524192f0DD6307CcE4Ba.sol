contract main {




// =====================  Runtime code  =====================


#
#  - executeOrder(bytes32 arg1)
#  - sub_47bcdb41(?)
#  - cancelOrder(bytes32 arg1)
#  - _fallback()
#
const sub_6e7bc88f(?) = 0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324

const sub_82f3a000(?) = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c

const sub_bfddca16(?) = 0xca141f75526f1b164b3f1d3c68053b85c5ee8db6a4596cb963a46050bf64b8b0

const EXECUTOR_ROLE = 0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e

const DEFAULT_ADMIN_ROLE = 0


mapping of struct roleAdmin;
uint8 stor1; offset 160
uint8 stor1; offset 168
uint8 stor1; offset 176
uint8 stor1; offset 184
uint8 stor1; offset 192
uint8 stor1; offset 200
uint8 stor1; offset 208
uint8 stor1; offset 216
uint16 stor1; offset 208
uint64 stor1; offset 200
address stor1;
uint256 stor1;
uint256 stor1;
mapping of struct stor2;
mapping of uint256 platformFees;
mapping of uint8 sub_996e5938;
array of struct accountAssets;
mapping of uint8 stor6;
address stor7;
address sub_0fc6a11cAddress;
address oracleAddress;
uint256 stor10;
uint256 sub_f1d18608;
uint256 serviceFee;
uint8 maxLeverage;
uint256 sub_e5adac3d;
uint256 sub_fb60bfc1;
uint256 sizeLimit;
address routerAddress;
uint256 stor6361;

function sub_0fc6a11c(?) {
    return sub_0fc6a11cAddress
}

function sizeLimit() {
    return sizeLimit
}

function getRoleAdmin(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return roleAdmin[arg1].field_256
}

function platformFees(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return platformFees[arg1]
}

function oracle() {
    return oracleAddress
}

function serviceFee() {
    return serviceFee
}

function hasRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(uint8(roleAdmin[arg1][address(arg2)].field_0))
}

function sub_996e5938(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return uint256(sub_996e5938[address(arg2)][address(arg1)]), uint256(sub_996e5938[address(arg2)][1][address(arg1)])
}

function maxLeverage() {
    return maxLeverage
}

function getRouter() {
    return address(routerAddress)
}

function accountAssets(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 < accountAssets[arg1].field_0
    return address(accountAssets[arg1][arg2].field_0)
}

function sub_e5adac3d(?) {
    return sub_e5adac3d
}

function sub_f1d18608(?) {
    return sub_f1d18608
}

function sub_fb60bfc1(?) {
    return sub_fb60bfc1
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function sub_8518f5f7(?) {
    require calldata.size - 4 >= 32
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    sizeLimit = arg1
    emit 0xd47ae1d2: sizeLimit, arg1
}

function setBaseToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    address(stor1.field_0) = arg1
}

function setOracle(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    oracleAddress = arg1
    emit NewOracle(oracleAddress, arg1);
}

function setCETH(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'invalid token'
    stor7 = arg1
}

function sub_4ddb14bb(?) {
    emit RoleAdminChanged(0xca141f75526f1b164b3f1d3c68053b85c5ee8db6a4596cb963a46050bf64b8b0, roleAdmin[0xca141f75526f1b164b3f1d3c68053b85c5ee8db6a4596cb963a46050bf64b8b0].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
    roleAdmin[0xca141f75526f1b164b3f1d3c68053b85c5ee8db6a4596cb963a46050bf64b8b0].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
}

function renounceRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg2 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
    if uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
}

function sub_0912475e(?) {
    require calldata.size - 4 >= 32
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'invalid originFee'
    sub_f1d18608 = arg1
    emit 0x966faa43: sub_f1d18608, arg1
}

function setServiceFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'invalid serviceFee'
    serviceFee = arg1
    emit 0xdff99e51: serviceFee, arg1
}

function setRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'invalid router'
    uint256(stor6361) = arg1
    emit 0x16f1d221: address(routerAddress), arg1
}

function revokeRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not uint8(roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to revoke'
    if uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
}

function grantRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not uint8(roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to grant'
    if not uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 1
        emit RoleGranted(arg1, arg2, msg.sender);
}

function sub_54bdaf4f(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not uint8(arg1):
        revert with 0, 'invalid leverage'
    maxLeverage = uint8(arg1)
    emit 0x1c22faa6: maxLeverage, uint8(arg1)
}

function setSwapHelper(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'invalid swaphelper'
    sub_0fc6a11cAddress = arg1
    emit 0x716ac706: sub_0fc6a11cAddress, arg1
}

function setState(uint8 arg1, uint8 arg2, uint8 arg3, uint8 arg4, uint8 arg5) {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if not uint8(roleAdmin[0xca141f75526f1b164b3f1d3c68053b85c5ee8db6a4596cb963a46050bf64b8b0][address(msg.sender)].field_0):
        revert with 0, 'permission deny'
    Mask(176, 0, stor1.field_0) = Mask(176, 0, 0xffffffffffff00ffffff00ffffffffffffffffffffffffffffffffffffffffff and uint256(stor1.field_0))
    uint8(stor1.field_168) = arg2
    uint8(stor1.field_176) = arg3
    uint8(stor1.field_184) = arg4
    uint8(stor1.field_192) = arg5
    uint8(stor1.field_200) = arg1
    stor1.field_200 % 72057594037927936 = Mask(56, 200, 0xffffffffffff00ffffff00ffffffffffffffffffffffffffffffffffffffffff and uint256(stor1.field_0)) >> 200
}

function setExecutor(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'address invalid'
    if not uint8(roleAdmin[roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to grant'
    if not uint8(roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e][address(arg1)].field_0):
        uint8(roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e][address(arg1)].field_0) = 1
        emit RoleGranted(0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e, arg1, msg.sender);
}

function removeExecutor(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'VeeSystemController: Admin permission required'
    if not arg1:
        revert with 0, 'address invalid'
    if not uint8(roleAdmin[roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to revoke'
    if uint8(roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e][address(arg1)].field_0):
        uint8(roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e][address(arg1)].field_0) = 0
        emit RoleRevoked(0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e, arg1, msg.sender);
}

function removeFromWhiteList(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = 0
    s = arg1 + 36
    t = 128
    while idx < arg1.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0, 'VeeSystemController: Admin permission required'
    idx = 0
    while idx < arg1.length:
        if idx >= mem[96]:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 6
        stor6[mem[(32 * idx) + 140 len 20]] = 0
        if idx >= mem[96]:
            revert with 0, 50
        _35 = mem[(32 * idx) + 128]
        mem[ceil32(32 * arg1.length) + 97] = 1
        mem[ceil32(32 * arg1.length) + 129] = address(_35)
        emit 0xc0430013: 1, address(_35)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_9f9ed54f(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0, 'VeeSystemController: Admin permission required'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 6
        stor6[mem[(32 * idx) + 140 len 20]] = 1
        if idx >= mem[96]:
            revert with 0, 50
        _35 = mem[(32 * idx) + 128]
        mem[ceil32(32 * ('cd', 4).length) + 97] = 0
        mem[ceil32(32 * ('cd', 4).length) + 129] = address(_35)
        emit 0xc0430013: 0, address(_35)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function getAssetsIn(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[64] = (32 * accountAssets[address(arg1)].field_0) + 128
    mem[96] = accountAssets[address(arg1)].field_0
    if not accountAssets[address(arg1)].field_0:
        mem[(32 * accountAssets[address(arg1)].field_0) + 128] = 32
        mem[(32 * accountAssets[address(arg1)].field_0) + 160] = accountAssets[address(arg1)].field_0
        idx = 0
        s = (32 * accountAssets[address(arg1)].field_0) + 192
        t = 128
        while idx < accountAssets[address(arg1)].field_0:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * accountAssets[address(arg1)].field_0) + 128
           len (96 * accountAssets[address(arg1)].field_0) + 64
    mem[128] = address(accountAssets[address(arg1)].field_0)
    idx = 128
    s = 0
    while (32 * accountAssets[address(arg1)].field_0) + 96 > idx:
        mem[idx + 32] = address(accountAssets[address(arg1)][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * accountAssets[address(arg1)].field_0) + 128] = 32
    mem[(32 * accountAssets[address(arg1)].field_0) + 160] = accountAssets[address(arg1)].field_0
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < accountAssets[address(arg1)].field_0:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * accountAssets[address(arg1)].field_0) + -mem[64] + 192
}

function sub_f0ef51fe(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[0] = msg.sender
    mem[32] = sha3(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, 0)
    if not uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(msg.sender)].field_0):
        revert with 0, 'VeeSystemController: Admin permission required'
    if not uint8(stor1.field_160):
        revert with 0, 'nonReentrant: Warning re-entered!'
    uint8(stor1.field_160) = 0
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _210 = mem[(32 * idx) + 128]
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 3
        _211 = sha3(mem[(32 * idx) + 140 len 20], 3)
        if platformFees[mem[(32 * idx) + 140 len 20]]:
            if 1 == mem[(32 * idx) + 140 len 20]:
                call msg.sender with:
                   value platformFees[mem[(32 * idx) + 140 len 20]] wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[0] = mem[(32 * idx) + 140 len 20]
                mem[32] = 3
                platformFees[address(mem[(32 * idx) + 128])] = 0
                mem[mem[64]] = platformFees[mem[(32 * idx) + 140 len 20]]
            else:
                _213 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = platformFees[mem[0]]
                _214 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_214 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_214 + 36 len 28]
                mem[64] = _213 + 164
                mem[_213 + 100] = 32
                mem[_213 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(_210)):
                    revert with 0, 'Address: call to non-contract'
                _224 = mem[_214]
                s = 0
                while s < _224:
                    mem[s + _213 + 164] = mem[s + _214 + 32]
                    s = s + 32
                    continue 
                if ceil32(_224) > _224:
                    mem[_224 + _213 + 164] = 0
                call address(_210).mem[_213 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_213 + 168 len _224 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_213 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_213 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _213 + 232] = mem[idx + _213 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_213 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[0] = address(_210)
                    mem[32] = 3
                    platformFees[address(_210)] = 0
                    mem[_213 + 164] = stor[_211]
                else:
                    mem[64] = _213 + ceil32(return_data.size) + 165
                    mem[_213 + 164] = return_data.size
                    mem[_213 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_213 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_213 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _213 + ceil32(return_data.size) + 233] = mem[idx + _213 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_213 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_213 + 196] == bool(mem[_213 + 196])
                        if not mem[_213 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[0] = address(_210)
                    mem[32] = 3
                    platformFees[address(_210)] = 0
                    mem[_213 + ceil32(return_data.size) + 165] = stor[_211]
            emit 0xd2b1d80c: stor[_211], address(_210)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    uint8(stor1.field_160) = 1
}

function sub_7f63f618(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg4 == uint8(arg4)
    if not uint8(stor1.field_160):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'nonReentrant: Warning re-entered!'
    uint8(stor1.field_160) = 0
    if not uint8(roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324][address(msg.sender)].field_0):
        if not uint8(roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e][address(msg.sender)].field_0):
            revert with 0, 'deposit deny'
    if not address(arg1):
        revert with 0, 'account error'
    if not address(arg2):
        if msg.value <= 0:
            revert with 0, 'token missed'
    if uint8(arg4) <= 0:
        revert with 0, 'leverage incorrect'
    if uint8(arg4) > maxLeverage:
        revert with 0, 'leverage incorrect'
    if uint8(arg4) < 1:
        revert with 0, 17
    if arg3 and uint8(uint8(arg4) - 1) > -1 / arg3:
        revert with 0, 17
    if arg3 > !(arg3 * uint8(uint8(arg4) - 1)):
        revert with 0, 17
    if msg.value:
        if arg3 + (arg3 * uint8(uint8(arg4) - 1)) != msg.value:
            revert with 0, 'value is error'
        if arg3 + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        uint256(sub_996e5938[1][address(arg1)]) += arg3
        if (arg3 * uint8(uint8(arg4) - 1)) + uint256(sub_996e5938[1][1][address(arg1)]) < uint256(sub_996e5938[1][1][address(arg1)]):
            revert with 0, 'addLeverage error'
        uint256(sub_996e5938[1][1][address(arg1)]) += arg3 * uint8(uint8(arg4) - 1)
        emit Deposit(address(arg1), address(arg2), arg3 + uint256(sub_996e5938[1][address(arg1)]), arg3, arg3 * uint8(uint8(arg4) - 1));
    else:
        mem[100] = msg.sender
        mem[132] = this.address
        require ext_code.size(address(arg2))
        staticcall address(arg2).0xdd62ed3e with:
                gas gas_remaining wei
               args msg.sender, this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < arg3 + (arg3 * uint8(uint8(arg4) - 1)):
            revert with 0, 'allowance not enough'
        mem[ceil32(return_data.size) + 132] = msg.sender
        mem[ceil32(return_data.size) + 164] = this.address
        mem[ceil32(return_data.size) + 196] = arg3 + (arg3 * uint8(uint8(arg4) - 1))
        mem[ceil32(return_data.size) + 96] = 100
        mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[ceil32(return_data.size) + 128 len 4] = unknown_0x23b872dd(?????)
        mem[ceil32(return_data.size) + 228] = 32
        mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(address(arg2)):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg3 + (arg3 * uint8(uint8(arg4) - 1)), 0
        mem[ceil32(return_data.size) + 392] = 0
        call address(arg2) with:
           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg3 + (arg3 * uint8(uint8(arg4) - 1)), 0) >> 224
             gas gas_remaining wei
            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg3 + (arg3 * uint8(uint8(arg4) - 1)), 0) << 544)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require uint32(msg.sender), Mask(224, 32, this.address) >> 32 == bool(uint32(msg.sender), Mask(224, 32, this.address) >> 32)
                if not uint32(msg.sender), Mask(224, 32, this.address) >> 32:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                if not mem[ceil32(return_data.size) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if arg3 + uint256(sub_996e5938[address(arg2)][address(arg1)]) < uint256(sub_996e5938[address(arg2)][address(arg1)]):
            revert with 0, 'addBalance error'
        uint256(sub_996e5938[address(arg2)][address(arg1)]) += arg3
        if (arg3 * uint8(uint8(arg4) - 1)) + uint256(sub_996e5938[address(arg2)][1][address(arg1)]) < uint256(sub_996e5938[address(arg2)][1][address(arg1)]):
            revert with 0, 'addLeverage error'
        uint256(sub_996e5938[address(arg2)][1][address(arg1)]) += arg3 * uint8(uint8(arg4) - 1)
        emit Deposit(address(arg1), address(arg2), arg3 + uint256(sub_996e5938[address(arg2)][address(arg1)]), arg3, arg3 * uint8(uint8(arg4) - 1));
    if bool(uint8(sub_996e5938[address(arg2)][2][address(arg1)])) != 1:
        uint8(sub_996e5938[address(arg2)][2][address(arg1)]) = 1
        accountAssets[address(arg1)].field_0++
        address(accountAssets[address(arg1)][accountAssets[address(arg1)].field_0].field_0) = address(arg2)
    uint8(stor1.field_160) = 1
}

function sub_869e847e(?) {
    require calldata.size - 4 >= 160
    require cd[4] == address(cd[4])
    require cd[36] == address(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 97 < 96 or ceil32(32 * ('cd', 68).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = 128
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] == address(cd[100])
    require cd[132] == address(cd[132])
    if uint8(stor1.field_216):
        emit RoleAdminChanged(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
        roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
        emit RoleAdminChanged(0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e, roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
        roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
        emit RoleAdminChanged(0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324, roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
        roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
        if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0):
            if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                stor7 = address(cd[36])
                uint256(stor6361) = cd[4]
                uint8(stor1.field_160) = 1
                serviceFee = 5 * 10^15
                sub_f1d18608 = 5 * 10^16
                sub_e5adac3d = 25 * 10^13 * 3600
                maxLeverage = 3
                sub_fb60bfc1 = 720 * 24 * 3600
                sizeLimit = 5000 * 10^18
                idx = 0
                while idx < ('cd', 68).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 6
                    stor6[mem[(32 * idx) + 140 len 20]] = 1
                    if idx >= mem[96]:
                        revert with 0, 50
                    _564 = mem[(32 * idx) + 128]
                    mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                    mem[ceil32(32 * ('cd', 68).length) + 129] = address(_564)
                    emit 0xc0430013: 0, address(_564)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
            else:
                uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                stor7 = address(cd[36])
                uint256(stor6361) = cd[4]
                uint8(stor1.field_160) = 1
                serviceFee = 5 * 10^15
                sub_f1d18608 = 5 * 10^16
                sub_e5adac3d = 25 * 10^13 * 3600
                maxLeverage = 3
                sub_fb60bfc1 = 720 * 24 * 3600
                sizeLimit = 5000 * 10^18
                idx = 0
                while idx < ('cd', 68).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 6
                    stor6[mem[(32 * idx) + 140 len 20]] = 1
                    if idx >= mem[96]:
                        revert with 0, 50
                    _566 = mem[(32 * idx) + 128]
                    mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                    mem[ceil32(32 * ('cd', 68).length) + 129] = address(_566)
                    emit 0xc0430013: 0, address(_566)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
            oracleAddress = address(cd[100])
            if not uint8(stor1.field_216):
                uint8(stor1.field_216) = 0
        else:
            uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0) = 1
            emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, address(cd[132]), msg.sender);
            if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                stor7 = address(cd[36])
                uint256(stor6361) = cd[4]
                uint8(stor1.field_160) = 1
                serviceFee = 5 * 10^15
                sub_f1d18608 = 5 * 10^16
                sub_e5adac3d = 25 * 10^13 * 3600
                maxLeverage = 3
                sub_fb60bfc1 = 720 * 24 * 3600
                sizeLimit = 5000 * 10^18
                idx = 0
                while idx < ('cd', 68).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 6
                    stor6[mem[(32 * idx) + 140 len 20]] = 1
                    if idx >= mem[96]:
                        revert with 0, 50
                    _568 = mem[(32 * idx) + 128]
                    mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                    mem[ceil32(32 * ('cd', 68).length) + 129] = address(_568)
                    emit 0xc0430013: 0, address(_568)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
            else:
                uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                stor7 = address(cd[36])
                uint256(stor6361) = cd[4]
                uint8(stor1.field_160) = 1
                serviceFee = 5 * 10^15
                sub_f1d18608 = 5 * 10^16
                sub_e5adac3d = 25 * 10^13 * 3600
                maxLeverage = 3
                sub_fb60bfc1 = 720 * 24 * 3600
                sizeLimit = 5000 * 10^18
                idx = 0
                while idx < ('cd', 68).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 6
                    stor6[mem[(32 * idx) + 140 len 20]] = 1
                    if idx >= mem[96]:
                        revert with 0, 50
                    _570 = mem[(32 * idx) + 128]
                    mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                    mem[ceil32(32 * ('cd', 68).length) + 129] = address(_570)
                    emit 0xc0430013: 0, address(_570)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
            oracleAddress = address(cd[100])
            if not uint8(stor1.field_216):
                uint8(stor1.field_216) = 0
    else:
        if uint8(stor1.field_208):
            revert with 0, 'Initializable: contract is already initialized'
        if uint8(stor1.field_216):
            emit RoleAdminChanged(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            emit RoleAdminChanged(0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e, roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            emit RoleAdminChanged(0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324, roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0):
                if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _572 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_572)
                        emit 0xc0430013: 0, address(_572)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                    emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _574 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_574)
                        emit 0xc0430013: 0, address(_574)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                oracleAddress = address(cd[100])
                if not uint8(stor1.field_216):
                    uint8(stor1.field_216) = 0
            else:
                uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0) = 1
                emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, address(cd[132]), msg.sender);
                if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _576 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_576)
                        emit 0xc0430013: 0, address(_576)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                    emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _578 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_578)
                        emit 0xc0430013: 0, address(_578)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                oracleAddress = address(cd[100])
                if not uint8(stor1.field_216):
                    uint8(stor1.field_216) = 0
        else:
            uint16(stor1.field_208) = 257
            emit RoleAdminChanged(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            emit RoleAdminChanged(0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e, roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0x1ad8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            emit RoleAdminChanged(0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324, roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256, 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c);
            roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324].field_256 = 0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c
            if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0):
                if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _580 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_580)
                        emit 0xc0430013: 0, address(_580)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                    emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _582 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_582)
                        emit 0xc0430013: 0, address(_582)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                oracleAddress = address(cd[100])
                if not uint8(stor1.field_216):
                    uint8(stor1.field_216) = 0
            else:
                uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(cd[132])].field_0) = 1
                emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, address(cd[132]), msg.sender);
                if uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0):
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _584 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_584)
                        emit 0xc0430013: 0, address(_584)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    uint8(roleAdmin[0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c][address(this.address)].field_0) = 1
                    emit RoleGranted(0x2795eb25cb2b1be6e10a101fd5278394bdeaa6cda3086183d0982b3254e030c, this.address, msg.sender);
                    stor7 = address(cd[36])
                    uint256(stor6361) = cd[4]
                    uint8(stor1.field_160) = 1
                    serviceFee = 5 * 10^15
                    sub_f1d18608 = 5 * 10^16
                    sub_e5adac3d = 25 * 10^13 * 3600
                    maxLeverage = 3
                    sub_fb60bfc1 = 720 * 24 * 3600
                    sizeLimit = 5000 * 10^18
                    idx = 0
                    while idx < ('cd', 68).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + 140 len 20]
                        mem[32] = 6
                        stor6[mem[(32 * idx) + 140 len 20]] = 1
                        if idx >= mem[96]:
                            revert with 0, 50
                        _586 = mem[(32 * idx) + 128]
                        mem[ceil32(32 * ('cd', 68).length) + 97] = 0
                        mem[ceil32(32 * ('cd', 68).length) + 129] = address(_586)
                        emit 0xc0430013: 0, address(_586)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                oracleAddress = address(cd[100])
                if not uint8(stor1.field_216):
                    uint8(stor1.field_216) = 0
}

function sub_db0bc67f(?) payable {
    require calldata.size - 4 >= 256
    require arg1 == address(arg1)
    require calldata.size - 36 >= 224
    require arg2 == address(arg2)
    mem[96] = arg2
    require arg3 == address(arg3)
    mem[128] = arg3
    mem[160] = arg4
    mem[192] = arg5
    mem[224] = arg6
    mem[256] = arg7
    require arg8 == uint8(arg8)
    mem[288] = arg8
    if uint8(stor1.field_200):
        revert with 0, 'veeLock: Lock System'
    if uint8(stor1.field_168):
        revert with 0, 'veeLock: Lock All'
    if uint8(stor1.field_176):
        revert with 0, 'veeLock: Lock Create'
    require ext_code.size(address(arg2))
    call address(arg2).underlying() with:
         gas gas_remaining wei
    mem[320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'invalid tokenA'
    if not address(arg2):
        revert with 0, 'invalid ctoken'
    if address(arg2) != msg.sender:
        revert with 0, 'ctokenA error'
    if not uint8(roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324][address(msg.sender)].field_0):
        revert with 0, 'VEETOKEN required'
    if not address(arg1):
        revert with 0, 'invalid order owner'
    if not address(stor1.field_0):
        revert with 0, 'invalid baseToken'
    if not arg5:
        revert with 0, 'invalid limit price'
    if not arg6:
        revert with 0, 'invalid stop limit'
    if not arg4:
        revert with 0, 'amountA can't be zero.'
    if arg7 < block.timestamp:
        revert with 0, 17
    if arg7 - block.timestamp >= sub_fb60bfc1:
        revert with 0, 'expirydate error'
    if uint8(arg8) <= 0:
        revert with 0, 'leverage incorrect'
    if uint8(arg8) > maxLeverage:
        revert with 0, 'leverage incorrect'
    if sub_f1d18608 != msg.value:
        revert with 0, 'originFee incorrect'
    if not stor6[1]:
        revert with 0, 'whiteList error'
    mem[ceil32(return_data.size) + 324] = address(arg2)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and ext_call.return_data[0] > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) * ext_call.return_data[0] / 10^18 > sizeLimit:
        revert with 0, 'out of limit'
    if not uint8(stor1.field_160):
        revert with 0, 'nonReentrant: Warning re-entered!'
    uint8(stor1.field_160) = 0
    if platformFees[1] > !sub_f1d18608:
        revert with 0, 17
    platformFees[1] += sub_f1d18608
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if platformFees[address(ext_call.return_data[0])] > !(arg4 * uint8(arg8) * serviceFee / 10^18):
        revert with 0, 17
    platformFees[address(ext_call.return_data[0])] += arg4 * uint8(arg8) * serviceFee / 10^18
    uint8(stor1.field_160) = 1
    if uint8(arg8) < 1:
        revert with 0, 17
    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
        revert with 0, 17
    mem[32] = sha3(address(ext_call.return_data[0]), 4) + 1
    if uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < arg4:
        revert with 0, 'allowance error'
    if uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) < arg4 * uint8(uint8(arg8) - 1):
        revert with 0, 'allowance error'
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
        revert with 0, 17
    if stor7 == address(arg2):
        if stor7 == address(arg3):
            mem[(2 * ceil32(return_data.size)) + 324] = address(arg2)
            require ext_code.size(oracleAddress)
            staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[(2 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(4 * ceil32(return_data.size)) + 324] = address(arg3)
            require ext_code.size(oracleAddress)
            staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if arg4 and uint8(arg8) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
                revert with 0, 17
            if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
                revert with 0, 17
            if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).factory() with:
                    gas gas_remaining wei
            mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[0] = address(arg1)
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(10 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(11 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(12 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(13 * ceil32(return_data.size)) + 320] = 100
                mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
                mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
                mem[(13 * ceil32(return_data.size)) + 552] = 0
                delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                     gas gas_remaining wei
                    args mem[(13 * ceil32(return_data.size)) + 456 len 96]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _17006 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                        revert with 0, 65
                    mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                    mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                    require arg3 + (32 * _17006) + 160 <= arg2 + 128
                    mem[(13 * ceil32(return_data.size)) + 484 len 32 * _17006] = mem[arg3 + 160 len 32 * _17006]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(1, 4)
                    uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34916 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34917 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34919 = sha3(mem[_34917 + 32 len mem[_34917]])
                    if 1 > !sha3(mem[_34917 + 32 len mem[_34917]]):
                        revert with 0, 17
                    mem[_34916 + 148] = address(arg1)
                    mem[_34916 + 180] = arg4
                    mem[_34916 + 212] = address(ext_call.return_data[0])
                    mem[_34916 + 244] = 1
                    mem[_34916 + 276] = _34919 + 1
                    mem[_34916 + 116] = 160
                    if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1), address(arg1));
                    mem[_34916 + 308] = address(arg1)
                    mem[_34916 + 340] = address(arg2)
                    mem[_34916 + 372] = address(ext_call.return_data[0])
                    mem[_34916 + 404] = 1
                    mem[_34916 + 436] = arg4
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    mem[_34916 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                    mem[_34916 + 500] = arg5
                    mem[_34916 + 532] = arg6
                    mem[_34916 + 564] = arg7
                    mem[_34916 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_512) = address(ext_call.return_data[0])
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_768) = 1
                    Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_776) = 0
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_1280 = mem[_34916 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34919 + 1].field_2304) = 0
                    mem[_34916 + 664] = address(ext_call.return_data[0])
                    mem[_34916 + 696] = address(stor1.field_0)
                    mem[_34916 + 628] = 68
                    mem[_34916 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34916 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34916 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34916 + 728 len 28]
                    mem[_34916 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34916 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34916 + 732 len 64]
                    if return_data.size:
                        mem[_34916 + 728] = return_data.size
                        mem[_34916 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34916 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34916 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34916 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34916 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34916 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34916 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34916 + 760], mem[_34916 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34916 + 764] = 1
                        mem[_34916 + 796] = address(stor1.field_0)
                        mem[_34916 + 728] = 68
                        mem[_34916 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34916 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34916 + 828 len 28]
                        mem[_34916 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34916 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34916 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34916 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34916 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34919 + 1)
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
                mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16935 = mem[(13 * ceil32(return_data.size)) + 484]
                require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
                require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
                _17007 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                require _16935 + (32 * _17007) + 64 <= return_data.size + 32
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _17007] = mem[(13 * ceil32(return_data.size)) + _16935 + 516 len 32 * _17007]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _17007:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34920 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34921 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34923 = sha3(mem[_34921 + 32 len mem[_34921]])
                if 1 > !sha3(mem[_34921 + 32 len mem[_34921]]):
                    revert with 0, 17
                mem[_34920 + 148] = address(arg1)
                mem[_34920 + 180] = arg4
                mem[_34920 + 212] = address(ext_call.return_data[0])
                mem[_34920 + 244] = 1
                mem[_34920 + 276] = _34923 + 1
                mem[_34920 + 116] = 160
                if 0 >= _17007:
                    revert with 0, 50
                if 1 >= _17007:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1), address(arg1));
                mem[_34920 + 308] = address(arg1)
                mem[_34920 + 340] = address(arg2)
                mem[_34920 + 372] = address(ext_call.return_data[0])
                mem[_34920 + 404] = 1
                mem[_34920 + 436] = arg4
                if 1 >= _17007:
                    revert with 0, 50
                mem[_34920 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                mem[_34920 + 500] = arg5
                mem[_34920 + 532] = arg6
                mem[_34920 + 564] = arg7
                mem[_34920 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_1280 = mem[_34920 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34923 + 1].field_2304) = 0
                mem[_34920 + 664] = address(ext_call.return_data[0])
                mem[_34920 + 696] = address(stor1.field_0)
                mem[_34920 + 628] = 68
                mem[_34920 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34920 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34920 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34920 + 728 len 28]
                mem[_34920 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34920 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34920 + 732 len 64]
                if return_data.size:
                    mem[_34920 + 728] = return_data.size
                    mem[_34920 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34920 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34920 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34920 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34920 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34920 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34920 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34920 + 760], mem[_34920 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34920 + 764] = 1
                    mem[_34920 + 796] = address(stor1.field_0)
                    mem[_34920 + 728] = 68
                    mem[_34920 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34920 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34920 + 828 len 28]
                    mem[_34920 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34920 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34920 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34920 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34920 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34923 + 1)
            mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(13 * ceil32(return_data.size)) + 320] = 100
            mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
            mem[(13 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(13 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _17010 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _17010) + 160 <= arg2 + 128
                mem[(13 * ceil32(return_data.size)) + 484 len 32 * _17010] = mem[arg3 + 160 len 32 * _17010]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34932 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34933 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34935 = sha3(mem[_34933 + 32 len mem[_34933]])
                if 1 > !sha3(mem[_34933 + 32 len mem[_34933]]):
                    revert with 0, 17
                mem[_34932 + 148] = address(arg1)
                mem[_34932 + 180] = arg4
                mem[_34932 + 212] = address(ext_call.return_data[0])
                mem[_34932 + 244] = 1
                mem[_34932 + 276] = _34935 + 1
                mem[_34932 + 116] = 160
                if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1), address(arg1));
                mem[_34932 + 308] = address(arg1)
                mem[_34932 + 340] = address(arg2)
                mem[_34932 + 372] = address(ext_call.return_data[0])
                mem[_34932 + 404] = 1
                mem[_34932 + 436] = arg4
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34932 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                mem[_34932 + 500] = arg5
                mem[_34932 + 532] = arg6
                mem[_34932 + 564] = arg7
                mem[_34932 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_1280 = mem[_34932 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34935 + 1].field_2304) = 0
                mem[_34932 + 664] = address(ext_call.return_data[0])
                mem[_34932 + 696] = address(stor1.field_0)
                mem[_34932 + 628] = 68
                mem[_34932 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34932 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34932 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34932 + 728 len 28]
                mem[_34932 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34932 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34932 + 732 len 64]
                if return_data.size:
                    mem[_34932 + 728] = return_data.size
                    mem[_34932 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34932 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34932 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34932 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34932 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34932 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34932 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34932 + 760], mem[_34932 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34932 + 764] = 1
                    mem[_34932 + 796] = address(stor1.field_0)
                    mem[_34932 + 728] = 68
                    mem[_34932 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34932 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34932 + 828 len 28]
                    mem[_34932 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34932 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34932 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34932 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34932 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34935 + 1)
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
            mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16939 = mem[(13 * ceil32(return_data.size)) + 484]
            require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
            require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
            _17011 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            require _16939 + (32 * _17011) + 64 <= return_data.size + 32
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _17011] = mem[(13 * ceil32(return_data.size)) + _16939 + 516 len 32 * _17011]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _17011:
                revert with 0, 50
            if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34936 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34937 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34939 = sha3(mem[_34937 + 32 len mem[_34937]])
            if 1 > !sha3(mem[_34937 + 32 len mem[_34937]]):
                revert with 0, 17
            mem[_34936 + 148] = address(arg1)
            mem[_34936 + 180] = arg4
            mem[_34936 + 212] = address(ext_call.return_data[0])
            mem[_34936 + 244] = 1
            mem[_34936 + 276] = _34939 + 1
            mem[_34936 + 116] = 160
            if 0 >= _17011:
                revert with 0, 50
            if 1 >= _17011:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1), address(arg1));
            mem[_34936 + 308] = address(arg1)
            mem[_34936 + 340] = address(arg2)
            mem[_34936 + 372] = address(ext_call.return_data[0])
            mem[_34936 + 404] = 1
            mem[_34936 + 436] = arg4
            if 1 >= _17011:
                revert with 0, 50
            mem[_34936 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34936 + 500] = arg5
            mem[_34936 + 532] = arg6
            mem[_34936 + 564] = arg7
            mem[_34936 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_1280 = mem[_34936 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34939 + 1].field_2304) = 0
            mem[_34936 + 664] = address(ext_call.return_data[0])
            mem[_34936 + 696] = address(stor1.field_0)
            mem[_34936 + 628] = 68
            mem[_34936 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34936 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34936 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34936 + 728 len 28]
            mem[_34936 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34936 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34936 + 732 len 64]
            if return_data.size:
                mem[_34936 + 728] = return_data.size
                mem[_34936 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34936 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34936 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34936 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34936 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34936 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34936 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34936 + 760], mem[_34936 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34936 + 764] = 1
                mem[_34936 + 796] = address(stor1.field_0)
                mem[_34936 + 728] = 68
                mem[_34936 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34936 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34936 + 828 len 28]
                mem[_34936 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34936 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34936 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34936 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34936 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34939 + 1)
        require ext_code.size(address(arg3))
        call address(arg3).underlying() with:
             gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 324] = address(arg2)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(6 * ceil32(return_data.size)) + 324] = address(arg3)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg3)
        mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg4 and uint8(arg8) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
            revert with 0, 17
        if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
            revert with 0, 17
        if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).factory() with:
                gas gas_remaining wei
        mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[0] = address(arg1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != 1:
            mem[(10 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(11 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(12 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(13 * ceil32(return_data.size)) + 320] = 100
                mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
                mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
                mem[(13 * ceil32(return_data.size)) + 552] = 0
                delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                     gas gas_remaining wei
                    args mem[(13 * ceil32(return_data.size)) + 456 len 96]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16990 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                        revert with 0, 65
                    mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                    mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                    require arg3 + (32 * _16990) + 160 <= arg2 + 128
                    mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16990] = mem[arg3 + 160 len 32 * _16990]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(1, 4)
                    uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34852 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34853 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34855 = sha3(mem[_34853 + 32 len mem[_34853]])
                    if 1 > !sha3(mem[_34853 + 32 len mem[_34853]]):
                        revert with 0, 17
                    mem[_34852 + 148] = address(arg1)
                    mem[_34852 + 180] = arg4
                    mem[_34852 + 212] = address(ext_call.return_data[0])
                    mem[_34852 + 244] = 1
                    mem[_34852 + 276] = _34855 + 1
                    mem[_34852 + 116] = 160
                    if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1), address(arg1));
                    mem[_34852 + 308] = address(arg1)
                    mem[_34852 + 340] = address(arg2)
                    mem[_34852 + 372] = address(ext_call.return_data[0])
                    mem[_34852 + 404] = 1
                    mem[_34852 + 436] = arg4
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    mem[_34852 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                    mem[_34852 + 500] = arg5
                    mem[_34852 + 532] = arg6
                    mem[_34852 + 564] = arg7
                    mem[_34852 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_512) = address(ext_call.return_data[0])
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_768) = 1
                    Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_776) = 0
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_1280 = mem[_34852 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34855 + 1].field_2304) = 0
                    mem[_34852 + 664] = address(ext_call.return_data[0])
                    mem[_34852 + 696] = address(stor1.field_0)
                    mem[_34852 + 628] = 68
                    mem[_34852 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34852 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34852 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34852 + 728 len 28]
                    mem[_34852 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34852 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34852 + 732 len 64]
                    if return_data.size:
                        mem[_34852 + 728] = return_data.size
                        mem[_34852 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34852 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34852 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34852 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34852 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34852 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34852 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34852 + 760], mem[_34852 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34852 + 764] = 1
                        mem[_34852 + 796] = address(stor1.field_0)
                        mem[_34852 + 728] = 68
                        mem[_34852 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34852 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34852 + 828 len 28]
                        mem[_34852 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34852 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34852 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34852 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34852 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34855 + 1)
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
                mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16919 = mem[(13 * ceil32(return_data.size)) + 484]
                require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
                require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
                _16991 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                require _16919 + (32 * _16991) + 64 <= return_data.size + 32
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16991] = mem[(13 * ceil32(return_data.size)) + _16919 + 516 len 32 * _16991]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16991:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34856 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34857 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34859 = sha3(mem[_34857 + 32 len mem[_34857]])
                if 1 > !sha3(mem[_34857 + 32 len mem[_34857]]):
                    revert with 0, 17
                mem[_34856 + 148] = address(arg1)
                mem[_34856 + 180] = arg4
                mem[_34856 + 212] = address(ext_call.return_data[0])
                mem[_34856 + 244] = 1
                mem[_34856 + 276] = _34859 + 1
                mem[_34856 + 116] = 160
                if 0 >= _16991:
                    revert with 0, 50
                if 1 >= _16991:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1), address(arg1));
                mem[_34856 + 308] = address(arg1)
                mem[_34856 + 340] = address(arg2)
                mem[_34856 + 372] = address(ext_call.return_data[0])
                mem[_34856 + 404] = 1
                mem[_34856 + 436] = arg4
                if 1 >= _16991:
                    revert with 0, 50
                mem[_34856 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                mem[_34856 + 500] = arg5
                mem[_34856 + 532] = arg6
                mem[_34856 + 564] = arg7
                mem[_34856 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_1280 = mem[_34856 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34859 + 1].field_2304) = 0
                mem[_34856 + 664] = address(ext_call.return_data[0])
                mem[_34856 + 696] = address(stor1.field_0)
                mem[_34856 + 628] = 68
                mem[_34856 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34856 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34856 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34856 + 728 len 28]
                mem[_34856 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34856 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34856 + 732 len 64]
                if return_data.size:
                    mem[_34856 + 728] = return_data.size
                    mem[_34856 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34856 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34856 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34856 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34856 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34856 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34856 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34856 + 760], mem[_34856 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34856 + 764] = 1
                    mem[_34856 + 796] = address(stor1.field_0)
                    mem[_34856 + 728] = 68
                    mem[_34856 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34856 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34856 + 828 len 28]
                    mem[_34856 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34856 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34856 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34856 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34856 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34859 + 1)
            mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(13 * ceil32(return_data.size)) + 320] = 100
            mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
            mem[(13 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(13 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16994 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16994) + 160 <= arg2 + 128
                mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16994] = mem[arg3 + 160 len 32 * _16994]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34868 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34869 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34871 = sha3(mem[_34869 + 32 len mem[_34869]])
                if 1 > !sha3(mem[_34869 + 32 len mem[_34869]]):
                    revert with 0, 17
                mem[_34868 + 148] = address(arg1)
                mem[_34868 + 180] = arg4
                mem[_34868 + 212] = address(ext_call.return_data[0])
                mem[_34868 + 244] = 1
                mem[_34868 + 276] = _34871 + 1
                mem[_34868 + 116] = 160
                if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1), address(arg1));
                mem[_34868 + 308] = address(arg1)
                mem[_34868 + 340] = address(arg2)
                mem[_34868 + 372] = address(ext_call.return_data[0])
                mem[_34868 + 404] = 1
                mem[_34868 + 436] = arg4
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34868 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                mem[_34868 + 500] = arg5
                mem[_34868 + 532] = arg6
                mem[_34868 + 564] = arg7
                mem[_34868 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_1280 = mem[_34868 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34871 + 1].field_2304) = 0
                mem[_34868 + 664] = address(ext_call.return_data[0])
                mem[_34868 + 696] = address(stor1.field_0)
                mem[_34868 + 628] = 68
                mem[_34868 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34868 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34868 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34868 + 728 len 28]
                mem[_34868 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34868 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34868 + 732 len 64]
                if return_data.size:
                    mem[_34868 + 728] = return_data.size
                    mem[_34868 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34868 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34868 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34868 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34868 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34868 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34868 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34868 + 760], mem[_34868 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34868 + 764] = 1
                    mem[_34868 + 796] = address(stor1.field_0)
                    mem[_34868 + 728] = 68
                    mem[_34868 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34868 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34868 + 828 len 28]
                    mem[_34868 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34868 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34868 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34868 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34868 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34871 + 1)
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
            mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16923 = mem[(13 * ceil32(return_data.size)) + 484]
            require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
            require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
            _16995 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            require _16923 + (32 * _16995) + 64 <= return_data.size + 32
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16995] = mem[(13 * ceil32(return_data.size)) + _16923 + 516 len 32 * _16995]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16995:
                revert with 0, 50
            if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34872 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34873 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34875 = sha3(mem[_34873 + 32 len mem[_34873]])
            if 1 > !sha3(mem[_34873 + 32 len mem[_34873]]):
                revert with 0, 17
            mem[_34872 + 148] = address(arg1)
            mem[_34872 + 180] = arg4
            mem[_34872 + 212] = address(ext_call.return_data[0])
            mem[_34872 + 244] = 1
            mem[_34872 + 276] = _34875 + 1
            mem[_34872 + 116] = 160
            if 0 >= _16995:
                revert with 0, 50
            if 1 >= _16995:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1), address(arg1));
            mem[_34872 + 308] = address(arg1)
            mem[_34872 + 340] = address(arg2)
            mem[_34872 + 372] = address(ext_call.return_data[0])
            mem[_34872 + 404] = 1
            mem[_34872 + 436] = arg4
            if 1 >= _16995:
                revert with 0, 50
            mem[_34872 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34872 + 500] = arg5
            mem[_34872 + 532] = arg6
            mem[_34872 + 564] = arg7
            mem[_34872 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_1280 = mem[_34872 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34875 + 1].field_2304) = 0
            mem[_34872 + 664] = address(ext_call.return_data[0])
            mem[_34872 + 696] = address(stor1.field_0)
            mem[_34872 + 628] = 68
            mem[_34872 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34872 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34872 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34872 + 728 len 28]
            mem[_34872 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34872 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34872 + 732 len 64]
            if return_data.size:
                mem[_34872 + 728] = return_data.size
                mem[_34872 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34872 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34872 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34872 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34872 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34872 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34872 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34872 + 760], mem[_34872 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34872 + 764] = 1
                mem[_34872 + 796] = address(stor1.field_0)
                mem[_34872 + 728] = 68
                mem[_34872 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34872 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34872 + 828 len 28]
                mem[_34872 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34872 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34872 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34872 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34872 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34875 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 100
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
            mem[(14 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16998 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16998) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16998] = mem[arg3 + 160 len 32 * _16998]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34884 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34885 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34887 = sha3(mem[_34885 + 32 len mem[_34885]])
                if 1 > !sha3(mem[_34885 + 32 len mem[_34885]]):
                    revert with 0, 17
                mem[_34884 + 148] = address(arg1)
                mem[_34884 + 180] = arg4
                mem[_34884 + 212] = address(ext_call.return_data[0])
                mem[_34884 + 244] = 1
                mem[_34884 + 276] = _34887 + 1
                mem[_34884 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1), address(arg1));
                mem[_34884 + 308] = address(arg1)
                mem[_34884 + 340] = address(arg2)
                mem[_34884 + 372] = address(ext_call.return_data[0])
                mem[_34884 + 404] = 1
                mem[_34884 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34884 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
                mem[_34884 + 500] = arg5
                mem[_34884 + 532] = arg6
                mem[_34884 + 564] = arg7
                mem[_34884 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_1280 = mem[_34884 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34887 + 1].field_2304) = 0
                mem[_34884 + 664] = address(ext_call.return_data[0])
                mem[_34884 + 696] = address(stor1.field_0)
                mem[_34884 + 628] = 68
                mem[_34884 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34884 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34884 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34884 + 728 len 28]
                mem[_34884 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34884 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34884 + 732 len 64]
                if return_data.size:
                    mem[_34884 + 728] = return_data.size
                    mem[_34884 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34884 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34884 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34884 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34884 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34884 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34884 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34884 + 760], mem[_34884 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34884 + 764] = 1
                    mem[_34884 + 796] = address(stor1.field_0)
                    mem[_34884 + 728] = 68
                    mem[_34884 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34884 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34884 + 828 len 28]
                    mem[_34884 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34884 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34884 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34884 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34884 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34887 + 1)
            mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16927 = mem[(14 * ceil32(return_data.size)) + 484]
            require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
            _16999 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            require _16927 + (32 * _16999) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16999] = mem[(14 * ceil32(return_data.size)) + _16927 + 516 len 32 * _16999]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16999:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34888 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34889 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34891 = sha3(mem[_34889 + 32 len mem[_34889]])
            if 1 > !sha3(mem[_34889 + 32 len mem[_34889]]):
                revert with 0, 17
            mem[_34888 + 148] = address(arg1)
            mem[_34888 + 180] = arg4
            mem[_34888 + 212] = address(ext_call.return_data[0])
            mem[_34888 + 244] = 1
            mem[_34888 + 276] = _34891 + 1
            mem[_34888 + 116] = 160
            if 0 >= _16999:
                revert with 0, 50
            if 1 >= _16999:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1), address(arg1));
            mem[_34888 + 308] = address(arg1)
            mem[_34888 + 340] = address(arg2)
            mem[_34888 + 372] = address(ext_call.return_data[0])
            mem[_34888 + 404] = 1
            mem[_34888 + 436] = arg4
            if 1 >= _16999:
                revert with 0, 50
            mem[_34888 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34888 + 500] = arg5
            mem[_34888 + 532] = arg6
            mem[_34888 + 564] = arg7
            mem[_34888 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_1280 = mem[_34888 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34891 + 1].field_2304) = 0
            mem[_34888 + 664] = address(ext_call.return_data[0])
            mem[_34888 + 696] = address(stor1.field_0)
            mem[_34888 + 628] = 68
            mem[_34888 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34888 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34888 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34888 + 728 len 28]
            mem[_34888 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34888 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34888 + 732 len 64]
            if return_data.size:
                mem[_34888 + 728] = return_data.size
                mem[_34888 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34888 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34888 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34888 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34888 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34888 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34888 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34888 + 760], mem[_34888 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34888 + 764] = 1
                mem[_34888 + 796] = address(stor1.field_0)
                mem[_34888 + 728] = 68
                mem[_34888 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34888 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34888 + 828 len 28]
                mem[_34888 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34888 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34888 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34888 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34888 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34891 + 1)
        mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(14 * ceil32(return_data.size)) + 320] = 100
        mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
        mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
        mem[(14 * ceil32(return_data.size)) + 552] = 0
        delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
             gas gas_remaining wei
            args mem[(14 * ceil32(return_data.size)) + 456 len 96]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _17002 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
            mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
            require arg3 + (32 * _17002) + 160 <= arg2 + 128
            mem[(14 * ceil32(return_data.size)) + 484 len 32 * _17002] = mem[arg3 + 160 len 32 * _17002]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34900 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34901 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34903 = sha3(mem[_34901 + 32 len mem[_34901]])
            if 1 > !sha3(mem[_34901 + 32 len mem[_34901]]):
                revert with 0, 17
            mem[_34900 + 148] = address(arg1)
            mem[_34900 + 180] = arg4
            mem[_34900 + 212] = address(ext_call.return_data[0])
            mem[_34900 + 244] = 1
            mem[_34900 + 276] = _34903 + 1
            mem[_34900 + 116] = 160
            if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1), address(arg1));
            mem[_34900 + 308] = address(arg1)
            mem[_34900 + 340] = address(arg2)
            mem[_34900 + 372] = address(ext_call.return_data[0])
            mem[_34900 + 404] = 1
            mem[_34900 + 436] = arg4
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            mem[_34900 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
            mem[_34900 + 500] = arg5
            mem[_34900 + 532] = arg6
            mem[_34900 + 564] = arg7
            mem[_34900 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_1280 = mem[_34900 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34903 + 1].field_2304) = 0
            mem[_34900 + 664] = address(ext_call.return_data[0])
            mem[_34900 + 696] = address(stor1.field_0)
            mem[_34900 + 628] = 68
            mem[_34900 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34900 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34900 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34900 + 728 len 28]
            mem[_34900 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34900 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34900 + 732 len 64]
            if return_data.size:
                mem[_34900 + 728] = return_data.size
                mem[_34900 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34900 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34900 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34900 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34900 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34900 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34900 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34900 + 760], mem[_34900 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34900 + 764] = 1
                mem[_34900 + 796] = address(stor1.field_0)
                mem[_34900 + 728] = 68
                mem[_34900 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34900 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34900 + 828 len 28]
                mem[_34900 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34900 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34900 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34900 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34900 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34903 + 1)
        mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
        mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16931 = mem[(14 * ceil32(return_data.size)) + 484]
        require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
        require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
        _17003 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
            revert with 0, 65
        mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        require _16931 + (32 * _17003) + 64 <= return_data.size + 32
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _17003] = mem[(14 * ceil32(return_data.size)) + _16931 + 516 len 32 * _17003]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _17003:
            revert with 0, 50
        if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34904 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34905 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34907 = sha3(mem[_34905 + 32 len mem[_34905]])
        if 1 > !sha3(mem[_34905 + 32 len mem[_34905]]):
            revert with 0, 17
        mem[_34904 + 148] = address(arg1)
        mem[_34904 + 180] = arg4
        mem[_34904 + 212] = address(ext_call.return_data[0])
        mem[_34904 + 244] = 1
        mem[_34904 + 276] = _34907 + 1
        mem[_34904 + 116] = 160
        if 0 >= _17003:
            revert with 0, 50
        if 1 >= _17003:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1), address(arg1));
        mem[_34904 + 308] = address(arg1)
        mem[_34904 + 340] = address(arg2)
        mem[_34904 + 372] = address(ext_call.return_data[0])
        mem[_34904 + 404] = 1
        mem[_34904 + 436] = arg4
        if 1 >= _17003:
            revert with 0, 50
        mem[_34904 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        mem[_34904 + 500] = arg5
        mem[_34904 + 532] = arg6
        mem[_34904 + 564] = arg7
        mem[_34904 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_1280 = mem[_34904 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34907 + 1].field_2304) = 0
        mem[_34904 + 664] = address(ext_call.return_data[0])
        mem[_34904 + 696] = address(stor1.field_0)
        mem[_34904 + 628] = 68
        mem[_34904 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34904 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34904 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34904 + 728 len 28]
        mem[_34904 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34904 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34904 + 732 len 64]
        if return_data.size:
            mem[_34904 + 728] = return_data.size
            mem[_34904 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34904 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34904 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34904 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34904 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34904 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34904 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34904 + 760], mem[_34904 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34904 + 764] = 1
            mem[_34904 + 796] = address(stor1.field_0)
            mem[_34904 + 728] = 68
            mem[_34904 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34904 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34904 + 828 len 28]
            mem[_34904 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34904 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34904 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34904 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34904 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34907 + 1)
    require ext_code.size(address(arg2))
    call address(arg2).underlying() with:
         gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if stor7 == address(arg3):
        mem[(4 * ceil32(return_data.size)) + 324] = address(arg2)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(6 * ceil32(return_data.size)) + 324] = address(arg3)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg3)
        mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg4 and uint8(arg8) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
            revert with 0, 17
        if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
            revert with 0, 17
        if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).factory() with:
                gas gas_remaining wei
        mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != 1:
            mem[0] = address(arg1)
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(10 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(11 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(12 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(13 * ceil32(return_data.size)) + 320] = 100
                mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
                mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
                mem[(13 * ceil32(return_data.size)) + 552] = 0
                delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                     gas gas_remaining wei
                    args mem[(13 * ceil32(return_data.size)) + 456 len 96]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16974 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                        revert with 0, 65
                    mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                    mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                    require arg3 + (32 * _16974) + 160 <= arg2 + 128
                    mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16974] = mem[arg3 + 160 len 32 * _16974]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(1, 4)
                    uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34788 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34789 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34791 = sha3(mem[_34789 + 32 len mem[_34789]])
                    if 1 > !sha3(mem[_34789 + 32 len mem[_34789]]):
                        revert with 0, 17
                    mem[_34788 + 148] = address(arg1)
                    mem[_34788 + 180] = arg4
                    mem[_34788 + 212] = address(ext_call.return_data[0])
                    mem[_34788 + 244] = 1
                    mem[_34788 + 276] = _34791 + 1
                    mem[_34788 + 116] = 160
                    if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1), address(arg1));
                    mem[_34788 + 308] = address(arg1)
                    mem[_34788 + 340] = address(arg2)
                    mem[_34788 + 372] = address(ext_call.return_data[0])
                    mem[_34788 + 404] = 1
                    mem[_34788 + 436] = arg4
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    mem[_34788 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                    mem[_34788 + 500] = arg5
                    mem[_34788 + 532] = arg6
                    mem[_34788 + 564] = arg7
                    mem[_34788 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_512) = address(ext_call.return_data[0])
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_768) = 1
                    Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_776) = 0
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_1280 = mem[_34788 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34791 + 1].field_2304) = 0
                    mem[_34788 + 664] = address(ext_call.return_data[0])
                    mem[_34788 + 696] = address(stor1.field_0)
                    mem[_34788 + 628] = 68
                    mem[_34788 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34788 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34788 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34788 + 728 len 28]
                    mem[_34788 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34788 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34788 + 732 len 64]
                    if return_data.size:
                        mem[_34788 + 728] = return_data.size
                        mem[_34788 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34788 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34788 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34788 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34788 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34788 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34788 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34788 + 760], mem[_34788 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34788 + 764] = 1
                        mem[_34788 + 796] = address(stor1.field_0)
                        mem[_34788 + 728] = 68
                        mem[_34788 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34788 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34788 + 828 len 28]
                        mem[_34788 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34788 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34788 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34788 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34788 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34791 + 1)
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
                mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16903 = mem[(13 * ceil32(return_data.size)) + 484]
                require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
                require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
                _16975 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                require _16903 + (32 * _16975) + 64 <= return_data.size + 32
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16975] = mem[(13 * ceil32(return_data.size)) + _16903 + 516 len 32 * _16975]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16975:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34792 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34793 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34795 = sha3(mem[_34793 + 32 len mem[_34793]])
                if 1 > !sha3(mem[_34793 + 32 len mem[_34793]]):
                    revert with 0, 17
                mem[_34792 + 148] = address(arg1)
                mem[_34792 + 180] = arg4
                mem[_34792 + 212] = address(ext_call.return_data[0])
                mem[_34792 + 244] = 1
                mem[_34792 + 276] = _34795 + 1
                mem[_34792 + 116] = 160
                if 0 >= _16975:
                    revert with 0, 50
                if 1 >= _16975:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1), address(arg1));
                mem[_34792 + 308] = address(arg1)
                mem[_34792 + 340] = address(arg2)
                mem[_34792 + 372] = address(ext_call.return_data[0])
                mem[_34792 + 404] = 1
                mem[_34792 + 436] = arg4
                if 1 >= _16975:
                    revert with 0, 50
                mem[_34792 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                mem[_34792 + 500] = arg5
                mem[_34792 + 532] = arg6
                mem[_34792 + 564] = arg7
                mem[_34792 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_1280 = mem[_34792 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34795 + 1].field_2304) = 0
                mem[_34792 + 664] = address(ext_call.return_data[0])
                mem[_34792 + 696] = address(stor1.field_0)
                mem[_34792 + 628] = 68
                mem[_34792 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34792 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34792 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34792 + 728 len 28]
                mem[_34792 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34792 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34792 + 732 len 64]
                if return_data.size:
                    mem[_34792 + 728] = return_data.size
                    mem[_34792 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34792 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34792 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34792 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34792 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34792 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34792 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34792 + 760], mem[_34792 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34792 + 764] = 1
                    mem[_34792 + 796] = address(stor1.field_0)
                    mem[_34792 + 728] = 68
                    mem[_34792 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34792 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34792 + 828 len 28]
                    mem[_34792 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34792 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34792 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34792 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34792 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34795 + 1)
            mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(13 * ceil32(return_data.size)) + 320] = 100
            mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
            mem[(13 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(13 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16978 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16978) + 160 <= arg2 + 128
                mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16978] = mem[arg3 + 160 len 32 * _16978]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34804 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34805 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34807 = sha3(mem[_34805 + 32 len mem[_34805]])
                if 1 > !sha3(mem[_34805 + 32 len mem[_34805]]):
                    revert with 0, 17
                mem[_34804 + 148] = address(arg1)
                mem[_34804 + 180] = arg4
                mem[_34804 + 212] = address(ext_call.return_data[0])
                mem[_34804 + 244] = 1
                mem[_34804 + 276] = _34807 + 1
                mem[_34804 + 116] = 160
                if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1), address(arg1));
                mem[_34804 + 308] = address(arg1)
                mem[_34804 + 340] = address(arg2)
                mem[_34804 + 372] = address(ext_call.return_data[0])
                mem[_34804 + 404] = 1
                mem[_34804 + 436] = arg4
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34804 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                mem[_34804 + 500] = arg5
                mem[_34804 + 532] = arg6
                mem[_34804 + 564] = arg7
                mem[_34804 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_1280 = mem[_34804 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34807 + 1].field_2304) = 0
                mem[_34804 + 664] = address(ext_call.return_data[0])
                mem[_34804 + 696] = address(stor1.field_0)
                mem[_34804 + 628] = 68
                mem[_34804 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34804 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34804 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34804 + 728 len 28]
                mem[_34804 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34804 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34804 + 732 len 64]
                if return_data.size:
                    mem[_34804 + 728] = return_data.size
                    mem[_34804 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34804 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34804 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34804 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34804 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34804 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34804 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34804 + 760], mem[_34804 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34804 + 764] = 1
                    mem[_34804 + 796] = address(stor1.field_0)
                    mem[_34804 + 728] = 68
                    mem[_34804 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34804 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34804 + 828 len 28]
                    mem[_34804 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34804 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34804 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34804 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34804 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34807 + 1)
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
            mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16907 = mem[(13 * ceil32(return_data.size)) + 484]
            require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
            require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
            _16979 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            require _16907 + (32 * _16979) + 64 <= return_data.size + 32
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16979] = mem[(13 * ceil32(return_data.size)) + _16907 + 516 len 32 * _16979]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16979:
                revert with 0, 50
            if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34808 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34809 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34811 = sha3(mem[_34809 + 32 len mem[_34809]])
            if 1 > !sha3(mem[_34809 + 32 len mem[_34809]]):
                revert with 0, 17
            mem[_34808 + 148] = address(arg1)
            mem[_34808 + 180] = arg4
            mem[_34808 + 212] = address(ext_call.return_data[0])
            mem[_34808 + 244] = 1
            mem[_34808 + 276] = _34811 + 1
            mem[_34808 + 116] = 160
            if 0 >= _16979:
                revert with 0, 50
            if 1 >= _16979:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1), address(arg1));
            mem[_34808 + 308] = address(arg1)
            mem[_34808 + 340] = address(arg2)
            mem[_34808 + 372] = address(ext_call.return_data[0])
            mem[_34808 + 404] = 1
            mem[_34808 + 436] = arg4
            if 1 >= _16979:
                revert with 0, 50
            mem[_34808 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34808 + 500] = arg5
            mem[_34808 + 532] = arg6
            mem[_34808 + 564] = arg7
            mem[_34808 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_1280 = mem[_34808 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34811 + 1].field_2304) = 0
            mem[_34808 + 664] = address(ext_call.return_data[0])
            mem[_34808 + 696] = address(stor1.field_0)
            mem[_34808 + 628] = 68
            mem[_34808 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34808 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34808 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34808 + 728 len 28]
            mem[_34808 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34808 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34808 + 732 len 64]
            if return_data.size:
                mem[_34808 + 728] = return_data.size
                mem[_34808 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34808 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34808 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34808 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34808 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34808 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34808 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34808 + 760], mem[_34808 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34808 + 764] = 1
                mem[_34808 + 796] = address(stor1.field_0)
                mem[_34808 + 728] = 68
                mem[_34808 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34808 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34808 + 828 len 28]
                mem[_34808 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34808 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34808 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34808 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34808 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34811 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 100
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
            mem[(14 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16982 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16982) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16982] = mem[arg3 + 160 len 32 * _16982]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34820 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34821 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34823 = sha3(mem[_34821 + 32 len mem[_34821]])
                if 1 > !sha3(mem[_34821 + 32 len mem[_34821]]):
                    revert with 0, 17
                mem[_34820 + 148] = address(arg1)
                mem[_34820 + 180] = arg4
                mem[_34820 + 212] = address(ext_call.return_data[0])
                mem[_34820 + 244] = 1
                mem[_34820 + 276] = _34823 + 1
                mem[_34820 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1), address(arg1));
                mem[_34820 + 308] = address(arg1)
                mem[_34820 + 340] = address(arg2)
                mem[_34820 + 372] = address(ext_call.return_data[0])
                mem[_34820 + 404] = 1
                mem[_34820 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34820 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
                mem[_34820 + 500] = arg5
                mem[_34820 + 532] = arg6
                mem[_34820 + 564] = arg7
                mem[_34820 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_1280 = mem[_34820 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34823 + 1].field_2304) = 0
                mem[_34820 + 664] = address(ext_call.return_data[0])
                mem[_34820 + 696] = address(stor1.field_0)
                mem[_34820 + 628] = 68
                mem[_34820 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34820 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34820 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34820 + 728 len 28]
                mem[_34820 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34820 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34820 + 732 len 64]
                if return_data.size:
                    mem[_34820 + 728] = return_data.size
                    mem[_34820 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34820 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34820 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34820 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34820 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34820 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34820 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34820 + 760], mem[_34820 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34820 + 764] = 1
                    mem[_34820 + 796] = address(stor1.field_0)
                    mem[_34820 + 728] = 68
                    mem[_34820 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34820 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34820 + 828 len 28]
                    mem[_34820 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34820 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34820 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34820 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34820 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34823 + 1)
            mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16911 = mem[(14 * ceil32(return_data.size)) + 484]
            require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
            _16983 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            require _16911 + (32 * _16983) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16983] = mem[(14 * ceil32(return_data.size)) + _16911 + 516 len 32 * _16983]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16983:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34824 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34825 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34827 = sha3(mem[_34825 + 32 len mem[_34825]])
            if 1 > !sha3(mem[_34825 + 32 len mem[_34825]]):
                revert with 0, 17
            mem[_34824 + 148] = address(arg1)
            mem[_34824 + 180] = arg4
            mem[_34824 + 212] = address(ext_call.return_data[0])
            mem[_34824 + 244] = 1
            mem[_34824 + 276] = _34827 + 1
            mem[_34824 + 116] = 160
            if 0 >= _16983:
                revert with 0, 50
            if 1 >= _16983:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1), address(arg1));
            mem[_34824 + 308] = address(arg1)
            mem[_34824 + 340] = address(arg2)
            mem[_34824 + 372] = address(ext_call.return_data[0])
            mem[_34824 + 404] = 1
            mem[_34824 + 436] = arg4
            if 1 >= _16983:
                revert with 0, 50
            mem[_34824 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34824 + 500] = arg5
            mem[_34824 + 532] = arg6
            mem[_34824 + 564] = arg7
            mem[_34824 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_1280 = mem[_34824 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34827 + 1].field_2304) = 0
            mem[_34824 + 664] = address(ext_call.return_data[0])
            mem[_34824 + 696] = address(stor1.field_0)
            mem[_34824 + 628] = 68
            mem[_34824 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34824 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34824 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34824 + 728 len 28]
            mem[_34824 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34824 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34824 + 732 len 64]
            if return_data.size:
                mem[_34824 + 728] = return_data.size
                mem[_34824 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34824 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34824 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34824 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34824 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34824 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34824 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34824 + 760], mem[_34824 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34824 + 764] = 1
                mem[_34824 + 796] = address(stor1.field_0)
                mem[_34824 + 728] = 68
                mem[_34824 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34824 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34824 + 828 len 28]
                mem[_34824 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34824 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34824 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34824 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34824 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34827 + 1)
        mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(14 * ceil32(return_data.size)) + 320] = 100
        mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
        mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
        mem[(14 * ceil32(return_data.size)) + 552] = 0
        delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
             gas gas_remaining wei
            args mem[(14 * ceil32(return_data.size)) + 456 len 96]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16986 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
            mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
            require arg3 + (32 * _16986) + 160 <= arg2 + 128
            mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16986] = mem[arg3 + 160 len 32 * _16986]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34836 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34837 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34839 = sha3(mem[_34837 + 32 len mem[_34837]])
            if 1 > !sha3(mem[_34837 + 32 len mem[_34837]]):
                revert with 0, 17
            mem[_34836 + 148] = address(arg1)
            mem[_34836 + 180] = arg4
            mem[_34836 + 212] = address(ext_call.return_data[0])
            mem[_34836 + 244] = 1
            mem[_34836 + 276] = _34839 + 1
            mem[_34836 + 116] = 160
            if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1), address(arg1));
            mem[_34836 + 308] = address(arg1)
            mem[_34836 + 340] = address(arg2)
            mem[_34836 + 372] = address(ext_call.return_data[0])
            mem[_34836 + 404] = 1
            mem[_34836 + 436] = arg4
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            mem[_34836 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
            mem[_34836 + 500] = arg5
            mem[_34836 + 532] = arg6
            mem[_34836 + 564] = arg7
            mem[_34836 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_1280 = mem[_34836 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34839 + 1].field_2304) = 0
            mem[_34836 + 664] = address(ext_call.return_data[0])
            mem[_34836 + 696] = address(stor1.field_0)
            mem[_34836 + 628] = 68
            mem[_34836 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34836 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34836 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34836 + 728 len 28]
            mem[_34836 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34836 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34836 + 732 len 64]
            if return_data.size:
                mem[_34836 + 728] = return_data.size
                mem[_34836 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34836 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34836 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34836 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34836 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34836 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34836 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34836 + 760], mem[_34836 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34836 + 764] = 1
                mem[_34836 + 796] = address(stor1.field_0)
                mem[_34836 + 728] = 68
                mem[_34836 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34836 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34836 + 828 len 28]
                mem[_34836 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34836 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34836 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34836 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34836 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34839 + 1)
        mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
        mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16915 = mem[(14 * ceil32(return_data.size)) + 484]
        require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
        require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
        _16987 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
            revert with 0, 65
        mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        require _16915 + (32 * _16987) + 64 <= return_data.size + 32
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16987] = mem[(14 * ceil32(return_data.size)) + _16915 + 516 len 32 * _16987]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16987:
            revert with 0, 50
        if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34840 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34841 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34843 = sha3(mem[_34841 + 32 len mem[_34841]])
        if 1 > !sha3(mem[_34841 + 32 len mem[_34841]]):
            revert with 0, 17
        mem[_34840 + 148] = address(arg1)
        mem[_34840 + 180] = arg4
        mem[_34840 + 212] = address(ext_call.return_data[0])
        mem[_34840 + 244] = 1
        mem[_34840 + 276] = _34843 + 1
        mem[_34840 + 116] = 160
        if 0 >= _16987:
            revert with 0, 50
        if 1 >= _16987:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1), address(arg1));
        mem[_34840 + 308] = address(arg1)
        mem[_34840 + 340] = address(arg2)
        mem[_34840 + 372] = address(ext_call.return_data[0])
        mem[_34840 + 404] = 1
        mem[_34840 + 436] = arg4
        if 1 >= _16987:
            revert with 0, 50
        mem[_34840 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        mem[_34840 + 500] = arg5
        mem[_34840 + 532] = arg6
        mem[_34840 + 564] = arg7
        mem[_34840 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_1280 = mem[_34840 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34843 + 1].field_2304) = 0
        mem[_34840 + 664] = address(ext_call.return_data[0])
        mem[_34840 + 696] = address(stor1.field_0)
        mem[_34840 + 628] = 68
        mem[_34840 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34840 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34840 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34840 + 728 len 28]
        mem[_34840 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34840 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34840 + 732 len 64]
        if return_data.size:
            mem[_34840 + 728] = return_data.size
            mem[_34840 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34840 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34840 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34840 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34840 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34840 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34840 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34840 + 760], mem[_34840 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34840 + 764] = 1
            mem[_34840 + 796] = address(stor1.field_0)
            mem[_34840 + 728] = 68
            mem[_34840 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34840 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34840 + 828 len 28]
            mem[_34840 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34840 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34840 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34840 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34840 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34843 + 1)
    require ext_code.size(address(arg3))
    call address(arg3).underlying() with:
         gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(6 * ceil32(return_data.size)) + 324] = address(arg2)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(7 * ceil32(return_data.size)) + 324] = address(arg3)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg3)
    mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
        revert with 0, 17
    if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    mem[0] = address(arg1)
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).factory() with:
            gas gas_remaining wei
    mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != 1:
        if address(ext_call.return_data[0]) != 1:
            mem[(10 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(11 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(12 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(13 * ceil32(return_data.size)) + 320] = 100
                mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
                mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
                mem[(13 * ceil32(return_data.size)) + 552] = 0
                delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                     gas gas_remaining wei
                    args mem[(13 * ceil32(return_data.size)) + 456 len 96]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16942 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                        revert with 0, 65
                    mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                    mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                    require arg3 + (32 * _16942) + 160 <= arg2 + 128
                    mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16942] = mem[arg3 + 160 len 32 * _16942]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(1, 4)
                    uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34660 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34661 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34663 = sha3(mem[_34661 + 32 len mem[_34661]])
                    if 1 > !sha3(mem[_34661 + 32 len mem[_34661]]):
                        revert with 0, 17
                    mem[_34660 + 148] = address(arg1)
                    mem[_34660 + 180] = arg4
                    mem[_34660 + 212] = address(ext_call.return_data[0])
                    mem[_34660 + 244] = 1
                    mem[_34660 + 276] = _34663 + 1
                    mem[_34660 + 116] = 160
                    if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1), address(arg1));
                    mem[_34660 + 308] = address(arg1)
                    mem[_34660 + 340] = address(arg2)
                    mem[_34660 + 372] = address(ext_call.return_data[0])
                    mem[_34660 + 404] = 1
                    mem[_34660 + 436] = arg4
                    if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                        revert with 0, 50
                    mem[_34660 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                    mem[_34660 + 500] = arg5
                    mem[_34660 + 532] = arg6
                    mem[_34660 + 564] = arg7
                    mem[_34660 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_512) = address(ext_call.return_data[0])
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_768) = 1
                    Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_776) = 0
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_1280 = mem[_34660 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34663 + 1].field_2304) = 0
                    mem[_34660 + 664] = address(ext_call.return_data[0])
                    mem[_34660 + 696] = address(stor1.field_0)
                    mem[_34660 + 628] = 68
                    mem[_34660 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34660 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34660 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34660 + 728 len 28]
                    mem[_34660 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34660 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34660 + 732 len 64]
                    if return_data.size:
                        mem[_34660 + 728] = return_data.size
                        mem[_34660 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34660 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34660 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34660 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34660 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34660 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34660 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34660 + 760], mem[_34660 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34660 + 764] = 1
                        mem[_34660 + 796] = address(stor1.field_0)
                        mem[_34660 + 728] = 68
                        mem[_34660 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34660 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34660 + 828 len 28]
                        mem[_34660 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34660 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34660 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34660 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34660 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34663 + 1)
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
                mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16871 = mem[(13 * ceil32(return_data.size)) + 484]
                require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
                require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
                _16943 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
                require _16871 + (32 * _16943) + 64 <= return_data.size + 32
                mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16943] = mem[(13 * ceil32(return_data.size)) + _16871 + 516 len 32 * _16943]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16943:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34664 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34665 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34667 = sha3(mem[_34665 + 32 len mem[_34665]])
                if 1 > !sha3(mem[_34665 + 32 len mem[_34665]]):
                    revert with 0, 17
                mem[_34664 + 148] = address(arg1)
                mem[_34664 + 180] = arg4
                mem[_34664 + 212] = address(ext_call.return_data[0])
                mem[_34664 + 244] = 1
                mem[_34664 + 276] = _34667 + 1
                mem[_34664 + 116] = 160
                if 0 >= _16943:
                    revert with 0, 50
                if 1 >= _16943:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1), address(arg1));
                mem[_34664 + 308] = address(arg1)
                mem[_34664 + 340] = address(arg2)
                mem[_34664 + 372] = address(ext_call.return_data[0])
                mem[_34664 + 404] = 1
                mem[_34664 + 436] = arg4
                if 1 >= _16943:
                    revert with 0, 50
                mem[_34664 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
                mem[_34664 + 500] = arg5
                mem[_34664 + 532] = arg6
                mem[_34664 + 564] = arg7
                mem[_34664 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_1280 = mem[_34664 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34667 + 1].field_2304) = 0
                mem[_34664 + 664] = address(ext_call.return_data[0])
                mem[_34664 + 696] = address(stor1.field_0)
                mem[_34664 + 628] = 68
                mem[_34664 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34664 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34664 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34664 + 728 len 28]
                mem[_34664 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34664 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34664 + 732 len 64]
                if return_data.size:
                    mem[_34664 + 728] = return_data.size
                    mem[_34664 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34664 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34664 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34664 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34664 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34664 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34664 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34664 + 760], mem[_34664 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34664 + 764] = 1
                    mem[_34664 + 796] = address(stor1.field_0)
                    mem[_34664 + 728] = 68
                    mem[_34664 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34664 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34664 + 828 len 28]
                    mem[_34664 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34664 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34664 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34664 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34664 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34667 + 1)
            mem[(12 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(12 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(13 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(13 * ceil32(return_data.size)) + 320] = 100
            mem[(13 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(13 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(13 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(13 * ceil32(return_data.size)) + 452 len 28]
            mem[(13 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(13 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(13 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16946 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (13 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(13 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16946) + 160 <= arg2 + 128
                mem[(13 * ceil32(return_data.size)) + 484 len 32 * _16946] = mem[arg3 + 160 len 32 * _16946]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(13 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34676 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34677 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34679 = sha3(mem[_34677 + 32 len mem[_34677]])
                if 1 > !sha3(mem[_34677 + 32 len mem[_34677]]):
                    revert with 0, 17
                mem[_34676 + 148] = address(arg1)
                mem[_34676 + 180] = arg4
                mem[_34676 + 212] = address(ext_call.return_data[0])
                mem[_34676 + 244] = 1
                mem[_34676 + 276] = _34679 + 1
                mem[_34676 + 116] = 160
                if 0 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + 484], mem[(13 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1), address(arg1));
                mem[_34676 + 308] = address(arg1)
                mem[_34676 + 340] = address(arg2)
                mem[_34676 + 372] = address(ext_call.return_data[0])
                mem[_34676 + 404] = 1
                mem[_34676 + 436] = arg4
                if 1 >= mem[(13 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34676 + 468] = mem[(13 * ceil32(return_data.size)) + 516]
                mem[_34676 + 500] = arg5
                mem[_34676 + 532] = arg6
                mem[_34676 + 564] = arg7
                mem[_34676 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_1280 = mem[_34676 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34679 + 1].field_2304) = 0
                mem[_34676 + 664] = address(ext_call.return_data[0])
                mem[_34676 + 696] = address(stor1.field_0)
                mem[_34676 + 628] = 68
                mem[_34676 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34676 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34676 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34676 + 728 len 28]
                mem[_34676 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34676 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34676 + 732 len 64]
                if return_data.size:
                    mem[_34676 + 728] = return_data.size
                    mem[_34676 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34676 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34676 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34676 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34676 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34676 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34676 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34676 + 760], mem[_34676 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34676 + 764] = 1
                    mem[_34676 + 796] = address(stor1.field_0)
                    mem[_34676 + 728] = 68
                    mem[_34676 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34676 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34676 + 828 len 28]
                    mem[_34676 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34676 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34676 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34676 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34676 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34679 + 1)
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453
            mem[(13 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(13 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16875 = mem[(13 * ceil32(return_data.size)) + 484]
            require mem[(13 * ceil32(return_data.size)) + 484] <= test266151307()
            require (13 * ceil32(return_data.size)) + return_data.size + 484 > (13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 515
            _16947 = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            if mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (13 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(13 * ceil32(return_data.size)) + mem[(13 * ceil32(return_data.size)) + 484] + 484]
            require _16875 + (32 * _16947) + 64 <= return_data.size + 32
            mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16947] = mem[(13 * ceil32(return_data.size)) + _16875 + 516 len 32 * _16947]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16947:
                revert with 0, 50
            if mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34680 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34681 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34683 = sha3(mem[_34681 + 32 len mem[_34681]])
            if 1 > !sha3(mem[_34681 + 32 len mem[_34681]]):
                revert with 0, 17
            mem[_34680 + 148] = address(arg1)
            mem[_34680 + 180] = arg4
            mem[_34680 + 212] = address(ext_call.return_data[0])
            mem[_34680 + 244] = 1
            mem[_34680 + 276] = _34683 + 1
            mem[_34680 + 116] = 160
            if 0 >= _16947:
                revert with 0, 50
            if 1 >= _16947:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1), address(arg1));
            mem[_34680 + 308] = address(arg1)
            mem[_34680 + 340] = address(arg2)
            mem[_34680 + 372] = address(ext_call.return_data[0])
            mem[_34680 + 404] = 1
            mem[_34680 + 436] = arg4
            if 1 >= _16947:
                revert with 0, 50
            mem[_34680 + 468] = mem[(13 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34680 + 500] = arg5
            mem[_34680 + 532] = arg6
            mem[_34680 + 564] = arg7
            mem[_34680 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_1280 = mem[_34680 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34683 + 1].field_2304) = 0
            mem[_34680 + 664] = address(ext_call.return_data[0])
            mem[_34680 + 696] = address(stor1.field_0)
            mem[_34680 + 628] = 68
            mem[_34680 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34680 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34680 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34680 + 728 len 28]
            mem[_34680 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34680 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34680 + 732 len 64]
            if return_data.size:
                mem[_34680 + 728] = return_data.size
                mem[_34680 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34680 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34680 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34680 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34680 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34680 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34680 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34680 + 760], mem[_34680 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34680 + 764] = 1
                mem[_34680 + 796] = address(stor1.field_0)
                mem[_34680 + 728] = 68
                mem[_34680 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34680 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34680 + 828 len 28]
                mem[_34680 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34680 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34680 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34680 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34680 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34683 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 100
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
            mem[(14 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16950 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16950) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16950] = mem[arg3 + 160 len 32 * _16950]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34692 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34693 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34695 = sha3(mem[_34693 + 32 len mem[_34693]])
                if 1 > !sha3(mem[_34693 + 32 len mem[_34693]]):
                    revert with 0, 17
                mem[_34692 + 148] = address(arg1)
                mem[_34692 + 180] = arg4
                mem[_34692 + 212] = address(ext_call.return_data[0])
                mem[_34692 + 244] = 1
                mem[_34692 + 276] = _34695 + 1
                mem[_34692 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1), address(arg1));
                mem[_34692 + 308] = address(arg1)
                mem[_34692 + 340] = address(arg2)
                mem[_34692 + 372] = address(ext_call.return_data[0])
                mem[_34692 + 404] = 1
                mem[_34692 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34692 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
                mem[_34692 + 500] = arg5
                mem[_34692 + 532] = arg6
                mem[_34692 + 564] = arg7
                mem[_34692 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_1280 = mem[_34692 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34695 + 1].field_2304) = 0
                mem[_34692 + 664] = address(ext_call.return_data[0])
                mem[_34692 + 696] = address(stor1.field_0)
                mem[_34692 + 628] = 68
                mem[_34692 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34692 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34692 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34692 + 728 len 28]
                mem[_34692 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34692 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34692 + 732 len 64]
                if return_data.size:
                    mem[_34692 + 728] = return_data.size
                    mem[_34692 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34692 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34692 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34692 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34692 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34692 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34692 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34692 + 760], mem[_34692 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34692 + 764] = 1
                    mem[_34692 + 796] = address(stor1.field_0)
                    mem[_34692 + 728] = 68
                    mem[_34692 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34692 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34692 + 828 len 28]
                    mem[_34692 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34692 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34692 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34692 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34692 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34695 + 1)
            mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16879 = mem[(14 * ceil32(return_data.size)) + 484]
            require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
            _16951 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            require _16879 + (32 * _16951) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16951] = mem[(14 * ceil32(return_data.size)) + _16879 + 516 len 32 * _16951]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16951:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34696 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34697 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34699 = sha3(mem[_34697 + 32 len mem[_34697]])
            if 1 > !sha3(mem[_34697 + 32 len mem[_34697]]):
                revert with 0, 17
            mem[_34696 + 148] = address(arg1)
            mem[_34696 + 180] = arg4
            mem[_34696 + 212] = address(ext_call.return_data[0])
            mem[_34696 + 244] = 1
            mem[_34696 + 276] = _34699 + 1
            mem[_34696 + 116] = 160
            if 0 >= _16951:
                revert with 0, 50
            if 1 >= _16951:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1), address(arg1));
            mem[_34696 + 308] = address(arg1)
            mem[_34696 + 340] = address(arg2)
            mem[_34696 + 372] = address(ext_call.return_data[0])
            mem[_34696 + 404] = 1
            mem[_34696 + 436] = arg4
            if 1 >= _16951:
                revert with 0, 50
            mem[_34696 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34696 + 500] = arg5
            mem[_34696 + 532] = arg6
            mem[_34696 + 564] = arg7
            mem[_34696 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_1280 = mem[_34696 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34699 + 1].field_2304) = 0
            mem[_34696 + 664] = address(ext_call.return_data[0])
            mem[_34696 + 696] = address(stor1.field_0)
            mem[_34696 + 628] = 68
            mem[_34696 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34696 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34696 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34696 + 728 len 28]
            mem[_34696 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34696 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34696 + 732 len 64]
            if return_data.size:
                mem[_34696 + 728] = return_data.size
                mem[_34696 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34696 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34696 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34696 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34696 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34696 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34696 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34696 + 760], mem[_34696 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34696 + 764] = 1
                mem[_34696 + 796] = address(stor1.field_0)
                mem[_34696 + 728] = 68
                mem[_34696 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34696 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34696 + 828 len 28]
                mem[_34696 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34696 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34696 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34696 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34696 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34699 + 1)
        mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(14 * ceil32(return_data.size)) + 320] = 100
        mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
        mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
        mem[(14 * ceil32(return_data.size)) + 552] = 0
        delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
             gas gas_remaining wei
            args mem[(14 * ceil32(return_data.size)) + 456 len 96]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16954 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
            mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
            require arg3 + (32 * _16954) + 160 <= arg2 + 128
            mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16954] = mem[arg3 + 160 len 32 * _16954]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34708 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34709 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34711 = sha3(mem[_34709 + 32 len mem[_34709]])
            if 1 > !sha3(mem[_34709 + 32 len mem[_34709]]):
                revert with 0, 17
            mem[_34708 + 148] = address(arg1)
            mem[_34708 + 180] = arg4
            mem[_34708 + 212] = address(ext_call.return_data[0])
            mem[_34708 + 244] = 1
            mem[_34708 + 276] = _34711 + 1
            mem[_34708 + 116] = 160
            if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1), address(arg1));
            mem[_34708 + 308] = address(arg1)
            mem[_34708 + 340] = address(arg2)
            mem[_34708 + 372] = address(ext_call.return_data[0])
            mem[_34708 + 404] = 1
            mem[_34708 + 436] = arg4
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            mem[_34708 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
            mem[_34708 + 500] = arg5
            mem[_34708 + 532] = arg6
            mem[_34708 + 564] = arg7
            mem[_34708 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_1280 = mem[_34708 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34711 + 1].field_2304) = 0
            mem[_34708 + 664] = address(ext_call.return_data[0])
            mem[_34708 + 696] = address(stor1.field_0)
            mem[_34708 + 628] = 68
            mem[_34708 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34708 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34708 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34708 + 728 len 28]
            mem[_34708 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34708 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34708 + 732 len 64]
            if return_data.size:
                mem[_34708 + 728] = return_data.size
                mem[_34708 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34708 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34708 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34708 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34708 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34708 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34708 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34708 + 760], mem[_34708 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34708 + 764] = 1
                mem[_34708 + 796] = address(stor1.field_0)
                mem[_34708 + 728] = 68
                mem[_34708 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34708 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34708 + 828 len 28]
                mem[_34708 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34708 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34708 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34708 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34708 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34711 + 1)
        mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
        mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16883 = mem[(14 * ceil32(return_data.size)) + 484]
        require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
        require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
        _16955 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
            revert with 0, 65
        mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        require _16883 + (32 * _16955) + 64 <= return_data.size + 32
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16955] = mem[(14 * ceil32(return_data.size)) + _16883 + 516 len 32 * _16955]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16955:
            revert with 0, 50
        if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34712 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34713 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34715 = sha3(mem[_34713 + 32 len mem[_34713]])
        if 1 > !sha3(mem[_34713 + 32 len mem[_34713]]):
            revert with 0, 17
        mem[_34712 + 148] = address(arg1)
        mem[_34712 + 180] = arg4
        mem[_34712 + 212] = address(ext_call.return_data[0])
        mem[_34712 + 244] = 1
        mem[_34712 + 276] = _34715 + 1
        mem[_34712 + 116] = 160
        if 0 >= _16955:
            revert with 0, 50
        if 1 >= _16955:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1), address(arg1));
        mem[_34712 + 308] = address(arg1)
        mem[_34712 + 340] = address(arg2)
        mem[_34712 + 372] = address(ext_call.return_data[0])
        mem[_34712 + 404] = 1
        mem[_34712 + 436] = arg4
        if 1 >= _16955:
            revert with 0, 50
        mem[_34712 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        mem[_34712 + 500] = arg5
        mem[_34712 + 532] = arg6
        mem[_34712 + 564] = arg7
        mem[_34712 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_1280 = mem[_34712 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34715 + 1].field_2304) = 0
        mem[_34712 + 664] = address(ext_call.return_data[0])
        mem[_34712 + 696] = address(stor1.field_0)
        mem[_34712 + 628] = 68
        mem[_34712 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34712 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34712 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34712 + 728 len 28]
        mem[_34712 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34712 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34712 + 732 len 64]
        if return_data.size:
            mem[_34712 + 728] = return_data.size
            mem[_34712 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34712 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34712 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34712 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34712 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34712 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34712 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34712 + 760], mem[_34712 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34712 + 764] = 1
            mem[_34712 + 796] = address(stor1.field_0)
            mem[_34712 + 728] = 68
            mem[_34712 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34712 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34712 + 828 len 28]
            mem[_34712 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34712 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34712 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34712 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34712 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34715 + 1)
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).WAVAX() with:
            gas gas_remaining wei
    mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != 1:
        mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 100
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
            mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
            mem[(14 * ceil32(return_data.size)) + 552] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 456 len 96]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16958 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
                mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
                require arg3 + (32 * _16958) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16958] = mem[arg3 + 160 len 32 * _16958]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(1, 4)
                uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34724 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34725 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34727 = sha3(mem[_34725 + 32 len mem[_34725]])
                if 1 > !sha3(mem[_34725 + 32 len mem[_34725]]):
                    revert with 0, 17
                mem[_34724 + 148] = address(arg1)
                mem[_34724 + 180] = arg4
                mem[_34724 + 212] = address(ext_call.return_data[0])
                mem[_34724 + 244] = 1
                mem[_34724 + 276] = _34727 + 1
                mem[_34724 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1), address(arg1));
                mem[_34724 + 308] = address(arg1)
                mem[_34724 + 340] = address(arg2)
                mem[_34724 + 372] = address(ext_call.return_data[0])
                mem[_34724 + 404] = 1
                mem[_34724 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                    revert with 0, 50
                mem[_34724 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
                mem[_34724 + 500] = arg5
                mem[_34724 + 532] = arg6
                mem[_34724 + 564] = arg7
                mem[_34724 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_512) = address(ext_call.return_data[0])
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_768) = 1
                Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_776) = 0
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_1280 = mem[_34724 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34727 + 1].field_2304) = 0
                mem[_34724 + 664] = address(ext_call.return_data[0])
                mem[_34724 + 696] = address(stor1.field_0)
                mem[_34724 + 628] = 68
                mem[_34724 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34724 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34724 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34724 + 728 len 28]
                mem[_34724 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34724 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34724 + 732 len 64]
                if return_data.size:
                    mem[_34724 + 728] = return_data.size
                    mem[_34724 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34724 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34724 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34724 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34724 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34724 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34724 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34724 + 760], mem[_34724 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34724 + 764] = 1
                    mem[_34724 + 796] = address(stor1.field_0)
                    mem[_34724 + 728] = 68
                    mem[_34724 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34724 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34724 + 828 len 28]
                    mem[_34724 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34724 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34724 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34724 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34724 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34727 + 1)
            mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16887 = mem[(14 * ceil32(return_data.size)) + 484]
            require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
            _16959 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
            require _16887 + (32 * _16959) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16959] = mem[(14 * ceil32(return_data.size)) + _16887 + 516 len 32 * _16959]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16959:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34728 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34729 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34731 = sha3(mem[_34729 + 32 len mem[_34729]])
            if 1 > !sha3(mem[_34729 + 32 len mem[_34729]]):
                revert with 0, 17
            mem[_34728 + 148] = address(arg1)
            mem[_34728 + 180] = arg4
            mem[_34728 + 212] = address(ext_call.return_data[0])
            mem[_34728 + 244] = 1
            mem[_34728 + 276] = _34731 + 1
            mem[_34728 + 116] = 160
            if 0 >= _16959:
                revert with 0, 50
            if 1 >= _16959:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1), address(arg1));
            mem[_34728 + 308] = address(arg1)
            mem[_34728 + 340] = address(arg2)
            mem[_34728 + 372] = address(ext_call.return_data[0])
            mem[_34728 + 404] = 1
            mem[_34728 + 436] = arg4
            if 1 >= _16959:
                revert with 0, 50
            mem[_34728 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
            mem[_34728 + 500] = arg5
            mem[_34728 + 532] = arg6
            mem[_34728 + 564] = arg7
            mem[_34728 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_1280 = mem[_34728 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34731 + 1].field_2304) = 0
            mem[_34728 + 664] = address(ext_call.return_data[0])
            mem[_34728 + 696] = address(stor1.field_0)
            mem[_34728 + 628] = 68
            mem[_34728 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34728 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34728 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34728 + 728 len 28]
            mem[_34728 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34728 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34728 + 732 len 64]
            if return_data.size:
                mem[_34728 + 728] = return_data.size
                mem[_34728 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34728 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34728 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34728 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34728 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34728 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34728 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34728 + 760], mem[_34728 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34728 + 764] = 1
                mem[_34728 + 796] = address(stor1.field_0)
                mem[_34728 + 728] = 68
                mem[_34728 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34728 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34728 + 828 len 28]
                mem[_34728 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34728 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34728 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34728 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34728 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34731 + 1)
        mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(14 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(14 * ceil32(return_data.size)) + 320] = 100
        mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(14 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
        mem[(14 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 452 len 28]
        mem[(14 * ceil32(return_data.size)) + 552] = 0
        delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 452 len 4] with:
             gas gas_remaining wei
            args mem[(14 * ceil32(return_data.size)) + 456 len 96]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16962 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
            mem[(14 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
            require arg3 + (32 * _16962) + 160 <= arg2 + 128
            mem[(14 * ceil32(return_data.size)) + 484 len 32 * _16962] = mem[arg3 + 160 len 32 * _16962]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 516]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34740 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34741 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34743 = sha3(mem[_34741 + 32 len mem[_34741]])
            if 1 > !sha3(mem[_34741 + 32 len mem[_34741]]):
                revert with 0, 17
            mem[_34740 + 148] = address(arg1)
            mem[_34740 + 180] = arg4
            mem[_34740 + 212] = address(ext_call.return_data[0])
            mem[_34740 + 244] = 1
            mem[_34740 + 276] = _34743 + 1
            mem[_34740 + 116] = 160
            if 0 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + 484], mem[(14 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1), address(arg1));
            mem[_34740 + 308] = address(arg1)
            mem[_34740 + 340] = address(arg2)
            mem[_34740 + 372] = address(ext_call.return_data[0])
            mem[_34740 + 404] = 1
            mem[_34740 + 436] = arg4
            if 1 >= mem[(14 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            mem[_34740 + 468] = mem[(14 * ceil32(return_data.size)) + 516]
            mem[_34740 + 500] = arg5
            mem[_34740 + 532] = arg6
            mem[_34740 + 564] = arg7
            mem[_34740 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_1280 = mem[_34740 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34743 + 1].field_2304) = 0
            mem[_34740 + 664] = address(ext_call.return_data[0])
            mem[_34740 + 696] = address(stor1.field_0)
            mem[_34740 + 628] = 68
            mem[_34740 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34740 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34740 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34740 + 728 len 28]
            mem[_34740 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34740 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34740 + 732 len 64]
            if return_data.size:
                mem[_34740 + 728] = return_data.size
                mem[_34740 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34740 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34740 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34740 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34740 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34740 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34740 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34740 + 760], mem[_34740 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34740 + 764] = 1
                mem[_34740 + 796] = address(stor1.field_0)
                mem[_34740 + 728] = 68
                mem[_34740 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34740 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34740 + 828 len 28]
                mem[_34740 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34740 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34740 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34740 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34740 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34743 + 1)
        mem[(14 * ceil32(return_data.size)) + 452] = return_data.size
        mem[(14 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16891 = mem[(14 * ceil32(return_data.size)) + 484]
        require mem[(14 * ceil32(return_data.size)) + 484] <= test266151307()
        require (14 * ceil32(return_data.size)) + return_data.size + 484 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 515
        _16963 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
            revert with 0, 65
        mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]) + 454
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 484] + 484]
        require _16891 + (32 * _16963) + 64 <= return_data.size + 32
        mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16963] = mem[(14 * ceil32(return_data.size)) + _16891 + 516 len 32 * _16963]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16963:
            revert with 0, 50
        if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34744 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34745 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34747 = sha3(mem[_34745 + 32 len mem[_34745]])
        if 1 > !sha3(mem[_34745 + 32 len mem[_34745]]):
            revert with 0, 17
        mem[_34744 + 148] = address(arg1)
        mem[_34744 + 180] = arg4
        mem[_34744 + 212] = address(ext_call.return_data[0])
        mem[_34744 + 244] = 1
        mem[_34744 + 276] = _34747 + 1
        mem[_34744 + 116] = 160
        if 0 >= _16963:
            revert with 0, 50
        if 1 >= _16963:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1), address(arg1));
        mem[_34744 + 308] = address(arg1)
        mem[_34744 + 340] = address(arg2)
        mem[_34744 + 372] = address(ext_call.return_data[0])
        mem[_34744 + 404] = 1
        mem[_34744 + 436] = arg4
        if 1 >= _16963:
            revert with 0, 50
        mem[_34744 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        mem[_34744 + 500] = arg5
        mem[_34744 + 532] = arg6
        mem[_34744 + 564] = arg7
        mem[_34744 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_1280 = mem[_34744 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34747 + 1].field_2304) = 0
        mem[_34744 + 664] = address(ext_call.return_data[0])
        mem[_34744 + 696] = address(stor1.field_0)
        mem[_34744 + 628] = 68
        mem[_34744 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34744 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34744 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34744 + 728 len 28]
        mem[_34744 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34744 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34744 + 732 len 64]
        if return_data.size:
            mem[_34744 + 728] = return_data.size
            mem[_34744 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34744 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34744 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34744 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34744 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34744 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34744 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34744 + 760], mem[_34744 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34744 + 764] = 1
            mem[_34744 + 796] = address(stor1.field_0)
            mem[_34744 + 728] = 68
            mem[_34744 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34744 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34744 + 828 len 28]
            mem[_34744 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34744 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34744 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34744 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34744 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34747 + 1)
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).WAVAX() with:
            gas gas_remaining wei
    mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(12 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
    mem[(12 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
            gas gas_remaining wei
           args address(ext_call.return_data[0]), address(ext_call.return_data[0])
    mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'token pair error'
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    mem[(13 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    mem[(14 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
    if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
        mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
        mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(15 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(15 * ceil32(return_data.size)) + 320] = 100
        mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(15 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
        mem[(15 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 452 len 28]
        mem[(15 * ceil32(return_data.size)) + 552] = 0
        delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 452 len 4] with:
             gas gas_remaining wei
            args mem[(15 * ceil32(return_data.size)) + 456 len 96]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16966 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
            mem[(15 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
            require arg3 + (32 * _16966) + 160 <= arg2 + 128
            mem[(15 * ceil32(return_data.size)) + 484 len 32 * _16966] = mem[arg3 + 160 len 32 * _16966]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(1, 4)
            uint256(sub_996e5938[1][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 516]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34756 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34757 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34759 = sha3(mem[_34757 + 32 len mem[_34757]])
            if 1 > !sha3(mem[_34757 + 32 len mem[_34757]]):
                revert with 0, 17
            mem[_34756 + 148] = address(arg1)
            mem[_34756 + 180] = arg4
            mem[_34756 + 212] = address(ext_call.return_data[0])
            mem[_34756 + 244] = 1
            mem[_34756 + 276] = _34759 + 1
            mem[_34756 + 116] = 160
            if 0 >= mem[(15 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(15 * ceil32(return_data.size)) + 484], mem[(15 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1), address(arg1));
            mem[_34756 + 308] = address(arg1)
            mem[_34756 + 340] = address(arg2)
            mem[_34756 + 372] = address(ext_call.return_data[0])
            mem[_34756 + 404] = 1
            mem[_34756 + 436] = arg4
            if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
                revert with 0, 50
            mem[_34756 + 468] = mem[(15 * ceil32(return_data.size)) + 516]
            mem[_34756 + 500] = arg5
            mem[_34756 + 532] = arg6
            mem[_34756 + 564] = arg7
            mem[_34756 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_512) = address(ext_call.return_data[0])
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_768) = 1
            Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_776) = 0
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_1280 = mem[_34756 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34759 + 1].field_2304) = 0
            mem[_34756 + 664] = address(ext_call.return_data[0])
            mem[_34756 + 696] = address(stor1.field_0)
            mem[_34756 + 628] = 68
            mem[_34756 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34756 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34756 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34756 + 728 len 28]
            mem[_34756 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34756 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34756 + 732 len 64]
            if return_data.size:
                mem[_34756 + 728] = return_data.size
                mem[_34756 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34756 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34756 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34756 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34756 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34756 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34756 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34756 + 760], mem[_34756 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34756 + 764] = 1
                mem[_34756 + 796] = address(stor1.field_0)
                mem[_34756 + 728] = 68
                mem[_34756 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34756 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34756 + 828 len 28]
                mem[_34756 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34756 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34756 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34756 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34756 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34759 + 1)
        mem[(15 * ceil32(return_data.size)) + 452] = return_data.size
        mem[(15 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16895 = mem[(15 * ceil32(return_data.size)) + 484]
        require mem[(15 * ceil32(return_data.size)) + 484] <= test266151307()
        require (15 * ceil32(return_data.size)) + return_data.size + 484 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 515
        _16967 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]
        if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]
        require _16895 + (32 * _16967) + 64 <= return_data.size + 32
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16967] = mem[(15 * ceil32(return_data.size)) + _16895 + 516 len 32 * _16967]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16967:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34760 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34761 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34763 = sha3(mem[_34761 + 32 len mem[_34761]])
        if 1 > !sha3(mem[_34761 + 32 len mem[_34761]]):
            revert with 0, 17
        mem[_34760 + 148] = address(arg1)
        mem[_34760 + 180] = arg4
        mem[_34760 + 212] = address(ext_call.return_data[0])
        mem[_34760 + 244] = 1
        mem[_34760 + 276] = _34763 + 1
        mem[_34760 + 116] = 160
        if 0 >= _16967:
            revert with 0, 50
        if 1 >= _16967:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1), address(arg1));
        mem[_34760 + 308] = address(arg1)
        mem[_34760 + 340] = address(arg2)
        mem[_34760 + 372] = address(ext_call.return_data[0])
        mem[_34760 + 404] = 1
        mem[_34760 + 436] = arg4
        if 1 >= _16967:
            revert with 0, 50
        mem[_34760 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
        mem[_34760 + 500] = arg5
        mem[_34760 + 532] = arg6
        mem[_34760 + 564] = arg7
        mem[_34760 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_1280 = mem[_34760 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34763 + 1].field_2304) = 0
        mem[_34760 + 664] = address(ext_call.return_data[0])
        mem[_34760 + 696] = address(stor1.field_0)
        mem[_34760 + 628] = 68
        mem[_34760 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34760 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34760 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34760 + 728 len 28]
        mem[_34760 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34760 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34760 + 732 len 64]
        if return_data.size:
            mem[_34760 + 728] = return_data.size
            mem[_34760 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34760 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34760 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34760 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34760 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34760 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34760 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34760 + 760], mem[_34760 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34760 + 764] = 1
            mem[_34760 + 796] = address(stor1.field_0)
            mem[_34760 + 728] = 68
            mem[_34760 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34760 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34760 + 828 len 28]
            mem[_34760 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34760 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34760 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34760 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34760 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34763 + 1)
    mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
    mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
            gas gas_remaining wei
           args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
    mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0, 'error PairPrice'
    if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
        revert with 0, 17
    if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
        revert with 0, 'price error'
    mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
    mem[(15 * ceil32(return_data.size)) + 388] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
    mem[(15 * ceil32(return_data.size)) + 420] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
    mem[(15 * ceil32(return_data.size)) + 320] = 100
    mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
    mem[(15 * ceil32(return_data.size)) + 352 len 4] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3)
    mem[(15 * ceil32(return_data.size)) + 452 len 128] = swapERC20ToETH(address rg1, uint256 rg2, uint256 rg3), address(ext_call.return_data[0]) << 64, 0, (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 452 len 28]
    mem[(15 * ceil32(return_data.size)) + 552] = 0
    delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 452 len 4] with:
         gas gas_remaining wei
        args mem[(15 * ceil32(return_data.size)) + 456 len 96]
    if not return_data.size:
        if not delegate.return_code:
            revert with memory
              from 128
               len return_data.size
        require arg2 >= 32
        require arg3 <= test266151307()
        require arg2 + 128 > arg3 + 159
        _16970 = mem[arg3 + 128]
        if mem[arg3 + 128] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[arg3 + 128]) + 453 < 452 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 453
        mem[(15 * ceil32(return_data.size)) + 452] = mem[arg3 + 128]
        require arg3 + (32 * _16970) + 160 <= arg2 + 128
        mem[(15 * ceil32(return_data.size)) + 484 len 32 * _16970] = mem[arg3 + 160 len 32 * _16970]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + 516] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(1, 4)
        uint256(sub_996e5938[1][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 516]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34772 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34773 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34775 = sha3(mem[_34773 + 32 len mem[_34773]])
        if 1 > !sha3(mem[_34773 + 32 len mem[_34773]]):
            revert with 0, 17
        mem[_34772 + 148] = address(arg1)
        mem[_34772 + 180] = arg4
        mem[_34772 + 212] = address(ext_call.return_data[0])
        mem[_34772 + 244] = 1
        mem[_34772 + 276] = _34775 + 1
        mem[_34772 + 116] = 160
        if 0 >= mem[(15 * ceil32(return_data.size)) + 452]:
            revert with 0, 50
        if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(15 * ceil32(return_data.size)) + 484], mem[(15 * ceil32(return_data.size)) + 516], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1), address(arg1));
        mem[_34772 + 308] = address(arg1)
        mem[_34772 + 340] = address(arg2)
        mem[_34772 + 372] = address(ext_call.return_data[0])
        mem[_34772 + 404] = 1
        mem[_34772 + 436] = arg4
        if 1 >= mem[(15 * ceil32(return_data.size)) + 452]:
            revert with 0, 50
        mem[_34772 + 468] = mem[(15 * ceil32(return_data.size)) + 516]
        mem[_34772 + 500] = arg5
        mem[_34772 + 532] = arg6
        mem[_34772 + 564] = arg7
        mem[_34772 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_512) = address(ext_call.return_data[0])
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_768) = 1
        Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_776) = 0
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_1280 = mem[_34772 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34775 + 1].field_2304) = 0
        mem[_34772 + 664] = address(ext_call.return_data[0])
        mem[_34772 + 696] = address(stor1.field_0)
        mem[_34772 + 628] = 68
        mem[_34772 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34772 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34772 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34772 + 728 len 28]
        mem[_34772 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34772 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34772 + 732 len 64]
        if return_data.size:
            mem[_34772 + 728] = return_data.size
            mem[_34772 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34772 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34772 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34772 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34772 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34772 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34772 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34772 + 760], mem[_34772 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34772 + 764] = 1
            mem[_34772 + 796] = address(stor1.field_0)
            mem[_34772 + 728] = 68
            mem[_34772 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34772 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34772 + 828 len 28]
            mem[_34772 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34772 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34772 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34772 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34772 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34775 + 1)
    mem[(15 * ceil32(return_data.size)) + 452] = return_data.size
    mem[(15 * ceil32(return_data.size)) + 484 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _16899 = mem[(15 * ceil32(return_data.size)) + 484]
    require mem[(15 * ceil32(return_data.size)) + 484] <= test266151307()
    require (15 * ceil32(return_data.size)) + return_data.size + 484 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 515
    _16971 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]
    if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454 < 453 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454 > test266151307():
        revert with 0, 65
    mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]) + 454
    mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 484] + 484]
    require _16899 + (32 * _16971) + 64 <= return_data.size + 32
    mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485 len 32 * _16971] = mem[(15 * ceil32(return_data.size)) + _16899 + 516 len 32 * _16971]
    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
        revert with 0, 'subBalance error'
    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
    if uint8(arg8) < 1:
        revert with 0, 17
    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
        revert with 0, 'subLeverage error'
    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
    if 1 >= _16971:
        revert with 0, 50
    if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] + uint256(sub_996e5938[1][address(arg1)]) < uint256(sub_996e5938[1][address(arg1)]):
        revert with 0, 'addBalance error'
    mem[0] = address(arg1)
    mem[32] = sha3(1, 4)
    uint256(sub_996e5938[1][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
    if stor10 == -1:
        revert with 0, 17
    stor10++
    _34776 = mem[64]
    mem[mem[64] + 32] = block.timestamp
    mem[mem[64] + 64] = address(msg.sender)
    mem[mem[64] + 84] = stor10
    _34777 = mem[64]
    mem[mem[64]] = 84
    mem[64] = mem[64] + 116
    _34779 = sha3(mem[_34777 + 32 len mem[_34777]])
    if 1 > !sha3(mem[_34777 + 32 len mem[_34777]]):
        revert with 0, 17
    mem[_34776 + 148] = address(arg1)
    mem[_34776 + 180] = arg4
    mem[_34776 + 212] = address(ext_call.return_data[0])
    mem[_34776 + 244] = 1
    mem[_34776 + 276] = _34779 + 1
    mem[_34776 + 116] = 160
    if 0 >= _16971:
        revert with 0, 50
    if 1 >= _16971:
        revert with 0, 50
    emit OnTokenSwapped(address(ext_call.return_data[0]), 1, mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1), address(arg1));
    mem[_34776 + 308] = address(arg1)
    mem[_34776 + 340] = address(arg2)
    mem[_34776 + 372] = address(ext_call.return_data[0])
    mem[_34776 + 404] = 1
    mem[_34776 + 436] = arg4
    if 1 >= _16971:
        revert with 0, 50
    mem[_34776 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517]
    mem[_34776 + 500] = arg5
    mem[_34776 + 532] = arg6
    mem[_34776 + 564] = arg7
    mem[_34776 + 596] = uint8(arg8)
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_0) = address(arg1)
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_256) = uint64(arg2) << 96
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_512) = address(ext_call.return_data[0])
    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_768) = 1
    Mask(152, 0, stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_776) = 0
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_1024 = arg4
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_1280 = mem[_34776 + 468]
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_1536 = arg5
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_1792 = arg6
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_2048 = arg7
    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][1][_34779 + 1].field_2304) = 0
    mem[_34776 + 664] = address(ext_call.return_data[0])
    mem[_34776 + 696] = address(stor1.field_0)
    mem[_34776 + 628] = 68
    mem[_34776 + 664 len 28] = address(ext_call.return_data[0]) << 64
    mem[_34776 + 660 len 4] = getPairPrice(address rg1, address rg2)
    mem[_34776 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34776 + 728 len 28]
    mem[_34776 + 796] = 0
    delegate sub_0fc6a11cAddress.mem[_34776 + 728 len 4] with:
         gas gas_remaining wei
        args mem[_34776 + 732 len 64]
    if return_data.size:
        mem[_34776 + 728] = return_data.size
        mem[_34776 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[_34776 + ceil32(return_data.size) + 829 len 96] = 0, 1, address(stor1.field_0), mem[_34776 + ceil32(return_data.size) + 829 len 28]
        delegate sub_0fc6a11cAddress.mem[_34776 + ceil32(return_data.size) + 829 len 4] with:
             gas gas_remaining wei
            args mem[_34776 + ceil32(return_data.size) + 833 len 64]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34776 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            mem[_34776 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, mem[_34776 + 760], mem[_34776 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1), address(arg1), address(ext_call.return_data[0])
    else:
        if not delegate.return_code:
            revert with memory
              from 128
               len return_data.size
        require arg2 >= 32
        mem[_34776 + 764] = 1
        mem[_34776 + 796] = address(stor1.field_0)
        mem[_34776 + 728] = 68
        mem[_34776 + 760 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34776 + 828 len 96] = 0, 1, address(stor1.field_0), mem[_34776 + 828 len 28]
        mem[_34776 + 896] = 0
        delegate sub_0fc6a11cAddress.mem[_34776 + 828 len 4] with:
             gas gas_remaining wei
            args mem[_34776 + 832 len 64]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            mem[_34776 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit 0x12cdba7c: address(arg2), 1, arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34776 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1), address(arg1), address(ext_call.return_data[0])
    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), 1, _34779 + 1)
}

function sub_dded4b8e(?) payable {
    require calldata.size - 4 >= 256
    require arg1 == address(arg1)
    require calldata.size - 36 >= 224
    require arg2 == address(arg2)
    mem[96] = arg2
    require arg3 == address(arg3)
    mem[128] = arg3
    mem[160] = arg4
    mem[192] = arg5
    mem[224] = arg6
    mem[256] = arg7
    require arg8 == uint8(arg8)
    mem[288] = arg8
    if uint8(stor1.field_200):
        revert with 0, 'veeLock: Lock System'
    if uint8(stor1.field_168):
        revert with 0, 'veeLock: Lock All'
    if uint8(stor1.field_176):
        revert with 0, 'veeLock: Lock Create'
    require ext_code.size(address(arg2))
    call address(arg2).underlying() with:
         gas gas_remaining wei
    mem[320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(arg3))
    call address(arg3).underlying() with:
         gas gas_remaining wei
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if not address(ext_call.return_data[0]):
        revert with 0, 'invalid tokenA'
    if not address(arg2):
        revert with 0, 'invalid ctoken'
    if address(arg2) != msg.sender:
        revert with 0, 'ctokenA error'
    if not uint8(roleAdmin[0xfe3e4be5f6b07b365e34e10539187d328f7295d5adbbb5b80e0b8b6a2d9e9324][address(msg.sender)].field_0):
        revert with 0, 'VEETOKEN required'
    if not address(arg1):
        revert with 0, 'invalid order owner'
    if not address(stor1.field_0):
        revert with 0, 'invalid baseToken'
    if not arg5:
        revert with 0, 'invalid limit price'
    if not arg6:
        revert with 0, 'invalid stop limit'
    if not arg4:
        revert with 0, 'amountA can't be zero.'
    if arg7 < block.timestamp:
        revert with 0, 17
    if arg7 - block.timestamp >= sub_fb60bfc1:
        revert with 0, 'expirydate error'
    if uint8(arg8) <= 0:
        revert with 0, 'leverage incorrect'
    if uint8(arg8) > maxLeverage:
        revert with 0, 'leverage incorrect'
    if sub_f1d18608 != msg.value:
        revert with 0, 'originFee incorrect'
    if not stor6[address(ext_call.return_data[0])]:
        revert with 0, 'whiteList error'
    mem[(2 * ceil32(return_data.size)) + 324] = address(arg2)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[(2 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and ext_call.return_data[0] > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) * ext_call.return_data[0] / 10^18 > sizeLimit:
        revert with 0, 'out of limit'
    if not uint8(stor1.field_160):
        revert with 0, 'nonReentrant: Warning re-entered!'
    uint8(stor1.field_160) = 0
    if platformFees[1] > !sub_f1d18608:
        revert with 0, 17
    platformFees[1] += sub_f1d18608
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if platformFees[address(ext_call.return_data[0])] > !(arg4 * uint8(arg8) * serviceFee / 10^18):
        revert with 0, 17
    platformFees[address(ext_call.return_data[0])] += arg4 * uint8(arg8) * serviceFee / 10^18
    uint8(stor1.field_160) = 1
    if uint8(arg8) < 1:
        revert with 0, 17
    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
        revert with 0, 17
    if uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < arg4:
        revert with 0, 'allowance error'
    if uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) < arg4 * uint8(uint8(arg8) - 1):
        revert with 0, 'allowance error'
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
        revert with 0, 17
    if stor7 == address(arg2):
        if stor7 == address(arg3):
            mem[(4 * ceil32(return_data.size)) + 324] = address(arg2)
            require ext_code.size(oracleAddress)
            staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(6 * ceil32(return_data.size)) + 324] = address(arg3)
            require ext_code.size(oracleAddress)
            staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if arg4 and uint8(arg8) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
                revert with 0, 17
            if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
                revert with 0, 17
            if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).factory() with:
                    gas gas_remaining wei
            mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(14 * ceil32(return_data.size)) + 320] = 132
                mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
                mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
                mem[(14 * ceil32(return_data.size)) + 616] = 0
                delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                     gas gas_remaining wei
                    args mem[(14 * ceil32(return_data.size)) + 488 len 128]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _17011 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                        revert with 0, 65
                    mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                    mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                    require arg3 + (32 * _17011) + 160 <= arg2 + 128
                    mem[(14 * ceil32(return_data.size)) + 516 len 32 * _17011] = mem[arg3 + 160 len 32 * _17011]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(address(ext_call.return_data[0]), 4)
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34921 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34922 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34924 = sha3(mem[_34922 + 32 len mem[_34922]])
                    if 1 > !sha3(mem[_34922 + 32 len mem[_34922]]):
                        revert with 0, 17
                    mem[_34921 + 148] = address(arg1)
                    mem[_34921 + 180] = arg4
                    mem[_34921 + 212] = address(ext_call.return_data[0])
                    mem[_34921 + 244] = address(ext_call.return_data[0])
                    mem[_34921 + 276] = _34924 + 1
                    mem[_34921 + 116] = 160
                    if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1), address(arg1));
                    mem[_34921 + 308] = address(arg1)
                    mem[_34921 + 340] = address(arg2)
                    mem[_34921 + 372] = address(ext_call.return_data[0])
                    mem[_34921 + 404] = address(ext_call.return_data[0])
                    mem[_34921 + 436] = arg4
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    mem[_34921 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                    mem[_34921 + 500] = arg5
                    mem[_34921 + 532] = arg6
                    mem[_34921 + 564] = arg7
                    mem[_34921 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_512) = address(ext_call.return_data[0])
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_768) = address(ext_call.return_data[0])
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_1280 = mem[_34921 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34924 + 1].field_2304) = 0
                    mem[_34921 + 664] = address(ext_call.return_data[0])
                    mem[_34921 + 696] = address(stor1.field_0)
                    mem[_34921 + 628] = 68
                    mem[_34921 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34921 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34921 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34921 + 728 len 28]
                    mem[_34921 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34921 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34921 + 732 len 64]
                    if return_data.size:
                        mem[_34921 + 728] = return_data.size
                        mem[_34921 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34921 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34921 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34921 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34921 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34921 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34921 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34921 + 760], mem[_34921 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34921 + 764] = address(ext_call.return_data[0])
                        mem[_34921 + 796] = address(stor1.field_0)
                        mem[_34921 + 728] = 68
                        mem[_34921 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34921 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34921 + 828 len 28]
                        mem[_34921 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34921 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34921 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34921 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34921 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34924 + 1)
                mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
                mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16940 = mem[(14 * ceil32(return_data.size)) + 516]
                require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
                require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
                _17012 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                require _16940 + (32 * _17012) + 64 <= return_data.size + 32
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _17012] = mem[(14 * ceil32(return_data.size)) + _16940 + 548 len 32 * _17012]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _17012:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34925 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34926 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34928 = sha3(mem[_34926 + 32 len mem[_34926]])
                if 1 > !sha3(mem[_34926 + 32 len mem[_34926]]):
                    revert with 0, 17
                mem[_34925 + 148] = address(arg1)
                mem[_34925 + 180] = arg4
                mem[_34925 + 212] = address(ext_call.return_data[0])
                mem[_34925 + 244] = address(ext_call.return_data[0])
                mem[_34925 + 276] = _34928 + 1
                mem[_34925 + 116] = 160
                if 0 >= _17012:
                    revert with 0, 50
                if 1 >= _17012:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1), address(arg1));
                mem[_34925 + 308] = address(arg1)
                mem[_34925 + 340] = address(arg2)
                mem[_34925 + 372] = address(ext_call.return_data[0])
                mem[_34925 + 404] = address(ext_call.return_data[0])
                mem[_34925 + 436] = arg4
                if 1 >= _17012:
                    revert with 0, 50
                mem[_34925 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                mem[_34925 + 500] = arg5
                mem[_34925 + 532] = arg6
                mem[_34925 + 564] = arg7
                mem[_34925 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_1280 = mem[_34925 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34928 + 1].field_2304) = 0
                mem[_34925 + 664] = address(ext_call.return_data[0])
                mem[_34925 + 696] = address(stor1.field_0)
                mem[_34925 + 628] = 68
                mem[_34925 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34925 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34925 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34925 + 728 len 28]
                mem[_34925 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34925 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34925 + 732 len 64]
                if return_data.size:
                    mem[_34925 + 728] = return_data.size
                    mem[_34925 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34925 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34925 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34925 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34925 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34925 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34925 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34925 + 760], mem[_34925 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34925 + 764] = address(ext_call.return_data[0])
                    mem[_34925 + 796] = address(stor1.field_0)
                    mem[_34925 + 728] = 68
                    mem[_34925 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34925 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34925 + 828 len 28]
                    mem[_34925 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34925 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34925 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34925 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34925 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34928 + 1)
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 132
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
            mem[(14 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _17015 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _17015) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 516 len 32 * _17015] = mem[arg3 + 160 len 32 * _17015]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34937 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34938 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34940 = sha3(mem[_34938 + 32 len mem[_34938]])
                if 1 > !sha3(mem[_34938 + 32 len mem[_34938]]):
                    revert with 0, 17
                mem[_34937 + 148] = address(arg1)
                mem[_34937 + 180] = arg4
                mem[_34937 + 212] = address(ext_call.return_data[0])
                mem[_34937 + 244] = address(ext_call.return_data[0])
                mem[_34937 + 276] = _34940 + 1
                mem[_34937 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1), address(arg1));
                mem[_34937 + 308] = address(arg1)
                mem[_34937 + 340] = address(arg2)
                mem[_34937 + 372] = address(ext_call.return_data[0])
                mem[_34937 + 404] = address(ext_call.return_data[0])
                mem[_34937 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34937 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                mem[_34937 + 500] = arg5
                mem[_34937 + 532] = arg6
                mem[_34937 + 564] = arg7
                mem[_34937 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_1280 = mem[_34937 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34940 + 1].field_2304) = 0
                mem[_34937 + 664] = address(ext_call.return_data[0])
                mem[_34937 + 696] = address(stor1.field_0)
                mem[_34937 + 628] = 68
                mem[_34937 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34937 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34937 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34937 + 728 len 28]
                mem[_34937 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34937 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34937 + 732 len 64]
                if return_data.size:
                    mem[_34937 + 728] = return_data.size
                    mem[_34937 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34937 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34937 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34937 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34937 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34937 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34937 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34937 + 760], mem[_34937 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34937 + 764] = address(ext_call.return_data[0])
                    mem[_34937 + 796] = address(stor1.field_0)
                    mem[_34937 + 728] = 68
                    mem[_34937 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34937 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34937 + 828 len 28]
                    mem[_34937 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34937 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34937 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34937 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34937 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34940 + 1)
            mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16944 = mem[(14 * ceil32(return_data.size)) + 516]
            require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
            _17016 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            require _16944 + (32 * _17016) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _17016] = mem[(14 * ceil32(return_data.size)) + _16944 + 548 len 32 * _17016]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _17016:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34941 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34942 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34944 = sha3(mem[_34942 + 32 len mem[_34942]])
            if 1 > !sha3(mem[_34942 + 32 len mem[_34942]]):
                revert with 0, 17
            mem[_34941 + 148] = address(arg1)
            mem[_34941 + 180] = arg4
            mem[_34941 + 212] = address(ext_call.return_data[0])
            mem[_34941 + 244] = address(ext_call.return_data[0])
            mem[_34941 + 276] = _34944 + 1
            mem[_34941 + 116] = 160
            if 0 >= _17016:
                revert with 0, 50
            if 1 >= _17016:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1), address(arg1));
            mem[_34941 + 308] = address(arg1)
            mem[_34941 + 340] = address(arg2)
            mem[_34941 + 372] = address(ext_call.return_data[0])
            mem[_34941 + 404] = address(ext_call.return_data[0])
            mem[_34941 + 436] = arg4
            if 1 >= _17016:
                revert with 0, 50
            mem[_34941 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34941 + 500] = arg5
            mem[_34941 + 532] = arg6
            mem[_34941 + 564] = arg7
            mem[_34941 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_1280 = mem[_34941 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34944 + 1].field_2304) = 0
            mem[_34941 + 664] = address(ext_call.return_data[0])
            mem[_34941 + 696] = address(stor1.field_0)
            mem[_34941 + 628] = 68
            mem[_34941 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34941 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34941 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34941 + 728 len 28]
            mem[_34941 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34941 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34941 + 732 len 64]
            if return_data.size:
                mem[_34941 + 728] = return_data.size
                mem[_34941 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34941 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34941 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34941 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34941 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34941 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34941 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34941 + 760], mem[_34941 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34941 + 764] = address(ext_call.return_data[0])
                mem[_34941 + 796] = address(stor1.field_0)
                mem[_34941 + 728] = 68
                mem[_34941 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34941 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34941 + 828 len 28]
                mem[_34941 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34941 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34941 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34941 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34941 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34944 + 1)
        require ext_code.size(address(arg3))
        call address(arg3).underlying() with:
             gas gas_remaining wei
        mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(6 * ceil32(return_data.size)) + 324] = address(arg2)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(7 * ceil32(return_data.size)) + 324] = address(arg3)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg3)
        mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg4 and uint8(arg8) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
            revert with 0, 17
        if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
            revert with 0, 17
        if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).factory() with:
                gas gas_remaining wei
        mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != 1:
            mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(14 * ceil32(return_data.size)) + 320] = 132
                mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
                mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
                mem[(14 * ceil32(return_data.size)) + 616] = 0
                delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                     gas gas_remaining wei
                    args mem[(14 * ceil32(return_data.size)) + 488 len 128]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16995 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                        revert with 0, 65
                    mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                    mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                    require arg3 + (32 * _16995) + 160 <= arg2 + 128
                    mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16995] = mem[arg3 + 160 len 32 * _16995]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(address(ext_call.return_data[0]), 4)
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34857 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34858 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34860 = sha3(mem[_34858 + 32 len mem[_34858]])
                    if 1 > !sha3(mem[_34858 + 32 len mem[_34858]]):
                        revert with 0, 17
                    mem[_34857 + 148] = address(arg1)
                    mem[_34857 + 180] = arg4
                    mem[_34857 + 212] = address(ext_call.return_data[0])
                    mem[_34857 + 244] = address(ext_call.return_data[0])
                    mem[_34857 + 276] = _34860 + 1
                    mem[_34857 + 116] = 160
                    if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1), address(arg1));
                    mem[_34857 + 308] = address(arg1)
                    mem[_34857 + 340] = address(arg2)
                    mem[_34857 + 372] = address(ext_call.return_data[0])
                    mem[_34857 + 404] = address(ext_call.return_data[0])
                    mem[_34857 + 436] = arg4
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    mem[_34857 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                    mem[_34857 + 500] = arg5
                    mem[_34857 + 532] = arg6
                    mem[_34857 + 564] = arg7
                    mem[_34857 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_512) = address(ext_call.return_data[0])
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_768) = address(ext_call.return_data[0])
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_1280 = mem[_34857 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34860 + 1].field_2304) = 0
                    mem[_34857 + 664] = address(ext_call.return_data[0])
                    mem[_34857 + 696] = address(stor1.field_0)
                    mem[_34857 + 628] = 68
                    mem[_34857 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34857 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34857 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34857 + 728 len 28]
                    mem[_34857 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34857 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34857 + 732 len 64]
                    if return_data.size:
                        mem[_34857 + 728] = return_data.size
                        mem[_34857 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34857 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34857 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34857 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34857 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34857 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34857 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34857 + 760], mem[_34857 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34857 + 764] = address(ext_call.return_data[0])
                        mem[_34857 + 796] = address(stor1.field_0)
                        mem[_34857 + 728] = 68
                        mem[_34857 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34857 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34857 + 828 len 28]
                        mem[_34857 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34857 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34857 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34857 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34857 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34860 + 1)
                mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
                mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16924 = mem[(14 * ceil32(return_data.size)) + 516]
                require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
                require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
                _16996 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                require _16924 + (32 * _16996) + 64 <= return_data.size + 32
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16996] = mem[(14 * ceil32(return_data.size)) + _16924 + 548 len 32 * _16996]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16996:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34861 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34862 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34864 = sha3(mem[_34862 + 32 len mem[_34862]])
                if 1 > !sha3(mem[_34862 + 32 len mem[_34862]]):
                    revert with 0, 17
                mem[_34861 + 148] = address(arg1)
                mem[_34861 + 180] = arg4
                mem[_34861 + 212] = address(ext_call.return_data[0])
                mem[_34861 + 244] = address(ext_call.return_data[0])
                mem[_34861 + 276] = _34864 + 1
                mem[_34861 + 116] = 160
                if 0 >= _16996:
                    revert with 0, 50
                if 1 >= _16996:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1), address(arg1));
                mem[_34861 + 308] = address(arg1)
                mem[_34861 + 340] = address(arg2)
                mem[_34861 + 372] = address(ext_call.return_data[0])
                mem[_34861 + 404] = address(ext_call.return_data[0])
                mem[_34861 + 436] = arg4
                if 1 >= _16996:
                    revert with 0, 50
                mem[_34861 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                mem[_34861 + 500] = arg5
                mem[_34861 + 532] = arg6
                mem[_34861 + 564] = arg7
                mem[_34861 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_1280 = mem[_34861 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34864 + 1].field_2304) = 0
                mem[_34861 + 664] = address(ext_call.return_data[0])
                mem[_34861 + 696] = address(stor1.field_0)
                mem[_34861 + 628] = 68
                mem[_34861 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34861 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34861 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34861 + 728 len 28]
                mem[_34861 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34861 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34861 + 732 len 64]
                if return_data.size:
                    mem[_34861 + 728] = return_data.size
                    mem[_34861 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34861 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34861 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34861 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34861 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34861 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34861 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34861 + 760], mem[_34861 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34861 + 764] = address(ext_call.return_data[0])
                    mem[_34861 + 796] = address(stor1.field_0)
                    mem[_34861 + 728] = 68
                    mem[_34861 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34861 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34861 + 828 len 28]
                    mem[_34861 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34861 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34861 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34861 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34861 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34864 + 1)
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 132
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
            mem[(14 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16999 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16999) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16999] = mem[arg3 + 160 len 32 * _16999]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34873 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34874 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34876 = sha3(mem[_34874 + 32 len mem[_34874]])
                if 1 > !sha3(mem[_34874 + 32 len mem[_34874]]):
                    revert with 0, 17
                mem[_34873 + 148] = address(arg1)
                mem[_34873 + 180] = arg4
                mem[_34873 + 212] = address(ext_call.return_data[0])
                mem[_34873 + 244] = address(ext_call.return_data[0])
                mem[_34873 + 276] = _34876 + 1
                mem[_34873 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1), address(arg1));
                mem[_34873 + 308] = address(arg1)
                mem[_34873 + 340] = address(arg2)
                mem[_34873 + 372] = address(ext_call.return_data[0])
                mem[_34873 + 404] = address(ext_call.return_data[0])
                mem[_34873 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34873 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                mem[_34873 + 500] = arg5
                mem[_34873 + 532] = arg6
                mem[_34873 + 564] = arg7
                mem[_34873 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_1280 = mem[_34873 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34876 + 1].field_2304) = 0
                mem[_34873 + 664] = address(ext_call.return_data[0])
                mem[_34873 + 696] = address(stor1.field_0)
                mem[_34873 + 628] = 68
                mem[_34873 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34873 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34873 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34873 + 728 len 28]
                mem[_34873 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34873 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34873 + 732 len 64]
                if return_data.size:
                    mem[_34873 + 728] = return_data.size
                    mem[_34873 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34873 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34873 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34873 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34873 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34873 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34873 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34873 + 760], mem[_34873 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34873 + 764] = address(ext_call.return_data[0])
                    mem[_34873 + 796] = address(stor1.field_0)
                    mem[_34873 + 728] = 68
                    mem[_34873 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34873 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34873 + 828 len 28]
                    mem[_34873 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34873 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34873 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34873 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34873 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34876 + 1)
            mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16928 = mem[(14 * ceil32(return_data.size)) + 516]
            require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
            _17000 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            require _16928 + (32 * _17000) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _17000] = mem[(14 * ceil32(return_data.size)) + _16928 + 548 len 32 * _17000]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _17000:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34877 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34878 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34880 = sha3(mem[_34878 + 32 len mem[_34878]])
            if 1 > !sha3(mem[_34878 + 32 len mem[_34878]]):
                revert with 0, 17
            mem[_34877 + 148] = address(arg1)
            mem[_34877 + 180] = arg4
            mem[_34877 + 212] = address(ext_call.return_data[0])
            mem[_34877 + 244] = address(ext_call.return_data[0])
            mem[_34877 + 276] = _34880 + 1
            mem[_34877 + 116] = 160
            if 0 >= _17000:
                revert with 0, 50
            if 1 >= _17000:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1), address(arg1));
            mem[_34877 + 308] = address(arg1)
            mem[_34877 + 340] = address(arg2)
            mem[_34877 + 372] = address(ext_call.return_data[0])
            mem[_34877 + 404] = address(ext_call.return_data[0])
            mem[_34877 + 436] = arg4
            if 1 >= _17000:
                revert with 0, 50
            mem[_34877 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34877 + 500] = arg5
            mem[_34877 + 532] = arg6
            mem[_34877 + 564] = arg7
            mem[_34877 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_1280 = mem[_34877 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34880 + 1].field_2304) = 0
            mem[_34877 + 664] = address(ext_call.return_data[0])
            mem[_34877 + 696] = address(stor1.field_0)
            mem[_34877 + 628] = 68
            mem[_34877 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34877 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34877 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34877 + 728 len 28]
            mem[_34877 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34877 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34877 + 732 len 64]
            if return_data.size:
                mem[_34877 + 728] = return_data.size
                mem[_34877 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34877 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34877 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34877 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34877 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34877 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34877 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34877 + 760], mem[_34877 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34877 + 764] = address(ext_call.return_data[0])
                mem[_34877 + 796] = address(stor1.field_0)
                mem[_34877 + 728] = 68
                mem[_34877 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34877 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34877 + 828 len 28]
                mem[_34877 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34877 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34877 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34877 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34877 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34880 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(12 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(13 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(14 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(15 * ceil32(return_data.size)) + 320] = 132
            mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
            mem[(15 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(15 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _17003 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _17003) + 160 <= arg2 + 128
                mem[(15 * ceil32(return_data.size)) + 516 len 32 * _17003] = mem[arg3 + 160 len 32 * _17003]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34889 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34890 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34892 = sha3(mem[_34890 + 32 len mem[_34890]])
                if 1 > !sha3(mem[_34890 + 32 len mem[_34890]]):
                    revert with 0, 17
                mem[_34889 + 148] = address(arg1)
                mem[_34889 + 180] = arg4
                mem[_34889 + 212] = address(ext_call.return_data[0])
                mem[_34889 + 244] = address(ext_call.return_data[0])
                mem[_34889 + 276] = _34892 + 1
                mem[_34889 + 116] = 160
                if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1), address(arg1));
                mem[_34889 + 308] = address(arg1)
                mem[_34889 + 340] = address(arg2)
                mem[_34889 + 372] = address(ext_call.return_data[0])
                mem[_34889 + 404] = address(ext_call.return_data[0])
                mem[_34889 + 436] = arg4
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34889 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
                mem[_34889 + 500] = arg5
                mem[_34889 + 532] = arg6
                mem[_34889 + 564] = arg7
                mem[_34889 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_1280 = mem[_34889 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34892 + 1].field_2304) = 0
                mem[_34889 + 664] = address(ext_call.return_data[0])
                mem[_34889 + 696] = address(stor1.field_0)
                mem[_34889 + 628] = 68
                mem[_34889 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34889 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34889 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34889 + 728 len 28]
                mem[_34889 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34889 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34889 + 732 len 64]
                if return_data.size:
                    mem[_34889 + 728] = return_data.size
                    mem[_34889 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34889 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34889 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34889 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34889 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34889 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34889 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34889 + 760], mem[_34889 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34889 + 764] = address(ext_call.return_data[0])
                    mem[_34889 + 796] = address(stor1.field_0)
                    mem[_34889 + 728] = 68
                    mem[_34889 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34889 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34889 + 828 len 28]
                    mem[_34889 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34889 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34889 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34889 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34889 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34892 + 1)
            mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16932 = mem[(15 * ceil32(return_data.size)) + 516]
            require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
            require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
            _17004 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            require _16932 + (32 * _17004) + 64 <= return_data.size + 32
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _17004] = mem[(15 * ceil32(return_data.size)) + _16932 + 548 len 32 * _17004]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _17004:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34893 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34894 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34896 = sha3(mem[_34894 + 32 len mem[_34894]])
            if 1 > !sha3(mem[_34894 + 32 len mem[_34894]]):
                revert with 0, 17
            mem[_34893 + 148] = address(arg1)
            mem[_34893 + 180] = arg4
            mem[_34893 + 212] = address(ext_call.return_data[0])
            mem[_34893 + 244] = address(ext_call.return_data[0])
            mem[_34893 + 276] = _34896 + 1
            mem[_34893 + 116] = 160
            if 0 >= _17004:
                revert with 0, 50
            if 1 >= _17004:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1), address(arg1));
            mem[_34893 + 308] = address(arg1)
            mem[_34893 + 340] = address(arg2)
            mem[_34893 + 372] = address(ext_call.return_data[0])
            mem[_34893 + 404] = address(ext_call.return_data[0])
            mem[_34893 + 436] = arg4
            if 1 >= _17004:
                revert with 0, 50
            mem[_34893 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34893 + 500] = arg5
            mem[_34893 + 532] = arg6
            mem[_34893 + 564] = arg7
            mem[_34893 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_1280 = mem[_34893 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34896 + 1].field_2304) = 0
            mem[_34893 + 664] = address(ext_call.return_data[0])
            mem[_34893 + 696] = address(stor1.field_0)
            mem[_34893 + 628] = 68
            mem[_34893 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34893 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34893 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34893 + 728 len 28]
            mem[_34893 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34893 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34893 + 732 len 64]
            if return_data.size:
                mem[_34893 + 728] = return_data.size
                mem[_34893 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34893 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34893 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34893 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34893 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34893 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34893 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34893 + 760], mem[_34893 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34893 + 764] = address(ext_call.return_data[0])
                mem[_34893 + 796] = address(stor1.field_0)
                mem[_34893 + 728] = 68
                mem[_34893 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34893 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34893 + 828 len 28]
                mem[_34893 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34893 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34893 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34893 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34893 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34896 + 1)
        mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(15 * ceil32(return_data.size)) + 320] = 132
        mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
        mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
        mem[(15 * ceil32(return_data.size)) + 616] = 0
        delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
             gas gas_remaining wei
            args mem[(15 * ceil32(return_data.size)) + 488 len 128]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _17007 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
            mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
            require arg3 + (32 * _17007) + 160 <= arg2 + 128
            mem[(15 * ceil32(return_data.size)) + 516 len 32 * _17007] = mem[arg3 + 160 len 32 * _17007]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34905 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34906 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34908 = sha3(mem[_34906 + 32 len mem[_34906]])
            if 1 > !sha3(mem[_34906 + 32 len mem[_34906]]):
                revert with 0, 17
            mem[_34905 + 148] = address(arg1)
            mem[_34905 + 180] = arg4
            mem[_34905 + 212] = address(ext_call.return_data[0])
            mem[_34905 + 244] = address(ext_call.return_data[0])
            mem[_34905 + 276] = _34908 + 1
            mem[_34905 + 116] = 160
            if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1), address(arg1));
            mem[_34905 + 308] = address(arg1)
            mem[_34905 + 340] = address(arg2)
            mem[_34905 + 372] = address(ext_call.return_data[0])
            mem[_34905 + 404] = address(ext_call.return_data[0])
            mem[_34905 + 436] = arg4
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            mem[_34905 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
            mem[_34905 + 500] = arg5
            mem[_34905 + 532] = arg6
            mem[_34905 + 564] = arg7
            mem[_34905 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_1280 = mem[_34905 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34908 + 1].field_2304) = 0
            mem[_34905 + 664] = address(ext_call.return_data[0])
            mem[_34905 + 696] = address(stor1.field_0)
            mem[_34905 + 628] = 68
            mem[_34905 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34905 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34905 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34905 + 728 len 28]
            mem[_34905 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34905 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34905 + 732 len 64]
            if return_data.size:
                mem[_34905 + 728] = return_data.size
                mem[_34905 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34905 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34905 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34905 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34905 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34905 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34905 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34905 + 760], mem[_34905 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34905 + 764] = address(ext_call.return_data[0])
                mem[_34905 + 796] = address(stor1.field_0)
                mem[_34905 + 728] = 68
                mem[_34905 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34905 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34905 + 828 len 28]
                mem[_34905 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34905 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34905 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34905 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34905 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34908 + 1)
        mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
        mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16936 = mem[(15 * ceil32(return_data.size)) + 516]
        require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
        require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
        _17008 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        require _16936 + (32 * _17008) + 64 <= return_data.size + 32
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _17008] = mem[(15 * ceil32(return_data.size)) + _16936 + 548 len 32 * _17008]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _17008:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34909 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34910 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34912 = sha3(mem[_34910 + 32 len mem[_34910]])
        if 1 > !sha3(mem[_34910 + 32 len mem[_34910]]):
            revert with 0, 17
        mem[_34909 + 148] = address(arg1)
        mem[_34909 + 180] = arg4
        mem[_34909 + 212] = address(ext_call.return_data[0])
        mem[_34909 + 244] = address(ext_call.return_data[0])
        mem[_34909 + 276] = _34912 + 1
        mem[_34909 + 116] = 160
        if 0 >= _17008:
            revert with 0, 50
        if 1 >= _17008:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1), address(arg1));
        mem[_34909 + 308] = address(arg1)
        mem[_34909 + 340] = address(arg2)
        mem[_34909 + 372] = address(ext_call.return_data[0])
        mem[_34909 + 404] = address(ext_call.return_data[0])
        mem[_34909 + 436] = arg4
        if 1 >= _17008:
            revert with 0, 50
        mem[_34909 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        mem[_34909 + 500] = arg5
        mem[_34909 + 532] = arg6
        mem[_34909 + 564] = arg7
        mem[_34909 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_1280 = mem[_34909 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34912 + 1].field_2304) = 0
        mem[_34909 + 664] = address(ext_call.return_data[0])
        mem[_34909 + 696] = address(stor1.field_0)
        mem[_34909 + 628] = 68
        mem[_34909 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34909 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34909 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34909 + 728 len 28]
        mem[_34909 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34909 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34909 + 732 len 64]
        if return_data.size:
            mem[_34909 + 728] = return_data.size
            mem[_34909 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34909 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34909 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34909 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34909 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34909 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34909 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34909 + 760], mem[_34909 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34909 + 764] = address(ext_call.return_data[0])
            mem[_34909 + 796] = address(stor1.field_0)
            mem[_34909 + 728] = 68
            mem[_34909 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34909 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34909 + 828 len 28]
            mem[_34909 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34909 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34909 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34909 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34909 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34912 + 1)
    require ext_code.size(address(arg2))
    call address(arg2).underlying() with:
         gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if stor7 == address(arg3):
        mem[(6 * ceil32(return_data.size)) + 324] = address(arg2)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(7 * ceil32(return_data.size)) + 324] = address(arg3)
        require ext_code.size(oracleAddress)
        staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
                gas gas_remaining wei
               args address(arg3)
        mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg4 and uint8(arg8) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
            revert with 0, 17
        if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
            revert with 0, 17
        if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).factory() with:
                gas gas_remaining wei
        mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != 1:
            mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(14 * ceil32(return_data.size)) + 320] = 132
                mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
                mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
                mem[(14 * ceil32(return_data.size)) + 616] = 0
                delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                     gas gas_remaining wei
                    args mem[(14 * ceil32(return_data.size)) + 488 len 128]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16979 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                        revert with 0, 65
                    mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                    mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                    require arg3 + (32 * _16979) + 160 <= arg2 + 128
                    mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16979] = mem[arg3 + 160 len 32 * _16979]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(address(ext_call.return_data[0]), 4)
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34793 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34794 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34796 = sha3(mem[_34794 + 32 len mem[_34794]])
                    if 1 > !sha3(mem[_34794 + 32 len mem[_34794]]):
                        revert with 0, 17
                    mem[_34793 + 148] = address(arg1)
                    mem[_34793 + 180] = arg4
                    mem[_34793 + 212] = address(ext_call.return_data[0])
                    mem[_34793 + 244] = address(ext_call.return_data[0])
                    mem[_34793 + 276] = _34796 + 1
                    mem[_34793 + 116] = 160
                    if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1), address(arg1));
                    mem[_34793 + 308] = address(arg1)
                    mem[_34793 + 340] = address(arg2)
                    mem[_34793 + 372] = address(ext_call.return_data[0])
                    mem[_34793 + 404] = address(ext_call.return_data[0])
                    mem[_34793 + 436] = arg4
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    mem[_34793 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                    mem[_34793 + 500] = arg5
                    mem[_34793 + 532] = arg6
                    mem[_34793 + 564] = arg7
                    mem[_34793 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_512) = address(ext_call.return_data[0])
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_768) = address(ext_call.return_data[0])
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_1280 = mem[_34793 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34796 + 1].field_2304) = 0
                    mem[_34793 + 664] = address(ext_call.return_data[0])
                    mem[_34793 + 696] = address(stor1.field_0)
                    mem[_34793 + 628] = 68
                    mem[_34793 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34793 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34793 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34793 + 728 len 28]
                    mem[_34793 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34793 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34793 + 732 len 64]
                    if return_data.size:
                        mem[_34793 + 728] = return_data.size
                        mem[_34793 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34793 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34793 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34793 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34793 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34793 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34793 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34793 + 760], mem[_34793 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34793 + 764] = address(ext_call.return_data[0])
                        mem[_34793 + 796] = address(stor1.field_0)
                        mem[_34793 + 728] = 68
                        mem[_34793 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34793 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34793 + 828 len 28]
                        mem[_34793 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34793 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34793 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34793 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34793 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34796 + 1)
                mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
                mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16908 = mem[(14 * ceil32(return_data.size)) + 516]
                require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
                require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
                _16980 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                require _16908 + (32 * _16980) + 64 <= return_data.size + 32
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16980] = mem[(14 * ceil32(return_data.size)) + _16908 + 548 len 32 * _16980]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16980:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34797 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34798 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34800 = sha3(mem[_34798 + 32 len mem[_34798]])
                if 1 > !sha3(mem[_34798 + 32 len mem[_34798]]):
                    revert with 0, 17
                mem[_34797 + 148] = address(arg1)
                mem[_34797 + 180] = arg4
                mem[_34797 + 212] = address(ext_call.return_data[0])
                mem[_34797 + 244] = address(ext_call.return_data[0])
                mem[_34797 + 276] = _34800 + 1
                mem[_34797 + 116] = 160
                if 0 >= _16980:
                    revert with 0, 50
                if 1 >= _16980:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1), address(arg1));
                mem[_34797 + 308] = address(arg1)
                mem[_34797 + 340] = address(arg2)
                mem[_34797 + 372] = address(ext_call.return_data[0])
                mem[_34797 + 404] = address(ext_call.return_data[0])
                mem[_34797 + 436] = arg4
                if 1 >= _16980:
                    revert with 0, 50
                mem[_34797 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                mem[_34797 + 500] = arg5
                mem[_34797 + 532] = arg6
                mem[_34797 + 564] = arg7
                mem[_34797 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_1280 = mem[_34797 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34800 + 1].field_2304) = 0
                mem[_34797 + 664] = address(ext_call.return_data[0])
                mem[_34797 + 696] = address(stor1.field_0)
                mem[_34797 + 628] = 68
                mem[_34797 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34797 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34797 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34797 + 728 len 28]
                mem[_34797 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34797 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34797 + 732 len 64]
                if return_data.size:
                    mem[_34797 + 728] = return_data.size
                    mem[_34797 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34797 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34797 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34797 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34797 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34797 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34797 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34797 + 760], mem[_34797 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34797 + 764] = address(ext_call.return_data[0])
                    mem[_34797 + 796] = address(stor1.field_0)
                    mem[_34797 + 728] = 68
                    mem[_34797 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34797 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34797 + 828 len 28]
                    mem[_34797 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34797 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34797 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34797 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34797 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34800 + 1)
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 132
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
            mem[(14 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16983 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16983) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16983] = mem[arg3 + 160 len 32 * _16983]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34809 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34810 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34812 = sha3(mem[_34810 + 32 len mem[_34810]])
                if 1 > !sha3(mem[_34810 + 32 len mem[_34810]]):
                    revert with 0, 17
                mem[_34809 + 148] = address(arg1)
                mem[_34809 + 180] = arg4
                mem[_34809 + 212] = address(ext_call.return_data[0])
                mem[_34809 + 244] = address(ext_call.return_data[0])
                mem[_34809 + 276] = _34812 + 1
                mem[_34809 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1), address(arg1));
                mem[_34809 + 308] = address(arg1)
                mem[_34809 + 340] = address(arg2)
                mem[_34809 + 372] = address(ext_call.return_data[0])
                mem[_34809 + 404] = address(ext_call.return_data[0])
                mem[_34809 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34809 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                mem[_34809 + 500] = arg5
                mem[_34809 + 532] = arg6
                mem[_34809 + 564] = arg7
                mem[_34809 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_1280 = mem[_34809 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34812 + 1].field_2304) = 0
                mem[_34809 + 664] = address(ext_call.return_data[0])
                mem[_34809 + 696] = address(stor1.field_0)
                mem[_34809 + 628] = 68
                mem[_34809 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34809 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34809 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34809 + 728 len 28]
                mem[_34809 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34809 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34809 + 732 len 64]
                if return_data.size:
                    mem[_34809 + 728] = return_data.size
                    mem[_34809 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34809 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34809 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34809 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34809 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34809 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34809 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34809 + 760], mem[_34809 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34809 + 764] = address(ext_call.return_data[0])
                    mem[_34809 + 796] = address(stor1.field_0)
                    mem[_34809 + 728] = 68
                    mem[_34809 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34809 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34809 + 828 len 28]
                    mem[_34809 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34809 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34809 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34809 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34809 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34812 + 1)
            mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16912 = mem[(14 * ceil32(return_data.size)) + 516]
            require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
            _16984 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            require _16912 + (32 * _16984) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16984] = mem[(14 * ceil32(return_data.size)) + _16912 + 548 len 32 * _16984]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16984:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34813 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34814 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34816 = sha3(mem[_34814 + 32 len mem[_34814]])
            if 1 > !sha3(mem[_34814 + 32 len mem[_34814]]):
                revert with 0, 17
            mem[_34813 + 148] = address(arg1)
            mem[_34813 + 180] = arg4
            mem[_34813 + 212] = address(ext_call.return_data[0])
            mem[_34813 + 244] = address(ext_call.return_data[0])
            mem[_34813 + 276] = _34816 + 1
            mem[_34813 + 116] = 160
            if 0 >= _16984:
                revert with 0, 50
            if 1 >= _16984:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1), address(arg1));
            mem[_34813 + 308] = address(arg1)
            mem[_34813 + 340] = address(arg2)
            mem[_34813 + 372] = address(ext_call.return_data[0])
            mem[_34813 + 404] = address(ext_call.return_data[0])
            mem[_34813 + 436] = arg4
            if 1 >= _16984:
                revert with 0, 50
            mem[_34813 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34813 + 500] = arg5
            mem[_34813 + 532] = arg6
            mem[_34813 + 564] = arg7
            mem[_34813 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_1280 = mem[_34813 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34816 + 1].field_2304) = 0
            mem[_34813 + 664] = address(ext_call.return_data[0])
            mem[_34813 + 696] = address(stor1.field_0)
            mem[_34813 + 628] = 68
            mem[_34813 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34813 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34813 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34813 + 728 len 28]
            mem[_34813 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34813 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34813 + 732 len 64]
            if return_data.size:
                mem[_34813 + 728] = return_data.size
                mem[_34813 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34813 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34813 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34813 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34813 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34813 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34813 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34813 + 760], mem[_34813 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34813 + 764] = address(ext_call.return_data[0])
                mem[_34813 + 796] = address(stor1.field_0)
                mem[_34813 + 728] = 68
                mem[_34813 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34813 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34813 + 828 len 28]
                mem[_34813 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34813 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34813 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34813 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34813 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34816 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(12 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(13 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(14 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(15 * ceil32(return_data.size)) + 320] = 132
            mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
            mem[(15 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(15 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16987 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16987) + 160 <= arg2 + 128
                mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16987] = mem[arg3 + 160 len 32 * _16987]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34825 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34826 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34828 = sha3(mem[_34826 + 32 len mem[_34826]])
                if 1 > !sha3(mem[_34826 + 32 len mem[_34826]]):
                    revert with 0, 17
                mem[_34825 + 148] = address(arg1)
                mem[_34825 + 180] = arg4
                mem[_34825 + 212] = address(ext_call.return_data[0])
                mem[_34825 + 244] = address(ext_call.return_data[0])
                mem[_34825 + 276] = _34828 + 1
                mem[_34825 + 116] = 160
                if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1), address(arg1));
                mem[_34825 + 308] = address(arg1)
                mem[_34825 + 340] = address(arg2)
                mem[_34825 + 372] = address(ext_call.return_data[0])
                mem[_34825 + 404] = address(ext_call.return_data[0])
                mem[_34825 + 436] = arg4
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34825 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
                mem[_34825 + 500] = arg5
                mem[_34825 + 532] = arg6
                mem[_34825 + 564] = arg7
                mem[_34825 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_1280 = mem[_34825 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34828 + 1].field_2304) = 0
                mem[_34825 + 664] = address(ext_call.return_data[0])
                mem[_34825 + 696] = address(stor1.field_0)
                mem[_34825 + 628] = 68
                mem[_34825 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34825 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34825 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34825 + 728 len 28]
                mem[_34825 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34825 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34825 + 732 len 64]
                if return_data.size:
                    mem[_34825 + 728] = return_data.size
                    mem[_34825 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34825 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34825 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34825 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34825 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34825 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34825 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34825 + 760], mem[_34825 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34825 + 764] = address(ext_call.return_data[0])
                    mem[_34825 + 796] = address(stor1.field_0)
                    mem[_34825 + 728] = 68
                    mem[_34825 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34825 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34825 + 828 len 28]
                    mem[_34825 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34825 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34825 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34825 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34825 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34828 + 1)
            mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16916 = mem[(15 * ceil32(return_data.size)) + 516]
            require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
            require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
            _16988 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            require _16916 + (32 * _16988) + 64 <= return_data.size + 32
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16988] = mem[(15 * ceil32(return_data.size)) + _16916 + 548 len 32 * _16988]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16988:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34829 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34830 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34832 = sha3(mem[_34830 + 32 len mem[_34830]])
            if 1 > !sha3(mem[_34830 + 32 len mem[_34830]]):
                revert with 0, 17
            mem[_34829 + 148] = address(arg1)
            mem[_34829 + 180] = arg4
            mem[_34829 + 212] = address(ext_call.return_data[0])
            mem[_34829 + 244] = address(ext_call.return_data[0])
            mem[_34829 + 276] = _34832 + 1
            mem[_34829 + 116] = 160
            if 0 >= _16988:
                revert with 0, 50
            if 1 >= _16988:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1), address(arg1));
            mem[_34829 + 308] = address(arg1)
            mem[_34829 + 340] = address(arg2)
            mem[_34829 + 372] = address(ext_call.return_data[0])
            mem[_34829 + 404] = address(ext_call.return_data[0])
            mem[_34829 + 436] = arg4
            if 1 >= _16988:
                revert with 0, 50
            mem[_34829 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34829 + 500] = arg5
            mem[_34829 + 532] = arg6
            mem[_34829 + 564] = arg7
            mem[_34829 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_1280 = mem[_34829 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34832 + 1].field_2304) = 0
            mem[_34829 + 664] = address(ext_call.return_data[0])
            mem[_34829 + 696] = address(stor1.field_0)
            mem[_34829 + 628] = 68
            mem[_34829 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34829 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34829 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34829 + 728 len 28]
            mem[_34829 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34829 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34829 + 732 len 64]
            if return_data.size:
                mem[_34829 + 728] = return_data.size
                mem[_34829 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34829 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34829 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34829 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34829 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34829 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34829 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34829 + 760], mem[_34829 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34829 + 764] = address(ext_call.return_data[0])
                mem[_34829 + 796] = address(stor1.field_0)
                mem[_34829 + 728] = 68
                mem[_34829 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34829 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34829 + 828 len 28]
                mem[_34829 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34829 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34829 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34829 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34829 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34832 + 1)
        mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(15 * ceil32(return_data.size)) + 320] = 132
        mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
        mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
        mem[(15 * ceil32(return_data.size)) + 616] = 0
        delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
             gas gas_remaining wei
            args mem[(15 * ceil32(return_data.size)) + 488 len 128]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16991 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
            mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
            require arg3 + (32 * _16991) + 160 <= arg2 + 128
            mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16991] = mem[arg3 + 160 len 32 * _16991]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34841 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34842 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34844 = sha3(mem[_34842 + 32 len mem[_34842]])
            if 1 > !sha3(mem[_34842 + 32 len mem[_34842]]):
                revert with 0, 17
            mem[_34841 + 148] = address(arg1)
            mem[_34841 + 180] = arg4
            mem[_34841 + 212] = address(ext_call.return_data[0])
            mem[_34841 + 244] = address(ext_call.return_data[0])
            mem[_34841 + 276] = _34844 + 1
            mem[_34841 + 116] = 160
            if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1), address(arg1));
            mem[_34841 + 308] = address(arg1)
            mem[_34841 + 340] = address(arg2)
            mem[_34841 + 372] = address(ext_call.return_data[0])
            mem[_34841 + 404] = address(ext_call.return_data[0])
            mem[_34841 + 436] = arg4
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            mem[_34841 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
            mem[_34841 + 500] = arg5
            mem[_34841 + 532] = arg6
            mem[_34841 + 564] = arg7
            mem[_34841 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_1280 = mem[_34841 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34844 + 1].field_2304) = 0
            mem[_34841 + 664] = address(ext_call.return_data[0])
            mem[_34841 + 696] = address(stor1.field_0)
            mem[_34841 + 628] = 68
            mem[_34841 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34841 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34841 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34841 + 728 len 28]
            mem[_34841 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34841 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34841 + 732 len 64]
            if return_data.size:
                mem[_34841 + 728] = return_data.size
                mem[_34841 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34841 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34841 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34841 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34841 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34841 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34841 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34841 + 760], mem[_34841 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34841 + 764] = address(ext_call.return_data[0])
                mem[_34841 + 796] = address(stor1.field_0)
                mem[_34841 + 728] = 68
                mem[_34841 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34841 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34841 + 828 len 28]
                mem[_34841 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34841 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34841 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34841 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34841 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34844 + 1)
        mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
        mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16920 = mem[(15 * ceil32(return_data.size)) + 516]
        require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
        require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
        _16992 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        require _16920 + (32 * _16992) + 64 <= return_data.size + 32
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16992] = mem[(15 * ceil32(return_data.size)) + _16920 + 548 len 32 * _16992]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16992:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34845 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34846 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34848 = sha3(mem[_34846 + 32 len mem[_34846]])
        if 1 > !sha3(mem[_34846 + 32 len mem[_34846]]):
            revert with 0, 17
        mem[_34845 + 148] = address(arg1)
        mem[_34845 + 180] = arg4
        mem[_34845 + 212] = address(ext_call.return_data[0])
        mem[_34845 + 244] = address(ext_call.return_data[0])
        mem[_34845 + 276] = _34848 + 1
        mem[_34845 + 116] = 160
        if 0 >= _16992:
            revert with 0, 50
        if 1 >= _16992:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1), address(arg1));
        mem[_34845 + 308] = address(arg1)
        mem[_34845 + 340] = address(arg2)
        mem[_34845 + 372] = address(ext_call.return_data[0])
        mem[_34845 + 404] = address(ext_call.return_data[0])
        mem[_34845 + 436] = arg4
        if 1 >= _16992:
            revert with 0, 50
        mem[_34845 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        mem[_34845 + 500] = arg5
        mem[_34845 + 532] = arg6
        mem[_34845 + 564] = arg7
        mem[_34845 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_1280 = mem[_34845 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34848 + 1].field_2304) = 0
        mem[_34845 + 664] = address(ext_call.return_data[0])
        mem[_34845 + 696] = address(stor1.field_0)
        mem[_34845 + 628] = 68
        mem[_34845 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34845 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34845 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34845 + 728 len 28]
        mem[_34845 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34845 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34845 + 732 len 64]
        if return_data.size:
            mem[_34845 + 728] = return_data.size
            mem[_34845 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34845 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34845 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34845 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34845 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34845 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34845 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34845 + 760], mem[_34845 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34845 + 764] = address(ext_call.return_data[0])
            mem[_34845 + 796] = address(stor1.field_0)
            mem[_34845 + 728] = 68
            mem[_34845 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34845 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34845 + 828 len 28]
            mem[_34845 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34845 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34845 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34845 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34845 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34848 + 1)
    require ext_code.size(address(arg3))
    call address(arg3).underlying() with:
         gas gas_remaining wei
    mem[(6 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(7 * ceil32(return_data.size)) + 324] = address(arg2)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[(7 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(8 * ceil32(return_data.size)) + 324] = address(arg3)
    require ext_code.size(oracleAddress)
    staticcall oracleAddress.getUnderlyingPrice(address rg1) with:
            gas gas_remaining wei
           args address(arg3)
    mem[(8 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 and uint8(arg8) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(arg8) and serviceFee > -1 / arg4 * uint8(arg8):
        revert with 0, 17
    if arg4 * uint8(arg8) < arg4 * uint8(arg8) * serviceFee / 10^18:
        revert with 0, 17
    if ext_call.return_data[0] and (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18) > -1 / ext_call.return_data[0]:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).factory() with:
            gas gas_remaining wei
    mem[(10 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != 1:
        if address(ext_call.return_data[0]) != 1:
            mem[(11 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), address(ext_call.return_data[0])
            mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'token pair error'
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).getReserves() with:
                    gas gas_remaining wei
            mem[(12 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            mem[(13 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
                mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
                mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
                require ext_code.size(address(routerAddress))
                staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
                mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'error PairPrice'
                if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                    revert with 0, 17
                if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                    revert with 0, 'price error'
                mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
                mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
                mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
                mem[(14 * ceil32(return_data.size)) + 320] = 132
                mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
                mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
                mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
                mem[(14 * ceil32(return_data.size)) + 616] = 0
                delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                     gas gas_remaining wei
                    args mem[(14 * ceil32(return_data.size)) + 488 len 128]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    require arg3 <= test266151307()
                    require arg2 + 128 > arg3 + 159
                    _16947 = mem[arg3 + 128]
                    if mem[arg3 + 128] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                        revert with 0, 65
                    mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                    mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                    require arg3 + (32 * _16947) + 160 <= arg2 + 128
                    mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16947] = mem[arg3 + 160 len 32 * _16947]
                    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'subBalance error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                    if uint8(arg8) < 1:
                        revert with 0, 17
                    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                        revert with 0, 17
                    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                        revert with 0, 'subLeverage error'
                    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                        revert with 0, 'addBalance error'
                    mem[0] = address(arg1)
                    mem[32] = sha3(address(ext_call.return_data[0]), 4)
                    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                    if stor10 == -1:
                        revert with 0, 17
                    stor10++
                    _34665 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = stor10
                    _34666 = mem[64]
                    mem[mem[64]] = 84
                    mem[64] = mem[64] + 116
                    _34668 = sha3(mem[_34666 + 32 len mem[_34666]])
                    if 1 > !sha3(mem[_34666 + 32 len mem[_34666]]):
                        revert with 0, 17
                    mem[_34665 + 148] = address(arg1)
                    mem[_34665 + 180] = arg4
                    mem[_34665 + 212] = address(ext_call.return_data[0])
                    mem[_34665 + 244] = address(ext_call.return_data[0])
                    mem[_34665 + 276] = _34668 + 1
                    mem[_34665 + 116] = 160
                    if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1), address(arg1));
                    mem[_34665 + 308] = address(arg1)
                    mem[_34665 + 340] = address(arg2)
                    mem[_34665 + 372] = address(ext_call.return_data[0])
                    mem[_34665 + 404] = address(ext_call.return_data[0])
                    mem[_34665 + 436] = arg4
                    if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                        revert with 0, 50
                    mem[_34665 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                    mem[_34665 + 500] = arg5
                    mem[_34665 + 532] = arg6
                    mem[_34665 + 564] = arg7
                    mem[_34665 + 596] = uint8(arg8)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_0) = address(arg1)
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_256) = uint64(arg2) << 96
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_512) = address(ext_call.return_data[0])
                    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_768) = address(ext_call.return_data[0])
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_1024 = arg4
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_1280 = mem[_34665 + 468]
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_1536 = arg5
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_1792 = arg6
                    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_2048 = arg7
                    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34668 + 1].field_2304) = 0
                    mem[_34665 + 664] = address(ext_call.return_data[0])
                    mem[_34665 + 696] = address(stor1.field_0)
                    mem[_34665 + 628] = 68
                    mem[_34665 + 664 len 28] = address(ext_call.return_data[0]) << 64
                    mem[_34665 + 660 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34665 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34665 + 728 len 28]
                    mem[_34665 + 796] = 0
                    delegate sub_0fc6a11cAddress.mem[_34665 + 728 len 4] with:
                         gas gas_remaining wei
                        args mem[_34665 + 732 len 64]
                    if return_data.size:
                        mem[_34665 + 728] = return_data.size
                        mem[_34665 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[_34665 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34665 + ceil32(return_data.size) + 829 len 28]
                        delegate sub_0fc6a11cAddress.mem[_34665 + ceil32(return_data.size) + 829 len 4] with:
                             gas gas_remaining wei
                            args mem[_34665 + ceil32(return_data.size) + 833 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34665 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34665 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34665 + 760], mem[_34665 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        mem[_34665 + 764] = address(ext_call.return_data[0])
                        mem[_34665 + 796] = address(stor1.field_0)
                        mem[_34665 + 728] = 68
                        mem[_34665 + 760 len 4] = getPairPrice(address rg1, address rg2)
                        mem[_34665 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34665 + 828 len 28]
                        mem[_34665 + 896] = 0
                        delegate sub_0fc6a11cAddress.mem[_34665 + 828 len 4] with:
                             gas gas_remaining wei
                            args mem[_34665 + 832 len 64]
                        if not return_data.size:
                            if not delegate.return_code:
                                revert with memory
                                  from 128
                                   len return_data.size
                            require arg2 >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1), address(arg1), address(ext_call.return_data[0])
                        else:
                            mem[_34665 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34665 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1), address(arg1), address(ext_call.return_data[0])
                    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34668 + 1)
                mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
                mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16876 = mem[(14 * ceil32(return_data.size)) + 516]
                require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
                require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
                _16948 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
                require _16876 + (32 * _16948) + 64 <= return_data.size + 32
                mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16948] = mem[(14 * ceil32(return_data.size)) + _16876 + 548 len 32 * _16948]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= _16948:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34669 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34670 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34672 = sha3(mem[_34670 + 32 len mem[_34670]])
                if 1 > !sha3(mem[_34670 + 32 len mem[_34670]]):
                    revert with 0, 17
                mem[_34669 + 148] = address(arg1)
                mem[_34669 + 180] = arg4
                mem[_34669 + 212] = address(ext_call.return_data[0])
                mem[_34669 + 244] = address(ext_call.return_data[0])
                mem[_34669 + 276] = _34672 + 1
                mem[_34669 + 116] = 160
                if 0 >= _16948:
                    revert with 0, 50
                if 1 >= _16948:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1), address(arg1));
                mem[_34669 + 308] = address(arg1)
                mem[_34669 + 340] = address(arg2)
                mem[_34669 + 372] = address(ext_call.return_data[0])
                mem[_34669 + 404] = address(ext_call.return_data[0])
                mem[_34669 + 436] = arg4
                if 1 >= _16948:
                    revert with 0, 50
                mem[_34669 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
                mem[_34669 + 500] = arg5
                mem[_34669 + 532] = arg6
                mem[_34669 + 564] = arg7
                mem[_34669 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_1280 = mem[_34669 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34672 + 1].field_2304) = 0
                mem[_34669 + 664] = address(ext_call.return_data[0])
                mem[_34669 + 696] = address(stor1.field_0)
                mem[_34669 + 628] = 68
                mem[_34669 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34669 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34669 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34669 + 728 len 28]
                mem[_34669 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34669 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34669 + 732 len 64]
                if return_data.size:
                    mem[_34669 + 728] = return_data.size
                    mem[_34669 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34669 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34669 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34669 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34669 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34669 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34669 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34669 + 760], mem[_34669 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34669 + 764] = address(ext_call.return_data[0])
                    mem[_34669 + 796] = address(stor1.field_0)
                    mem[_34669 + 728] = 68
                    mem[_34669 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34669 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34669 + 828 len 28]
                    mem[_34669 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34669 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34669 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34669 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34669 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34672 + 1)
            mem[(13 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
            mem[(13 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
            mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(14 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(14 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(14 * ceil32(return_data.size)) + 320] = 132
            mem[(14 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(14 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(14 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(14 * ceil32(return_data.size)) + 484 len 28]
            mem[(14 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(14 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(14 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16951 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (14 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(14 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16951) + 160 <= arg2 + 128
                mem[(14 * ceil32(return_data.size)) + 516 len 32 * _16951] = mem[arg3 + 160 len 32 * _16951]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(14 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34681 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34682 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34684 = sha3(mem[_34682 + 32 len mem[_34682]])
                if 1 > !sha3(mem[_34682 + 32 len mem[_34682]]):
                    revert with 0, 17
                mem[_34681 + 148] = address(arg1)
                mem[_34681 + 180] = arg4
                mem[_34681 + 212] = address(ext_call.return_data[0])
                mem[_34681 + 244] = address(ext_call.return_data[0])
                mem[_34681 + 276] = _34684 + 1
                mem[_34681 + 116] = 160
                if 0 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + 516], mem[(14 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1), address(arg1));
                mem[_34681 + 308] = address(arg1)
                mem[_34681 + 340] = address(arg2)
                mem[_34681 + 372] = address(ext_call.return_data[0])
                mem[_34681 + 404] = address(ext_call.return_data[0])
                mem[_34681 + 436] = arg4
                if 1 >= mem[(14 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34681 + 468] = mem[(14 * ceil32(return_data.size)) + 548]
                mem[_34681 + 500] = arg5
                mem[_34681 + 532] = arg6
                mem[_34681 + 564] = arg7
                mem[_34681 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_1280 = mem[_34681 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34684 + 1].field_2304) = 0
                mem[_34681 + 664] = address(ext_call.return_data[0])
                mem[_34681 + 696] = address(stor1.field_0)
                mem[_34681 + 628] = 68
                mem[_34681 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34681 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34681 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34681 + 728 len 28]
                mem[_34681 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34681 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34681 + 732 len 64]
                if return_data.size:
                    mem[_34681 + 728] = return_data.size
                    mem[_34681 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34681 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34681 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34681 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34681 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34681 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34681 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34681 + 760], mem[_34681 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34681 + 764] = address(ext_call.return_data[0])
                    mem[_34681 + 796] = address(stor1.field_0)
                    mem[_34681 + 728] = 68
                    mem[_34681 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34681 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34681 + 828 len 28]
                    mem[_34681 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34681 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34681 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34681 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34681 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34684 + 1)
            mem[(14 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(14 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16880 = mem[(14 * ceil32(return_data.size)) + 516]
            require mem[(14 * ceil32(return_data.size)) + 516] <= test266151307()
            require (14 * ceil32(return_data.size)) + return_data.size + 516 > (14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 547
            _16952 = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            if mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (14 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(14 * ceil32(return_data.size)) + mem[(14 * ceil32(return_data.size)) + 516] + 516]
            require _16880 + (32 * _16952) + 64 <= return_data.size + 32
            mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16952] = mem[(14 * ceil32(return_data.size)) + _16880 + 548 len 32 * _16952]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16952:
                revert with 0, 50
            if mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34685 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34686 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34688 = sha3(mem[_34686 + 32 len mem[_34686]])
            if 1 > !sha3(mem[_34686 + 32 len mem[_34686]]):
                revert with 0, 17
            mem[_34685 + 148] = address(arg1)
            mem[_34685 + 180] = arg4
            mem[_34685 + 212] = address(ext_call.return_data[0])
            mem[_34685 + 244] = address(ext_call.return_data[0])
            mem[_34685 + 276] = _34688 + 1
            mem[_34685 + 116] = 160
            if 0 >= _16952:
                revert with 0, 50
            if 1 >= _16952:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1), address(arg1));
            mem[_34685 + 308] = address(arg1)
            mem[_34685 + 340] = address(arg2)
            mem[_34685 + 372] = address(ext_call.return_data[0])
            mem[_34685 + 404] = address(ext_call.return_data[0])
            mem[_34685 + 436] = arg4
            if 1 >= _16952:
                revert with 0, 50
            mem[_34685 + 468] = mem[(14 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34685 + 500] = arg5
            mem[_34685 + 532] = arg6
            mem[_34685 + 564] = arg7
            mem[_34685 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_1280 = mem[_34685 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34688 + 1].field_2304) = 0
            mem[_34685 + 664] = address(ext_call.return_data[0])
            mem[_34685 + 696] = address(stor1.field_0)
            mem[_34685 + 628] = 68
            mem[_34685 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34685 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34685 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34685 + 728 len 28]
            mem[_34685 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34685 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34685 + 732 len 64]
            if return_data.size:
                mem[_34685 + 728] = return_data.size
                mem[_34685 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34685 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34685 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34685 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34685 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34685 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34685 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34685 + 760], mem[_34685 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34685 + 764] = address(ext_call.return_data[0])
                mem[_34685 + 796] = address(stor1.field_0)
                mem[_34685 + 728] = 68
                mem[_34685 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34685 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34685 + 828 len 28]
                mem[_34685 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34685 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34685 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34685 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34685 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34688 + 1)
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(12 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(13 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(14 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(15 * ceil32(return_data.size)) + 320] = 132
            mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
            mem[(15 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(15 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16955 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16955) + 160 <= arg2 + 128
                mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16955] = mem[arg3 + 160 len 32 * _16955]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34697 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34698 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34700 = sha3(mem[_34698 + 32 len mem[_34698]])
                if 1 > !sha3(mem[_34698 + 32 len mem[_34698]]):
                    revert with 0, 17
                mem[_34697 + 148] = address(arg1)
                mem[_34697 + 180] = arg4
                mem[_34697 + 212] = address(ext_call.return_data[0])
                mem[_34697 + 244] = address(ext_call.return_data[0])
                mem[_34697 + 276] = _34700 + 1
                mem[_34697 + 116] = 160
                if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1), address(arg1));
                mem[_34697 + 308] = address(arg1)
                mem[_34697 + 340] = address(arg2)
                mem[_34697 + 372] = address(ext_call.return_data[0])
                mem[_34697 + 404] = address(ext_call.return_data[0])
                mem[_34697 + 436] = arg4
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34697 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
                mem[_34697 + 500] = arg5
                mem[_34697 + 532] = arg6
                mem[_34697 + 564] = arg7
                mem[_34697 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_1280 = mem[_34697 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34700 + 1].field_2304) = 0
                mem[_34697 + 664] = address(ext_call.return_data[0])
                mem[_34697 + 696] = address(stor1.field_0)
                mem[_34697 + 628] = 68
                mem[_34697 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34697 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34697 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34697 + 728 len 28]
                mem[_34697 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34697 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34697 + 732 len 64]
                if return_data.size:
                    mem[_34697 + 728] = return_data.size
                    mem[_34697 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34697 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34697 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34697 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34697 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34697 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34697 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34697 + 760], mem[_34697 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34697 + 764] = address(ext_call.return_data[0])
                    mem[_34697 + 796] = address(stor1.field_0)
                    mem[_34697 + 728] = 68
                    mem[_34697 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34697 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34697 + 828 len 28]
                    mem[_34697 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34697 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34697 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34697 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34697 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34700 + 1)
            mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16884 = mem[(15 * ceil32(return_data.size)) + 516]
            require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
            require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
            _16956 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            require _16884 + (32 * _16956) + 64 <= return_data.size + 32
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16956] = mem[(15 * ceil32(return_data.size)) + _16884 + 548 len 32 * _16956]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16956:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34701 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34702 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34704 = sha3(mem[_34702 + 32 len mem[_34702]])
            if 1 > !sha3(mem[_34702 + 32 len mem[_34702]]):
                revert with 0, 17
            mem[_34701 + 148] = address(arg1)
            mem[_34701 + 180] = arg4
            mem[_34701 + 212] = address(ext_call.return_data[0])
            mem[_34701 + 244] = address(ext_call.return_data[0])
            mem[_34701 + 276] = _34704 + 1
            mem[_34701 + 116] = 160
            if 0 >= _16956:
                revert with 0, 50
            if 1 >= _16956:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1), address(arg1));
            mem[_34701 + 308] = address(arg1)
            mem[_34701 + 340] = address(arg2)
            mem[_34701 + 372] = address(ext_call.return_data[0])
            mem[_34701 + 404] = address(ext_call.return_data[0])
            mem[_34701 + 436] = arg4
            if 1 >= _16956:
                revert with 0, 50
            mem[_34701 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34701 + 500] = arg5
            mem[_34701 + 532] = arg6
            mem[_34701 + 564] = arg7
            mem[_34701 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_1280 = mem[_34701 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34704 + 1].field_2304) = 0
            mem[_34701 + 664] = address(ext_call.return_data[0])
            mem[_34701 + 696] = address(stor1.field_0)
            mem[_34701 + 628] = 68
            mem[_34701 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34701 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34701 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34701 + 728 len 28]
            mem[_34701 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34701 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34701 + 732 len 64]
            if return_data.size:
                mem[_34701 + 728] = return_data.size
                mem[_34701 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34701 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34701 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34701 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34701 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34701 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34701 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34701 + 760], mem[_34701 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34701 + 764] = address(ext_call.return_data[0])
                mem[_34701 + 796] = address(stor1.field_0)
                mem[_34701 + 728] = 68
                mem[_34701 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34701 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34701 + 828 len 28]
                mem[_34701 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34701 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34701 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34701 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34701 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34704 + 1)
        mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(15 * ceil32(return_data.size)) + 320] = 132
        mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
        mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
        mem[(15 * ceil32(return_data.size)) + 616] = 0
        delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
             gas gas_remaining wei
            args mem[(15 * ceil32(return_data.size)) + 488 len 128]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16959 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
            mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
            require arg3 + (32 * _16959) + 160 <= arg2 + 128
            mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16959] = mem[arg3 + 160 len 32 * _16959]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34713 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34714 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34716 = sha3(mem[_34714 + 32 len mem[_34714]])
            if 1 > !sha3(mem[_34714 + 32 len mem[_34714]]):
                revert with 0, 17
            mem[_34713 + 148] = address(arg1)
            mem[_34713 + 180] = arg4
            mem[_34713 + 212] = address(ext_call.return_data[0])
            mem[_34713 + 244] = address(ext_call.return_data[0])
            mem[_34713 + 276] = _34716 + 1
            mem[_34713 + 116] = 160
            if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1), address(arg1));
            mem[_34713 + 308] = address(arg1)
            mem[_34713 + 340] = address(arg2)
            mem[_34713 + 372] = address(ext_call.return_data[0])
            mem[_34713 + 404] = address(ext_call.return_data[0])
            mem[_34713 + 436] = arg4
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            mem[_34713 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
            mem[_34713 + 500] = arg5
            mem[_34713 + 532] = arg6
            mem[_34713 + 564] = arg7
            mem[_34713 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_1280 = mem[_34713 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34716 + 1].field_2304) = 0
            mem[_34713 + 664] = address(ext_call.return_data[0])
            mem[_34713 + 696] = address(stor1.field_0)
            mem[_34713 + 628] = 68
            mem[_34713 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34713 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34713 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34713 + 728 len 28]
            mem[_34713 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34713 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34713 + 732 len 64]
            if return_data.size:
                mem[_34713 + 728] = return_data.size
                mem[_34713 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34713 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34713 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34713 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34713 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34713 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34713 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34713 + 760], mem[_34713 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34713 + 764] = address(ext_call.return_data[0])
                mem[_34713 + 796] = address(stor1.field_0)
                mem[_34713 + 728] = 68
                mem[_34713 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34713 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34713 + 828 len 28]
                mem[_34713 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34713 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34713 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34713 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34713 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34716 + 1)
        mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
        mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16888 = mem[(15 * ceil32(return_data.size)) + 516]
        require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
        require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
        _16960 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        require _16888 + (32 * _16960) + 64 <= return_data.size + 32
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16960] = mem[(15 * ceil32(return_data.size)) + _16888 + 548 len 32 * _16960]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16960:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34717 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34718 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34720 = sha3(mem[_34718 + 32 len mem[_34718]])
        if 1 > !sha3(mem[_34718 + 32 len mem[_34718]]):
            revert with 0, 17
        mem[_34717 + 148] = address(arg1)
        mem[_34717 + 180] = arg4
        mem[_34717 + 212] = address(ext_call.return_data[0])
        mem[_34717 + 244] = address(ext_call.return_data[0])
        mem[_34717 + 276] = _34720 + 1
        mem[_34717 + 116] = 160
        if 0 >= _16960:
            revert with 0, 50
        if 1 >= _16960:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1), address(arg1));
        mem[_34717 + 308] = address(arg1)
        mem[_34717 + 340] = address(arg2)
        mem[_34717 + 372] = address(ext_call.return_data[0])
        mem[_34717 + 404] = address(ext_call.return_data[0])
        mem[_34717 + 436] = arg4
        if 1 >= _16960:
            revert with 0, 50
        mem[_34717 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        mem[_34717 + 500] = arg5
        mem[_34717 + 532] = arg6
        mem[_34717 + 564] = arg7
        mem[_34717 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_1280 = mem[_34717 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34720 + 1].field_2304) = 0
        mem[_34717 + 664] = address(ext_call.return_data[0])
        mem[_34717 + 696] = address(stor1.field_0)
        mem[_34717 + 628] = 68
        mem[_34717 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34717 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34717 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34717 + 728 len 28]
        mem[_34717 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34717 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34717 + 732 len 64]
        if return_data.size:
            mem[_34717 + 728] = return_data.size
            mem[_34717 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34717 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34717 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34717 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34717 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34717 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34717 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34717 + 760], mem[_34717 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34717 + 764] = address(ext_call.return_data[0])
            mem[_34717 + 796] = address(stor1.field_0)
            mem[_34717 + 728] = 68
            mem[_34717 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34717 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34717 + 828 len 28]
            mem[_34717 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34717 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34717 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34717 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34717 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34720 + 1)
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).WAVAX() with:
            gas gas_remaining wei
    mem[(11 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != 1:
        mem[(12 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args address(ext_call.return_data[0]), address(ext_call.return_data[0])
        mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'token pair error'
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).getReserves() with:
                gas gas_remaining wei
        mem[(13 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        mem[(14 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
            mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
            mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
            mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'error PairPrice'
            if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                revert with 0, 17
            if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
                revert with 0, 'price error'
            mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
            mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
            mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
            mem[(15 * ceil32(return_data.size)) + 320] = 132
            mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
            mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
            mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
            mem[(15 * ceil32(return_data.size)) + 616] = 0
            delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
                 gas gas_remaining wei
                args mem[(15 * ceil32(return_data.size)) + 488 len 128]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                require arg3 <= test266151307()
                require arg2 + 128 > arg3 + 159
                _16963 = mem[arg3 + 128]
                if mem[arg3 + 128] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                    revert with 0, 65
                mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
                mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
                require arg3 + (32 * _16963) + 160 <= arg2 + 128
                mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16963] = mem[arg3 + 160 len 32 * _16963]
                if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'subBalance error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
                if uint8(arg8) < 1:
                    revert with 0, 17
                if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                    revert with 0, 17
                if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                    revert with 0, 'subLeverage error'
                uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                    revert with 0, 'addBalance error'
                mem[0] = address(arg1)
                mem[32] = sha3(address(ext_call.return_data[0]), 4)
                uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
                if stor10 == -1:
                    revert with 0, 17
                stor10++
                _34729 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = stor10
                _34730 = mem[64]
                mem[mem[64]] = 84
                mem[64] = mem[64] + 116
                _34732 = sha3(mem[_34730 + 32 len mem[_34730]])
                if 1 > !sha3(mem[_34730 + 32 len mem[_34730]]):
                    revert with 0, 17
                mem[_34729 + 148] = address(arg1)
                mem[_34729 + 180] = arg4
                mem[_34729 + 212] = address(ext_call.return_data[0])
                mem[_34729 + 244] = address(ext_call.return_data[0])
                mem[_34729 + 276] = _34732 + 1
                mem[_34729 + 116] = 160
                if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1), address(arg1));
                mem[_34729 + 308] = address(arg1)
                mem[_34729 + 340] = address(arg2)
                mem[_34729 + 372] = address(ext_call.return_data[0])
                mem[_34729 + 404] = address(ext_call.return_data[0])
                mem[_34729 + 436] = arg4
                if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                    revert with 0, 50
                mem[_34729 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
                mem[_34729 + 500] = arg5
                mem[_34729 + 532] = arg6
                mem[_34729 + 564] = arg7
                mem[_34729 + 596] = uint8(arg8)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_0) = address(arg1)
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_256) = uint64(arg2) << 96
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_512) = address(ext_call.return_data[0])
                address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_768) = address(ext_call.return_data[0])
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_1024 = arg4
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_1280 = mem[_34729 + 468]
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_1536 = arg5
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_1792 = arg6
                stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_2048 = arg7
                uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34732 + 1].field_2304) = 0
                mem[_34729 + 664] = address(ext_call.return_data[0])
                mem[_34729 + 696] = address(stor1.field_0)
                mem[_34729 + 628] = 68
                mem[_34729 + 664 len 28] = address(ext_call.return_data[0]) << 64
                mem[_34729 + 660 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34729 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34729 + 728 len 28]
                mem[_34729 + 796] = 0
                delegate sub_0fc6a11cAddress.mem[_34729 + 728 len 4] with:
                     gas gas_remaining wei
                    args mem[_34729 + 732 len 64]
                if return_data.size:
                    mem[_34729 + 728] = return_data.size
                    mem[_34729 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[_34729 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34729 + ceil32(return_data.size) + 829 len 28]
                    delegate sub_0fc6a11cAddress.mem[_34729 + ceil32(return_data.size) + 829 len 4] with:
                         gas gas_remaining wei
                        args mem[_34729 + ceil32(return_data.size) + 833 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34729 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34729 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34729 + 760], mem[_34729 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    mem[_34729 + 764] = address(ext_call.return_data[0])
                    mem[_34729 + 796] = address(stor1.field_0)
                    mem[_34729 + 728] = 68
                    mem[_34729 + 760 len 4] = getPairPrice(address rg1, address rg2)
                    mem[_34729 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34729 + 828 len 28]
                    mem[_34729 + 896] = 0
                    delegate sub_0fc6a11cAddress.mem[_34729 + 828 len 4] with:
                         gas gas_remaining wei
                        args mem[_34729 + 832 len 64]
                    if not return_data.size:
                        if not delegate.return_code:
                            revert with memory
                              from 128
                               len return_data.size
                        require arg2 >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1), address(arg1), address(ext_call.return_data[0])
                    else:
                        mem[_34729 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34729 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1), address(arg1), address(ext_call.return_data[0])
                return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34732 + 1)
            mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
            mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _16892 = mem[(15 * ceil32(return_data.size)) + 516]
            require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
            require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
            _16964 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
            require _16892 + (32 * _16964) + 64 <= return_data.size + 32
            mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16964] = mem[(15 * ceil32(return_data.size)) + _16892 + 548 len 32 * _16964]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= _16964:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34733 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34734 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34736 = sha3(mem[_34734 + 32 len mem[_34734]])
            if 1 > !sha3(mem[_34734 + 32 len mem[_34734]]):
                revert with 0, 17
            mem[_34733 + 148] = address(arg1)
            mem[_34733 + 180] = arg4
            mem[_34733 + 212] = address(ext_call.return_data[0])
            mem[_34733 + 244] = address(ext_call.return_data[0])
            mem[_34733 + 276] = _34736 + 1
            mem[_34733 + 116] = 160
            if 0 >= _16964:
                revert with 0, 50
            if 1 >= _16964:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1), address(arg1));
            mem[_34733 + 308] = address(arg1)
            mem[_34733 + 340] = address(arg2)
            mem[_34733 + 372] = address(ext_call.return_data[0])
            mem[_34733 + 404] = address(ext_call.return_data[0])
            mem[_34733 + 436] = arg4
            if 1 >= _16964:
                revert with 0, 50
            mem[_34733 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
            mem[_34733 + 500] = arg5
            mem[_34733 + 532] = arg6
            mem[_34733 + 564] = arg7
            mem[_34733 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_1280 = mem[_34733 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34736 + 1].field_2304) = 0
            mem[_34733 + 664] = address(ext_call.return_data[0])
            mem[_34733 + 696] = address(stor1.field_0)
            mem[_34733 + 628] = 68
            mem[_34733 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34733 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34733 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34733 + 728 len 28]
            mem[_34733 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34733 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34733 + 732 len 64]
            if return_data.size:
                mem[_34733 + 728] = return_data.size
                mem[_34733 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34733 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34733 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34733 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34733 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34733 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34733 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34733 + 760], mem[_34733 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34733 + 764] = address(ext_call.return_data[0])
                mem[_34733 + 796] = address(stor1.field_0)
                mem[_34733 + 728] = 68
                mem[_34733 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34733 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34733 + 828 len 28]
                mem[_34733 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34733 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34733 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34733 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34733 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34736 + 1)
        mem[(14 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
        mem[(14 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(14 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(15 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(15 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(15 * ceil32(return_data.size)) + 320] = 132
        mem[(15 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(15 * ceil32(return_data.size)) + 352 len 4] = 3575617902
        mem[(15 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(15 * ceil32(return_data.size)) + 484 len 28]
        mem[(15 * ceil32(return_data.size)) + 616] = 0
        delegate sub_0fc6a11cAddress.mem[(15 * ceil32(return_data.size)) + 484 len 4] with:
             gas gas_remaining wei
            args mem[(15 * ceil32(return_data.size)) + 488 len 128]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16967 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                revert with 0, 65
            mem[64] = (15 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
            mem[(15 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
            require arg3 + (32 * _16967) + 160 <= arg2 + 128
            mem[(15 * ceil32(return_data.size)) + 516 len 32 * _16967] = mem[arg3 + 160 len 32 * _16967]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if mem[(15 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + 548]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34745 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34746 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34748 = sha3(mem[_34746 + 32 len mem[_34746]])
            if 1 > !sha3(mem[_34746 + 32 len mem[_34746]]):
                revert with 0, 17
            mem[_34745 + 148] = address(arg1)
            mem[_34745 + 180] = arg4
            mem[_34745 + 212] = address(ext_call.return_data[0])
            mem[_34745 + 244] = address(ext_call.return_data[0])
            mem[_34745 + 276] = _34748 + 1
            mem[_34745 + 116] = 160
            if 0 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + 516], mem[(15 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1), address(arg1));
            mem[_34745 + 308] = address(arg1)
            mem[_34745 + 340] = address(arg2)
            mem[_34745 + 372] = address(ext_call.return_data[0])
            mem[_34745 + 404] = address(ext_call.return_data[0])
            mem[_34745 + 436] = arg4
            if 1 >= mem[(15 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            mem[_34745 + 468] = mem[(15 * ceil32(return_data.size)) + 548]
            mem[_34745 + 500] = arg5
            mem[_34745 + 532] = arg6
            mem[_34745 + 564] = arg7
            mem[_34745 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_1280 = mem[_34745 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34748 + 1].field_2304) = 0
            mem[_34745 + 664] = address(ext_call.return_data[0])
            mem[_34745 + 696] = address(stor1.field_0)
            mem[_34745 + 628] = 68
            mem[_34745 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34745 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34745 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34745 + 728 len 28]
            mem[_34745 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34745 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34745 + 732 len 64]
            if return_data.size:
                mem[_34745 + 728] = return_data.size
                mem[_34745 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34745 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34745 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34745 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34745 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34745 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34745 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34745 + 760], mem[_34745 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34745 + 764] = address(ext_call.return_data[0])
                mem[_34745 + 796] = address(stor1.field_0)
                mem[_34745 + 728] = 68
                mem[_34745 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34745 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34745 + 828 len 28]
                mem[_34745 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34745 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34745 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34745 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34745 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34748 + 1)
        mem[(15 * ceil32(return_data.size)) + 484] = return_data.size
        mem[(15 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16896 = mem[(15 * ceil32(return_data.size)) + 516]
        require mem[(15 * ceil32(return_data.size)) + 516] <= test266151307()
        require (15 * ceil32(return_data.size)) + return_data.size + 516 > (15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 547
        _16968 = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        if mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
            revert with 0, 65
        mem[64] = (15 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]) + 486
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(15 * ceil32(return_data.size)) + mem[(15 * ceil32(return_data.size)) + 516] + 516]
        require _16896 + (32 * _16968) + 64 <= return_data.size + 32
        mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16968] = mem[(15 * ceil32(return_data.size)) + _16896 + 548 len 32 * _16968]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16968:
            revert with 0, 50
        if mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34749 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34750 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34752 = sha3(mem[_34750 + 32 len mem[_34750]])
        if 1 > !sha3(mem[_34750 + 32 len mem[_34750]]):
            revert with 0, 17
        mem[_34749 + 148] = address(arg1)
        mem[_34749 + 180] = arg4
        mem[_34749 + 212] = address(ext_call.return_data[0])
        mem[_34749 + 244] = address(ext_call.return_data[0])
        mem[_34749 + 276] = _34752 + 1
        mem[_34749 + 116] = 160
        if 0 >= _16968:
            revert with 0, 50
        if 1 >= _16968:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1), address(arg1));
        mem[_34749 + 308] = address(arg1)
        mem[_34749 + 340] = address(arg2)
        mem[_34749 + 372] = address(ext_call.return_data[0])
        mem[_34749 + 404] = address(ext_call.return_data[0])
        mem[_34749 + 436] = arg4
        if 1 >= _16968:
            revert with 0, 50
        mem[_34749 + 468] = mem[(15 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        mem[_34749 + 500] = arg5
        mem[_34749 + 532] = arg6
        mem[_34749 + 564] = arg7
        mem[_34749 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_1280 = mem[_34749 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34752 + 1].field_2304) = 0
        mem[_34749 + 664] = address(ext_call.return_data[0])
        mem[_34749 + 696] = address(stor1.field_0)
        mem[_34749 + 628] = 68
        mem[_34749 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34749 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34749 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34749 + 728 len 28]
        mem[_34749 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34749 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34749 + 732 len 64]
        if return_data.size:
            mem[_34749 + 728] = return_data.size
            mem[_34749 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34749 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34749 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34749 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34749 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34749 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34749 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34749 + 760], mem[_34749 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34749 + 764] = address(ext_call.return_data[0])
            mem[_34749 + 796] = address(stor1.field_0)
            mem[_34749 + 728] = 68
            mem[_34749 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34749 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34749 + 828 len 28]
            mem[_34749 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34749 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34749 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34749 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34749 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34752 + 1)
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).WAVAX() with:
            gas gas_remaining wei
    mem[(12 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(13 * ceil32(return_data.size)) + 324] = address(ext_call.return_data[0])
    mem[(13 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address rg1, address rg2) with:
            gas gas_remaining wei
           args address(ext_call.return_data[0]), address(ext_call.return_data[0])
    mem[(13 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'token pair error'
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    mem[(14 * ceil32(return_data.size)) + 320 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    mem[(15 * ceil32(return_data.size)) + 324] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
    if address(ext_call.return_data[0]) >= address(ext_call.return_data[0]):
        mem[(15 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[32])
        mem[(15 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[0])
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
        mem[(15 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'error PairPrice'
        if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
            revert with 0, 17
        if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
            revert with 0, 'price error'
        mem[(16 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
        mem[(16 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
        mem[(16 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
        mem[(16 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
        mem[(16 * ceil32(return_data.size)) + 320] = 132
        mem[(16 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
        mem[(16 * ceil32(return_data.size)) + 352 len 4] = 3575617902
        mem[(16 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(16 * ceil32(return_data.size)) + 484 len 28]
        mem[(16 * ceil32(return_data.size)) + 616] = 0
        delegate sub_0fc6a11cAddress.mem[(16 * ceil32(return_data.size)) + 484 len 4] with:
             gas gas_remaining wei
            args mem[(16 * ceil32(return_data.size)) + 488 len 128]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            require arg3 <= test266151307()
            require arg2 + 128 > arg3 + 159
            _16971 = mem[arg3 + 128]
            if mem[arg3 + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (16 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
                revert with 0, 65
            mem[64] = (16 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
            mem[(16 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
            require arg3 + (32 * _16971) + 160 <= arg2 + 128
            mem[(16 * ceil32(return_data.size)) + 516 len 32 * _16971] = mem[arg3 + 160 len 32 * _16971]
            if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'subBalance error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
            if uint8(arg8) < 1:
                revert with 0, 17
            if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
                revert with 0, 17
            if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
                revert with 0, 'subLeverage error'
            uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
            if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if mem[(16 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
                revert with 0, 'addBalance error'
            mem[0] = address(arg1)
            mem[32] = sha3(address(ext_call.return_data[0]), 4)
            uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(16 * ceil32(return_data.size)) + 548]
            if stor10 == -1:
                revert with 0, 17
            stor10++
            _34761 = mem[64]
            mem[mem[64] + 32] = block.timestamp
            mem[mem[64] + 64] = address(msg.sender)
            mem[mem[64] + 84] = stor10
            _34762 = mem[64]
            mem[mem[64]] = 84
            mem[64] = mem[64] + 116
            _34764 = sha3(mem[_34762 + 32 len mem[_34762]])
            if 1 > !sha3(mem[_34762 + 32 len mem[_34762]]):
                revert with 0, 17
            mem[_34761 + 148] = address(arg1)
            mem[_34761 + 180] = arg4
            mem[_34761 + 212] = address(ext_call.return_data[0])
            mem[_34761 + 244] = address(ext_call.return_data[0])
            mem[_34761 + 276] = _34764 + 1
            mem[_34761 + 116] = 160
            if 0 >= mem[(16 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(16 * ceil32(return_data.size)) + 516], mem[(16 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1), address(arg1));
            mem[_34761 + 308] = address(arg1)
            mem[_34761 + 340] = address(arg2)
            mem[_34761 + 372] = address(ext_call.return_data[0])
            mem[_34761 + 404] = address(ext_call.return_data[0])
            mem[_34761 + 436] = arg4
            if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
                revert with 0, 50
            mem[_34761 + 468] = mem[(16 * ceil32(return_data.size)) + 548]
            mem[_34761 + 500] = arg5
            mem[_34761 + 532] = arg6
            mem[_34761 + 564] = arg7
            mem[_34761 + 596] = uint8(arg8)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_0) = address(arg1)
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_256) = uint64(arg2) << 96
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_512) = address(ext_call.return_data[0])
            address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_768) = address(ext_call.return_data[0])
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_1024 = arg4
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_1280 = mem[_34761 + 468]
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_1536 = arg5
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_1792 = arg6
            stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_2048 = arg7
            uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34764 + 1].field_2304) = 0
            mem[_34761 + 664] = address(ext_call.return_data[0])
            mem[_34761 + 696] = address(stor1.field_0)
            mem[_34761 + 628] = 68
            mem[_34761 + 664 len 28] = address(ext_call.return_data[0]) << 64
            mem[_34761 + 660 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34761 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34761 + 728 len 28]
            mem[_34761 + 796] = 0
            delegate sub_0fc6a11cAddress.mem[_34761 + 728 len 4] with:
                 gas gas_remaining wei
                args mem[_34761 + 732 len 64]
            if return_data.size:
                mem[_34761 + 728] = return_data.size
                mem[_34761 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[_34761 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34761 + ceil32(return_data.size) + 829 len 28]
                delegate sub_0fc6a11cAddress.mem[_34761 + ceil32(return_data.size) + 829 len 4] with:
                     gas gas_remaining wei
                    args mem[_34761 + ceil32(return_data.size) + 833 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34761 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34761 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34761 + 760], mem[_34761 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                mem[_34761 + 764] = address(ext_call.return_data[0])
                mem[_34761 + 796] = address(stor1.field_0)
                mem[_34761 + 728] = 68
                mem[_34761 + 760 len 4] = getPairPrice(address rg1, address rg2)
                mem[_34761 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34761 + 828 len 28]
                mem[_34761 + 896] = 0
                delegate sub_0fc6a11cAddress.mem[_34761 + 828 len 4] with:
                     gas gas_remaining wei
                    args mem[_34761 + 832 len 64]
                if not return_data.size:
                    if not delegate.return_code:
                        revert with memory
                          from 128
                           len return_data.size
                    require arg2 >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1), address(arg1), address(ext_call.return_data[0])
                else:
                    mem[_34761 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34761 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1), address(arg1), address(ext_call.return_data[0])
            return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34764 + 1)
        mem[(16 * ceil32(return_data.size)) + 484] = return_data.size
        mem[(16 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _16900 = mem[(16 * ceil32(return_data.size)) + 516]
        require mem[(16 * ceil32(return_data.size)) + 516] <= test266151307()
        require (16 * ceil32(return_data.size)) + return_data.size + 516 > (16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 547
        _16972 = mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]
        if mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (16 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
            revert with 0, 65
        mem[64] = (16 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486
        mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]
        require _16900 + (32 * _16972) + 64 <= return_data.size + 32
        mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16972] = mem[(16 * ceil32(return_data.size)) + _16900 + 548 len 32 * _16972]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= _16972:
            revert with 0, 50
        if mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34765 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34766 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34768 = sha3(mem[_34766 + 32 len mem[_34766]])
        if 1 > !sha3(mem[_34766 + 32 len mem[_34766]]):
            revert with 0, 17
        mem[_34765 + 148] = address(arg1)
        mem[_34765 + 180] = arg4
        mem[_34765 + 212] = address(ext_call.return_data[0])
        mem[_34765 + 244] = address(ext_call.return_data[0])
        mem[_34765 + 276] = _34768 + 1
        mem[_34765 + 116] = 160
        if 0 >= _16972:
            revert with 0, 50
        if 1 >= _16972:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1), address(arg1));
        mem[_34765 + 308] = address(arg1)
        mem[_34765 + 340] = address(arg2)
        mem[_34765 + 372] = address(ext_call.return_data[0])
        mem[_34765 + 404] = address(ext_call.return_data[0])
        mem[_34765 + 436] = arg4
        if 1 >= _16972:
            revert with 0, 50
        mem[_34765 + 468] = mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
        mem[_34765 + 500] = arg5
        mem[_34765 + 532] = arg6
        mem[_34765 + 564] = arg7
        mem[_34765 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_1280 = mem[_34765 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34768 + 1].field_2304) = 0
        mem[_34765 + 664] = address(ext_call.return_data[0])
        mem[_34765 + 696] = address(stor1.field_0)
        mem[_34765 + 628] = 68
        mem[_34765 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34765 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34765 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34765 + 728 len 28]
        mem[_34765 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34765 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34765 + 732 len 64]
        if return_data.size:
            mem[_34765 + 728] = return_data.size
            mem[_34765 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34765 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34765 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34765 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34765 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34765 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34765 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34765 + 760], mem[_34765 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34765 + 764] = address(ext_call.return_data[0])
            mem[_34765 + 796] = address(stor1.field_0)
            mem[_34765 + 728] = 68
            mem[_34765 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34765 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34765 + 828 len 28]
            mem[_34765 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34765 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34765 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34765 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34765 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34768 + 1)
    mem[(15 * ceil32(return_data.size)) + 356] = Mask(112, 0, ext_call.return_data[0])
    mem[(15 * ceil32(return_data.size)) + 388] = Mask(112, 0, ext_call.return_data[32])
    require ext_code.size(address(routerAddress))
    staticcall address(routerAddress).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
            gas gas_remaining wei
           args (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
    mem[(15 * ceil32(return_data.size)) + 320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0, 'error PairPrice'
    if (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
        revert with 0, 17
    if ext_call.return_data[0] < 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100:
        revert with 0, 'price error'
    mem[(16 * ceil32(return_data.size)) + 356] = address(ext_call.return_data[0])
    mem[(16 * ceil32(return_data.size)) + 388] = address(ext_call.return_data[0])
    mem[(16 * ceil32(return_data.size)) + 420] = (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18)
    mem[(16 * ceil32(return_data.size)) + 452] = 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100
    mem[(16 * ceil32(return_data.size)) + 320] = 132
    mem[(16 * ceil32(return_data.size)) + 356 len 28] = address(ext_call.return_data[0]) << 64
    mem[(16 * ceil32(return_data.size)) + 352 len 4] = 3575617902
    mem[(16 * ceil32(return_data.size)) + 484 len 160] = 3575617902, address(ext_call.return_data[0]) << 64, 0, address(ext_call.return_data[0]), (arg4 * uint8(arg8)) - (arg4 * uint8(arg8) * serviceFee / 10^18), 95 * (arg4 * uint8(arg8) * ext_call.return_data[0]) - (arg4 * uint8(arg8) * serviceFee / 10^18 * ext_call.return_data[0]) / ext_call.return_data[0] / 100, mem[(16 * ceil32(return_data.size)) + 484 len 28]
    mem[(16 * ceil32(return_data.size)) + 616] = 0
    delegate sub_0fc6a11cAddress.mem[(16 * ceil32(return_data.size)) + 484 len 4] with:
         gas gas_remaining wei
        args mem[(16 * ceil32(return_data.size)) + 488 len 128]
    if not return_data.size:
        if not delegate.return_code:
            revert with memory
              from 128
               len return_data.size
        require arg2 >= 32
        require arg3 <= test266151307()
        require arg2 + 128 > arg3 + 159
        _16975 = mem[arg3 + 128]
        if mem[arg3 + 128] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[arg3 + 128]) + 485 < 484 or (16 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485 > test266151307():
            revert with 0, 65
        mem[64] = (16 * ceil32(return_data.size)) + ceil32(32 * mem[arg3 + 128]) + 485
        mem[(16 * ceil32(return_data.size)) + 484] = mem[arg3 + 128]
        require arg3 + (32 * _16975) + 160 <= arg2 + 128
        mem[(16 * ceil32(return_data.size)) + 516 len 32 * _16975] = mem[arg3 + 160 len 32 * _16975]
        if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'subBalance error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
        if uint8(arg8) < 1:
            revert with 0, 17
        if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
            revert with 0, 17
        if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
            revert with 0, 'subLeverage error'
        uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
        if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
            revert with 0, 50
        if mem[(16 * ceil32(return_data.size)) + 548] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
            revert with 0, 'addBalance error'
        mem[0] = address(arg1)
        mem[32] = sha3(address(ext_call.return_data[0]), 4)
        uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(16 * ceil32(return_data.size)) + 548]
        if stor10 == -1:
            revert with 0, 17
        stor10++
        _34777 = mem[64]
        mem[mem[64] + 32] = block.timestamp
        mem[mem[64] + 64] = address(msg.sender)
        mem[mem[64] + 84] = stor10
        _34778 = mem[64]
        mem[mem[64]] = 84
        mem[64] = mem[64] + 116
        _34780 = sha3(mem[_34778 + 32 len mem[_34778]])
        if 1 > !sha3(mem[_34778 + 32 len mem[_34778]]):
            revert with 0, 17
        mem[_34777 + 148] = address(arg1)
        mem[_34777 + 180] = arg4
        mem[_34777 + 212] = address(ext_call.return_data[0])
        mem[_34777 + 244] = address(ext_call.return_data[0])
        mem[_34777 + 276] = _34780 + 1
        mem[_34777 + 116] = 160
        if 0 >= mem[(16 * ceil32(return_data.size)) + 484]:
            revert with 0, 50
        if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
            revert with 0, 50
        emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(16 * ceil32(return_data.size)) + 516], mem[(16 * ceil32(return_data.size)) + 548], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1), address(arg1));
        mem[_34777 + 308] = address(arg1)
        mem[_34777 + 340] = address(arg2)
        mem[_34777 + 372] = address(ext_call.return_data[0])
        mem[_34777 + 404] = address(ext_call.return_data[0])
        mem[_34777 + 436] = arg4
        if 1 >= mem[(16 * ceil32(return_data.size)) + 484]:
            revert with 0, 50
        mem[_34777 + 468] = mem[(16 * ceil32(return_data.size)) + 548]
        mem[_34777 + 500] = arg5
        mem[_34777 + 532] = arg6
        mem[_34777 + 564] = arg7
        mem[_34777 + 596] = uint8(arg8)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_0) = address(arg1)
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_256) = uint64(arg2) << 96
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_512) = address(ext_call.return_data[0])
        address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_768) = address(ext_call.return_data[0])
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_1024 = arg4
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_1280 = mem[_34777 + 468]
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_1536 = arg5
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_1792 = arg6
        stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_2048 = arg7
        uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34780 + 1].field_2304) = 0
        mem[_34777 + 664] = address(ext_call.return_data[0])
        mem[_34777 + 696] = address(stor1.field_0)
        mem[_34777 + 628] = 68
        mem[_34777 + 664 len 28] = address(ext_call.return_data[0]) << 64
        mem[_34777 + 660 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34777 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34777 + 728 len 28]
        mem[_34777 + 796] = 0
        delegate sub_0fc6a11cAddress.mem[_34777 + 728 len 4] with:
             gas gas_remaining wei
            args mem[_34777 + 732 len 64]
        if return_data.size:
            mem[_34777 + 728] = return_data.size
            mem[_34777 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[_34777 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34777 + ceil32(return_data.size) + 829 len 28]
            delegate sub_0fc6a11cAddress.mem[_34777 + ceil32(return_data.size) + 829 len 4] with:
                 gas gas_remaining wei
                args mem[_34777 + ceil32(return_data.size) + 833 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34777 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34777 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34777 + 760], mem[_34777 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            mem[_34777 + 764] = address(ext_call.return_data[0])
            mem[_34777 + 796] = address(stor1.field_0)
            mem[_34777 + 728] = 68
            mem[_34777 + 760 len 4] = getPairPrice(address rg1, address rg2)
            mem[_34777 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34777 + 828 len 28]
            mem[_34777 + 896] = 0
            delegate sub_0fc6a11cAddress.mem[_34777 + 828 len 4] with:
                 gas gas_remaining wei
                args mem[_34777 + 832 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require arg2 >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1), address(arg1), address(ext_call.return_data[0])
            else:
                mem[_34777 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34777 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1), address(arg1), address(ext_call.return_data[0])
        return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34780 + 1)
    mem[(16 * ceil32(return_data.size)) + 484] = return_data.size
    mem[(16 * ceil32(return_data.size)) + 516 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _16904 = mem[(16 * ceil32(return_data.size)) + 516]
    require mem[(16 * ceil32(return_data.size)) + 516] <= test266151307()
    require (16 * ceil32(return_data.size)) + return_data.size + 516 > (16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 547
    _16976 = mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]
    if mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486 < 485 or (16 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486 > test266151307():
        revert with 0, 65
    mem[64] = (16 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]) + 486
    mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = mem[(16 * ceil32(return_data.size)) + mem[(16 * ceil32(return_data.size)) + 516] + 516]
    require _16904 + (32 * _16976) + 64 <= return_data.size + 32
    mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 517 len 32 * _16976] = mem[(16 * ceil32(return_data.size)) + _16904 + 548 len 32 * _16976]
    if arg4 > uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
        revert with 0, 'subBalance error'
    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) -= arg4
    if uint8(arg8) < 1:
        revert with 0, 17
    if arg4 and uint8(uint8(arg8) - 1) > -1 / arg4:
        revert with 0, 17
    if arg4 * uint8(uint8(arg8) - 1) > uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]):
        revert with 0, 'subLeverage error'
    uint256(sub_996e5938[address(ext_call.return_data[0])][1][address(arg1)]) += -1 * arg4 * uint8(uint8(arg8) - 1)
    if 1 >= _16976:
        revert with 0, 50
    if mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] + uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) < uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]):
        revert with 0, 'addBalance error'
    mem[0] = address(arg1)
    mem[32] = sha3(address(ext_call.return_data[0]), 4)
    uint256(sub_996e5938[address(ext_call.return_data[0])][address(arg1)]) += mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
    if stor10 == -1:
        revert with 0, 17
    stor10++
    _34781 = mem[64]
    mem[mem[64] + 32] = block.timestamp
    mem[mem[64] + 64] = address(msg.sender)
    mem[mem[64] + 84] = stor10
    _34782 = mem[64]
    mem[mem[64]] = 84
    mem[64] = mem[64] + 116
    _34784 = sha3(mem[_34782 + 32 len mem[_34782]])
    if 1 > !sha3(mem[_34782 + 32 len mem[_34782]]):
        revert with 0, 17
    mem[_34781 + 148] = address(arg1)
    mem[_34781 + 180] = arg4
    mem[_34781 + 212] = address(ext_call.return_data[0])
    mem[_34781 + 244] = address(ext_call.return_data[0])
    mem[_34781 + 276] = _34784 + 1
    mem[_34781 + 116] = 160
    if 0 >= _16976:
        revert with 0, 50
    if 1 >= _16976:
        revert with 0, 50
    emit OnTokenSwapped(address(ext_call.return_data[0]), address(ext_call.return_data[0]), mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 517], mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1), address(arg1));
    mem[_34781 + 308] = address(arg1)
    mem[_34781 + 340] = address(arg2)
    mem[_34781 + 372] = address(ext_call.return_data[0])
    mem[_34781 + 404] = address(ext_call.return_data[0])
    mem[_34781 + 436] = arg4
    if 1 >= _16976:
        revert with 0, 50
    mem[_34781 + 468] = mem[(16 * ceil32(return_data.size)) + ceil32(return_data.size) + 549]
    mem[_34781 + 500] = arg5
    mem[_34781 + 532] = arg6
    mem[_34781 + 564] = arg7
    mem[_34781 + 596] = uint8(arg8)
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_0) = address(arg1)
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_256) = uint64(arg2) << 96
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_512) = address(ext_call.return_data[0])
    address(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_768) = address(ext_call.return_data[0])
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_1024 = arg4
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_1280 = mem[_34781 + 468]
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_1536 = arg5
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_1792 = arg6
    stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_2048 = arg7
    uint8(stor2[address(arg1)][arg4][address(ext_call.return_data[0])][address(ext_call.return_data[0])][_34784 + 1].field_2304) = 0
    mem[_34781 + 664] = address(ext_call.return_data[0])
    mem[_34781 + 696] = address(stor1.field_0)
    mem[_34781 + 628] = 68
    mem[_34781 + 664 len 28] = address(ext_call.return_data[0]) << 64
    mem[_34781 + 660 len 4] = getPairPrice(address rg1, address rg2)
    mem[_34781 + 728 len 96] = getPairPrice(address rg1, address rg2), address(ext_call.return_data[0]) << 64, 0, address(stor1.field_0), mem[_34781 + 728 len 28]
    mem[_34781 + 796] = 0
    delegate sub_0fc6a11cAddress.mem[_34781 + 728 len 4] with:
         gas gas_remaining wei
        args mem[_34781 + 732 len 64]
    if return_data.size:
        mem[_34781 + 728] = return_data.size
        mem[_34781 + 760 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[_34781 + ceil32(return_data.size) + 829 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34781 + ceil32(return_data.size) + 829 len 28]
        delegate sub_0fc6a11cAddress.mem[_34781 + ceil32(return_data.size) + 829 len 4] with:
             gas gas_remaining wei
            args mem[_34781 + ceil32(return_data.size) + 833 len 64]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34781 + 760], arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            mem[_34781 + ceil32(return_data.size) + 861 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, mem[_34781 + 760], mem[_34781 + ceil32(return_data.size) + 861], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1), address(arg1), address(ext_call.return_data[0])
    else:
        if not delegate.return_code:
            revert with memory
              from 128
               len return_data.size
        require arg2 >= 32
        mem[_34781 + 764] = address(ext_call.return_data[0])
        mem[_34781 + 796] = address(stor1.field_0)
        mem[_34781 + 728] = 68
        mem[_34781 + 760 len 4] = getPairPrice(address rg1, address rg2)
        mem[_34781 + 828 len 96] = 0, address(ext_call.return_data[0]), address(stor1.field_0), mem[_34781 + 828 len 28]
        mem[_34781 + 896] = 0
        delegate sub_0fc6a11cAddress.mem[_34781 + 828 len 4] with:
             gas gas_remaining wei
            args mem[_34781 + 832 len 64]
        if not return_data.size:
            if not delegate.return_code:
                revert with memory
                  from 128
                   len return_data.size
            require arg2 >= 32
            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, arg3, sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1), address(arg1), address(ext_call.return_data[0])
        else:
            mem[_34781 + 860 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not delegate.return_code:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit 0x12cdba7c: address(arg2), address(ext_call.return_data[0]), arg4, arg5, arg6, arg7, arg8 << 248, arg3, mem[_34781 + 860], sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1), address(arg1), address(ext_call.return_data[0])
    return sha3(address(arg1), arg4, address(ext_call.return_data[0]), address(ext_call.return_data[0]), _34784 + 1)
}

function checkOrder(bytes32 arg1) {
    require calldata.size - 4 >= 32
    mem[128] = address(stor2[arg1].field_256)
    mem[160] = address(stor2[arg1].field_512)
    mem[192] = address(stor2[arg1].field_768)
    mem[224] = stor2[arg1].field_1024
    mem[256] = stor2[arg1].field_1280
    mem[288] = stor2[arg1].field_1536
    mem[320] = stor2[arg1].field_1792
    mem[352] = stor2[arg1].field_2048
    mem[384] = uint8(stor2[arg1].field_2304)
    if not address(stor2[arg1].field_0):
        revert with 0, 'invalid order id'
    if address(stor2[arg1].field_512) != 1:
        if address(stor2[arg1].field_768) != 1:
            mem[452] = address(stor2[arg1].field_768)
            mem[484] = address(stor2[arg1].field_512)
            mem[416] = 68
            mem[452 len 28] = Mask(224, 0, stor2[arg1].field_768)
            mem[448 len 4] = 3093898343
            mem[516 len 96] = 3093898343, Mask(224, 0, stor2[arg1].field_768), uint32(stor2[arg1].field_768), address(stor2[arg1].field_512), mem[516 len 28]
            mem[584] = 0
            delegate sub_0fc6a11cAddress.mem[516 len 4] with:
                 gas gas_remaining wei
                args mem[520 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require address(stor2[arg1].field_0) >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
            else:
                mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if mem[548] > stor2[arg1].field_1792:
                        if mem[548] < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if mem[548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if mem[548] < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if mem[548] > stor2[arg1].field_1792:
                                    if mem[548] < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if mem[548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[548] > stor2[arg1].field_1792:
                                        if mem[548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[548] > stor2[arg1].field_1792:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[548] > stor2[arg1].field_1792:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if mem[548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[548] > stor2[arg1].field_1792:
                                        if mem[548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[548] > stor2[arg1].field_1792:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[548] > stor2[arg1].field_1792:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[548] > stor2[arg1].field_1792:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[548] > stor2[arg1].field_1792:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[548] > stor2[arg1].field_1792:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[548] > stor2[arg1].field_1792:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[548] > stor2[arg1].field_1792:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[548] > stor2[arg1].field_1792:
                                            if mem[548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[548] > stor2[arg1].field_1792:
                                                if mem[548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[548] > stor2[arg1].field_1792:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[548] > stor2[arg1].field_1792:
                                                    if mem[548] < stor2[arg1].field_1536:
                                                        return 2
        else:
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            mem[416] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[ceil32(return_data.size) + 516 len 96] = 0, ext_call.return_data[12 len 20], address(stor2[arg1].field_512), mem[ceil32(return_data.size) + 516 len 28]
            delegate sub_0fc6a11cAddress.mem[ceil32(return_data.size) + 516 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + 520 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require address(stor2[arg1].field_0) >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
            else:
                mem[ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
    else:
        require ext_code.size(address(routerAddress))
        staticcall address(routerAddress).WAVAX() with:
                gas gas_remaining wei
        mem[416] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(stor2[arg1].field_768) != 1:
            mem[ceil32(return_data.size) + 484] = ext_call.return_data[12 len 20]
            mem[ceil32(return_data.size) + 516 len 96] = 3093898343, Mask(224, 0, stor2[arg1].field_768), uint32(stor2[arg1].field_768), mem[ceil32(return_data.size) + 484 len 60]
            delegate sub_0fc6a11cAddress.mem[ceil32(return_data.size) + 516 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + 520 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require address(stor2[arg1].field_0) >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
            else:
                mem[ceil32(return_data.size) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[ceil32(return_data.size) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[ceil32(return_data.size) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[ceil32(return_data.size) + 548] > stor2[arg1].field_1792:
                                                    if mem[ceil32(return_data.size) + 548] < stor2[arg1].field_1536:
                                                        return 2
        else:
            require ext_code.size(address(routerAddress))
            staticcall address(routerAddress).WAVAX() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 516 len 96] = 0, ext_call.return_data[12 len 20], address(ext_call.return_data[0]), mem[(2 * ceil32(return_data.size)) + 516 len 28]
            delegate sub_0fc6a11cAddress.mem[(2 * ceil32(return_data.size)) + 516 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 520 len 64]
            if not return_data.size:
                if not delegate.return_code:
                    revert with memory
                      from 128
                       len return_data.size
                require address(stor2[arg1].field_0) >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if address(stor2[arg1].field_256) > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if address(stor2[arg1].field_256) > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if address(stor2[arg1].field_256) > stor2[arg1].field_1792:
                                                    if address(stor2[arg1].field_256) < stor2[arg1].field_1536:
                                                        return 2
            else:
                mem[(2 * ceil32(return_data.size)) + 548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 1 == uint8(stor2[arg1].field_2304):
                    if stor2[arg1].field_2048 <= block.timestamp:
                        return 1
                    if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                        if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                            return 2
                else:
                    if stor2[arg1].field_1024 and uint8(stor2[arg1].field_2304) > -1 / stor2[arg1].field_1024:
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) and serviceFee > -1 / stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304):
                        revert with 0, 17
                    if stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) < stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18:
                        revert with 0, 17
                    if 1 == address(stor2[arg1].field_512):
                        if 1 == address(stor2[arg1].field_768):
                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                revert with 0, 17
                            if not stor2[arg1].field_1280:
                                revert with 0, 18
                            if not uint8(stor2[arg1].field_2304):
                                revert with 0, 18
                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                revert with 0, 17
                            if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                revert with 0, 17
                            if stor2[arg1].field_2048 <= block.timestamp:
                                return 1
                            if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                        return 2
                            else:
                                if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                        return 2
                        else:
                            require ext_code.size(address(stor2[arg1].field_768))
                            staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                            if not ext_call.return_data[31 len 1]:
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                        if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    s = 10
                                    t = 1
                                    idx = ext_call.return_data[31 len 1]
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^18) / 10^18:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                    else:
                        require ext_code.size(address(stor2[arg1].field_512))
                        staticcall address(stor2[arg1].field_512).0x313ce567 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                        if not ext_call.return_data[31 len 1]:
                            if 1 == address(stor2[arg1].field_768):
                                if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                    revert with 0, 17
                                if not stor2[arg1].field_1280:
                                    revert with 0, 18
                                if not uint8(stor2[arg1].field_2304):
                                    revert with 0, 18
                                if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                    revert with 0, 17
                                if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                    revert with 0, 17
                                if stor2[arg1].field_2048 <= block.timestamp:
                                    return 1
                                if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                    if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                        if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                            return 2
                                else:
                                    if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                            return 2
                            else:
                                require ext_code.size(address(stor2[arg1].field_768))
                                staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                if not ext_call.return_data[31 len 1]:
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280) / 10^18:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280) / 10^18:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        s = 10
                                        t = 1
                                        idx = ext_call.return_data[31 len 1]
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280) / 10^18:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                        else:
                            if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1] and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^ext_call.return_data[31 len 1]) / 10^18:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            s = 10
                                            t = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and s * t > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]) and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0]):
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * s * t) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * s * t) / stor2[arg1].field_1280 / 10^uint8(ext_call.return_data[0])) / 10^18:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                            else:
                                s = 10
                                t = 1
                                idx = ext_call.return_data[31 len 1]
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if 1 == address(stor2[arg1].field_768):
                                    if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                        revert with 0, 17
                                    if not stor2[arg1].field_1280:
                                        revert with 0, 18
                                    if not s * t:
                                        revert with 0, 18
                                    if not uint8(stor2[arg1].field_2304):
                                        revert with 0, 18
                                    if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                        revert with 0, 17
                                    if (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                        revert with 0, 17
                                    if stor2[arg1].field_2048 <= block.timestamp:
                                        return 1
                                    if (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (1000000000000000000 * 10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                    else:
                                        if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                return 2
                                else:
                                    require ext_code.size(address(stor2[arg1].field_768))
                                    staticcall address(stor2[arg1].field_768).0x313ce567 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
                                    if not ext_call.return_data[31 len 1]:
                                        if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 1 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                            revert with 0, 17
                                        if not stor2[arg1].field_1280:
                                            revert with 0, 18
                                        if not s * t:
                                            revert with 0, 18
                                        if not uint8(stor2[arg1].field_2304):
                                            revert with 0, 18
                                        if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                            revert with 0, 17
                                        if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t:
                                            revert with 0, 17
                                        if stor2[arg1].field_2048 <= block.timestamp:
                                            return 1
                                        if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                        else:
                                            if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                    return 2
                                    else:
                                        if bool(bool(ext_call.return_data[31 len 1] < 78)) or bool(bool(ext_call.return_data[31 len 1] < 32)):
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^ext_call.return_data[31 len 1] > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * 10^ext_call.return_data[31 len 1]) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * 10^ext_call.return_data[31 len 1]) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                        else:
                                            u = 10
                                            v = 1
                                            idx = ext_call.return_data[31 len 1]
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and 10^18 > -1 / (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18) and u * v > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304)) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18):
                                                revert with 0, 17
                                            if not stor2[arg1].field_1280:
                                                revert with 0, 18
                                            if not s * t:
                                                revert with 0, 18
                                            if not uint8(stor2[arg1].field_2304):
                                                revert with 0, 18
                                            if 10^18 < sub_e5adac3d / uint8(stor2[arg1].field_2304):
                                                revert with 0, 17
                                            if (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t and -(sub_e5adac3d / uint8(stor2[arg1].field_2304)) + 10^18 > -1 / (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t:
                                                revert with 0, 17
                                            if stor2[arg1].field_2048 <= block.timestamp:
                                                return 1
                                            if (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18 >= stor2[arg1].field_1792:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > (10^18 * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) - (sub_e5adac3d / uint8(stor2[arg1].field_2304) * (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * u * v) - (10^18 * stor2[arg1].field_1024 * uint8(stor2[arg1].field_2304) * serviceFee / 10^18 * u * v) / stor2[arg1].field_1280 / s * t) / 10^18:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
                                            else:
                                                if mem[(2 * ceil32(return_data.size)) + 548] > stor2[arg1].field_1792:
                                                    if mem[(2 * ceil32(return_data.size)) + 548] < stor2[arg1].field_1536:
                                                        return 2
    return 0
}



}

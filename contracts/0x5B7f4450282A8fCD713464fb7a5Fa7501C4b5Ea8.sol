contract main {




// =====================  Runtime code  =====================


#
#  - _getNodesRewardAvailable(address arg1)
#  - _cashoutNodeReward(address arg1, uint256 arg2)
#  - _distributeRewards()
#  - sub_90219732(?)
#  - sub_a50c28ea(?)
#  - _getRewardAmountOf(address arg1, uint256 arg2)
#
array of uint256 stor1;
array of struct sub_2130fe23;
uint256 nodePrice;
uint256 rewardPerNode;
uint256 claimTime;
address gateKeeperAddress;
uint8 stor9; offset 160
uint8 stor9; offset 168
uint128 stor9; offset 160
address tokenAddress;
uint256 gasForDistribution;
uint256 lastDistributionCount;
uint256 lastIndexProcessed;
uint256 totalNodesCreated;
uint256 totalRewardStaked;
uint256 claimDuration;
uint256 sub_b137b854;
uint256 sub_af89f87c;

function sub_2130fe23(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_2130fe23[address(arg1)].field_0
}

function claimTime() payable {
    return claimTime
}

function gateKeeper() payable {
    return gateKeeperAddress
}

function distribution() payable {
    return bool(uint8(stor9.field_168))
}

function rewardPerNode() payable {
    return rewardPerNode
}

function lastIndexProcessed() payable {
    return lastIndexProcessed
}

function autoDistri() payable {
    return bool(uint8(stor9.field_160))
}

function totalRewardStaked() payable {
    return totalRewardStaked
}

function claimDuration() payable {
    return claimDuration
}

function sub_af89f87c(?) payable {
    return sub_af89f87c
}

function sub_b137b854(?) payable {
    return sub_b137b854
}

function totalNodesCreated() payable {
    return totalNodesCreated
}

function gasForDistribution() payable {
    return gasForDistribution
}

function nodePrice() payable {
    return nodePrice
}

function lastDistributionCount() payable {
    return lastDistributionCount
}

function token() payable {
    return tokenAddress
}

function _fallback() payable {
    revert
}

function sub_0df5c9d2(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    sub_af89f87c = arg1
}

function sub_d9b3d6db(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    sub_b137b854 = arg1
}

function _changeNodePrice(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    nodePrice = arg1
}

function _changeClaimTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    claimTime = arg1
}

function _changeRewardPerNode(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    rewardPerNode = arg1
}

function _changeGasDistri(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    gasForDistribution = arg1
}

function setToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    tokenAddress = arg1
}

function _changeAutoDistri(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    Mask(96, 0, stor9.field_160) = Mask(96, 0, arg1)
}

function sub_2d6f594f(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
    if not sub_2130fe23[address(arg1)].field_0:
        revert with 0, 50
    if sub_2130fe23[address(arg1)].field_768 > !arg2:
        revert with 0, 17
    sub_2130fe23[address(arg1)].field_768 += arg2
}

function _getNodeNumberOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(0x83a099deff9c89036f4c697511a504ea917d192a)
    delegate 0x83a099deff9c89036f4c697511a504ea917d192a.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return delegate.return_data[0]
}

function _isNodeOwner(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(0x83a099deff9c89036f4c697511a504ea917d192a)
    delegate 0x83a099deff9c89036f4c697511a504ea917d192a.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (delegate.return_data[0] > 0)
}

function _getNodesNames(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[100] = 0
    mem[132] = arg1
    require ext_code.size(0x83a099deff9c89036f4c697511a504ea917d192a)
    delegate 0x83a099deff9c89036f4c697511a504ea917d192a.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    mem[96] = delegate.return_data[0]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if delegate.return_data[0] <= 0:
        revert with 0, 'GET NAMES: NO NODE OWNER'
    mem[0] = arg1
    mem[32] = 4
    mem[64] = ceil32(return_data.size) + (32 * sub_2130fe23[address(arg1)].field_0) + 128
    mem[ceil32(return_data.size) + 96] = sub_2130fe23[address(arg1)].field_0
    s = ceil32(return_data.size) + 128
    idx = 0
    while idx < sub_2130fe23[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _56 = mem[64]
        mem[64] = mem[64] + 128
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            _62 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
            mem[_62] = sub_2130fe23[address(arg1)][idx].field_1
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if sub_2130fe23[address(arg1)][idx].field_1:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_62 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_62 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _62 + 32
                        u = sha3(mem[0])
                        while _62 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_56] = _62
                mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_56] = _62
                mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_62 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_56] = _62
                mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_62 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _62 + 32
            u = sha3(mem[0])
            while _62 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_56] = _62
            mem[_56 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_56 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_56 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _56
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        _64 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
        mem[_64] = sub_2130fe23[address(arg1)][idx].field_1
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_56] = _64
                mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_64 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_56] = _64
                mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_64 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _64 + 32
            u = sha3(mem[0])
            while _64 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_56] = _64
            mem[_56 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_56 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_56 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _56
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        if sub_2130fe23[address(arg1)][idx].field_1:
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_64 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                mem[_64 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                t = _64 + 32
                u = sha3(mem[0])
                while _64 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_56] = _64
        mem[_56 + 32] = sub_2130fe23[address(arg1)][idx].field_256
        mem[_56 + 64] = sub_2130fe23[address(arg1)][idx].field_512
        mem[_56 + 96] = sub_2130fe23[address(arg1)][idx].field_768
        mem[s] = _56
        s = s + 32
        idx = idx + 1
        continue 
    _54 = mem[ceil32(return_data.size) + 96]
    _57 = mem[64]
    mem[64] = mem[64] + 128
    mem[_57] = 96
    mem[_57 + 32] = 0
    mem[_57 + 64] = 0
    mem[_57 + 96] = 0
    if 0 >= mem[ceil32(return_data.size) + 96]:
        revert with 0, 50
    _60 = mem[mem[ceil32(return_data.size) + 128]]
    _61 = mem[64]
    mem[64] = mem[64] + 64
    mem[_61] = 1
    mem[_61 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _60
    t = _57
    while idx < _54:
        if idx >= mem[ceil32(return_data.size) + 96]:
            revert with 0, 50
        _101 = mem[(32 * idx) + ceil32(return_data.size) + 128]
        _102 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128]]
        _103 = mem[64]
        _105 = mem[s]
        t = 0
        while t < _105:
            mem[t + _103 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_105) <= _105:
            _132 = mem[_61]
            s = 0
            while s < _132:
                mem[s + _103 + _105 + 32] = mem[s + _61 + 32]
                s = s + 32
                continue 
            if ceil32(_132) <= _132:
                _156 = mem[_102]
                s = 0
                while s < _156:
                    mem[s + _103 + _105 + _132 + 32] = mem[s + _102 + 32]
                    s = s + 32
                    continue 
                if ceil32(_156) <= _156:
                    _176 = mem[64]
                    mem[mem[64]] = _156 + _103 + _105 + _132 - mem[64]
                    mem[64] = _156 + _103 + _105 + _132 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _176
                    t = _101
                    continue 
                mem[_103 + _105 + _132 + _156 + 32] = 0
                _180 = mem[64]
                mem[mem[64]] = _156 + _103 + _105 + _132 - mem[64]
                mem[64] = _156 + _103 + _105 + _132 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _180
                t = _101
                continue 
            mem[_103 + _105 + _132 + 32] = 0
            _158 = mem[_102]
            s = 0
            while s < _158:
                mem[s + _103 + _105 + _132 + 32] = mem[s + _102 + 32]
                s = s + 32
                continue 
            if ceil32(_158) <= _158:
                _177 = mem[64]
                mem[mem[64]] = _158 + _103 + _105 + _132 - mem[64]
                mem[64] = _158 + _103 + _105 + _132 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _177
                t = _101
                continue 
            mem[_103 + _105 + _132 + _158 + 32] = 0
            _181 = mem[64]
            mem[mem[64]] = _158 + _103 + _105 + _132 - mem[64]
            mem[64] = _158 + _103 + _105 + _132 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _181
            t = _101
            continue 
        mem[_103 + _105 + 32] = 0
        _134 = mem[_61]
        s = 0
        while s < _134:
            mem[s + _103 + _105 + 32] = mem[s + _61 + 32]
            s = s + 32
            continue 
        if ceil32(_134) <= _134:
            _157 = mem[_102]
            s = 0
            while s < _157:
                mem[s + _103 + _105 + _134 + 32] = mem[s + _102 + 32]
                s = s + 32
                continue 
            if ceil32(_157) <= _157:
                _178 = mem[64]
                mem[mem[64]] = _157 + _103 + _105 + _134 - mem[64]
                mem[64] = _157 + _103 + _105 + _134 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _178
                t = _101
                continue 
            mem[_103 + _105 + _134 + _157 + 32] = 0
            _182 = mem[64]
            mem[mem[64]] = _157 + _103 + _105 + _134 - mem[64]
            mem[64] = _157 + _103 + _105 + _134 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _182
            t = _101
            continue 
        mem[_103 + _105 + _134 + 32] = 0
        _159 = mem[_102]
        s = 0
        while s < _159:
            mem[s + _103 + _105 + _134 + 32] = mem[s + _102 + 32]
            s = s + 32
            continue 
        if ceil32(_159) <= _159:
            _179 = mem[64]
            mem[mem[64]] = _159 + _103 + _105 + _134 - mem[64]
            mem[64] = _159 + _103 + _105 + _134 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _179
            t = _101
            continue 
        mem[_103 + _105 + _134 + _159 + 32] = 0
        _183 = mem[64]
        mem[mem[64]] = _159 + _103 + _105 + _134 - mem[64]
        mem[64] = _159 + _103 + _105 + _134 + 32
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = _183
        t = _101
        continue 
    mem[mem[64]] = 32
    _104 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_104)] = mem[s + 32 len ceil32(_104)]
    if ceil32(_104) > _104:
        mem[mem[64] + _104 + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_104) + 32]
}

function _getNodesCreationTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[100] = 0
    mem[132] = arg1
    require ext_code.size(0x83a099deff9c89036f4c697511a504ea917d192a)
    delegate 0x83a099deff9c89036f4c697511a504ea917d192a.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    mem[96] = delegate.return_data[0]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if delegate.return_data[0] <= 0:
        revert with 0, 'GET CREATIME: NO NODE OWNER'
    mem[0] = arg1
    mem[32] = 4
    mem[64] = ceil32(return_data.size) + (32 * sub_2130fe23[address(arg1)].field_0) + 128
    mem[ceil32(return_data.size) + 96] = sub_2130fe23[address(arg1)].field_0
    s = ceil32(return_data.size) + 128
    idx = 0
    while idx < sub_2130fe23[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _58 = mem[64]
        mem[64] = mem[64] + 128
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            _63 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
            mem[_63] = sub_2130fe23[address(arg1)][idx].field_1
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if sub_2130fe23[address(arg1)][idx].field_1:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_63 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_63 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _63 + 32
                        u = sha3(mem[0])
                        while _63 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_63 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_63 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _63 + 32
            u = sha3(mem[0])
            while _63 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_58] = _63
            mem[_58 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_58 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_58 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _58
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        _65 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
        mem[_65] = sub_2130fe23[address(arg1)][idx].field_1
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_58] = _65
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_65 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_58] = _65
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_65 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _65 + 32
            u = sha3(mem[0])
            while _65 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_58] = _65
            mem[_58 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_58 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_58 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _58
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        if sub_2130fe23[address(arg1)][idx].field_1:
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_65 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                mem[_65 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                t = _65 + 32
                u = sha3(mem[0])
                while _65 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_58] = _65
        mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
        mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
        mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
        mem[s] = _58
        s = s + 32
        idx = idx + 1
        continue 
    _56 = mem[ceil32(return_data.size) + 96]
    _59 = mem[64]
    mem[64] = mem[64] + 128
    mem[_59] = 96
    mem[_59 + 32] = 0
    mem[_59 + 64] = 0
    mem[_59 + 96] = 0
    if 0 >= mem[ceil32(return_data.size) + 96]:
        revert with 0, 50
    _62 = mem[mem[ceil32(return_data.size) + 128] + 32]
    if not mem[mem[ceil32(return_data.size) + 128] + 32]:
        _64 = mem[64]
        mem[64] = mem[64] + 64
        mem[_64] = 1
        mem[_64 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _66 = mem[64]
        mem[64] = mem[64] + 64
        mem[_66] = 1
        mem[_66 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _64
        t = _59
        while idx < _56:
            if idx >= mem[ceil32(return_data.size) + 96]:
                revert with 0, 50
            _106 = mem[(32 * idx) + ceil32(return_data.size) + 128]
            _107 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
            if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]:
                _109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_109] = 1
                mem[_109 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _112 = mem[64]
                _114 = mem[s]
                t = 0
                while t < _114:
                    mem[t + _112 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_114) <= _114:
                    _209 = mem[_66]
                    s = 0
                    while s < _209:
                        mem[s + _112 + _114 + 32] = mem[s + _66 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_209) <= _209:
                        _361 = mem[_109]
                        s = 0
                        while s < _361:
                            mem[s + _112 + _114 + _209 + 32] = mem[s + _109 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_361) <= _361:
                            _497 = mem[64]
                            mem[mem[64]] = _361 + _112 + _114 + _209 - mem[64]
                            mem[64] = _361 + _112 + _114 + _209 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _497
                            t = _106
                            continue 
                        mem[_112 + _114 + _209 + _361 + 32] = 0
                        _503 = mem[64]
                        mem[mem[64]] = _361 + _112 + _114 + _209 - mem[64]
                        mem[64] = _361 + _112 + _114 + _209 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _503
                        t = _106
                        continue 
                    mem[_112 + _114 + _209 + 32] = 0
                    _365 = mem[_109]
                    s = 0
                    while s < _365:
                        mem[s + _112 + _114 + _209 + 32] = mem[s + _109 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_365) <= _365:
                        _498 = mem[64]
                        mem[mem[64]] = _365 + _112 + _114 + _209 - mem[64]
                        mem[64] = _365 + _112 + _114 + _209 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _498
                        t = _106
                        continue 
                    mem[_112 + _114 + _209 + _365 + 32] = 0
                    _504 = mem[64]
                    mem[mem[64]] = _365 + _112 + _114 + _209 - mem[64]
                    mem[64] = _365 + _112 + _114 + _209 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _504
                    t = _106
                    continue 
                mem[_112 + _114 + 32] = 0
                _213 = mem[_66]
                s = 0
                while s < _213:
                    mem[s + _112 + _114 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_213) <= _213:
                    _362 = mem[_109]
                    s = 0
                    while s < _362:
                        mem[s + _112 + _114 + _213 + 32] = mem[s + _109 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_362) <= _362:
                        _499 = mem[64]
                        mem[mem[64]] = _362 + _112 + _114 + _213 - mem[64]
                        mem[64] = _362 + _112 + _114 + _213 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _499
                        t = _106
                        continue 
                    mem[_112 + _114 + _213 + _362 + 32] = 0
                    _505 = mem[64]
                    mem[mem[64]] = _362 + _112 + _114 + _213 - mem[64]
                    mem[64] = _362 + _112 + _114 + _213 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _505
                    t = _106
                    continue 
                mem[_112 + _114 + _213 + 32] = 0
                _366 = mem[_109]
                s = 0
                while s < _366:
                    mem[s + _112 + _114 + _213 + 32] = mem[s + _109 + 32]
                    s = s + 32
                    continue 
                if ceil32(_366) <= _366:
                    _500 = mem[64]
                    mem[mem[64]] = _366 + _112 + _114 + _213 - mem[64]
                    mem[64] = _366 + _112 + _114 + _213 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _500
                    t = _106
                    continue 
                mem[_112 + _114 + _213 + _366 + 32] = 0
                _506 = mem[64]
                mem[mem[64]] = _366 + _112 + _114 + _213 - mem[64]
                mem[64] = _366 + _112 + _114 + _213 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _506
                t = _106
                continue 
            u = 0
            t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _208 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _107
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_208]:
                        revert with 0, 50
                    mem[v + _208 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _355 = mem[64]
                _359 = mem[s]
                t = 0
                while t < _359:
                    mem[t + _355 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_359) <= _359:
                    _489 = mem[_66]
                    s = 0
                    while s < _489:
                        mem[s + _355 + _359 + 32] = mem[s + _66 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_489) <= _489:
                        _695 = mem[_208]
                        s = 0
                        while s < _695:
                            mem[s + _355 + _359 + _489 + 32] = mem[s + _208 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_695) <= _695:
                            _879 = mem[64]
                            mem[mem[64]] = _695 + _355 + _359 + _489 - mem[64]
                            mem[64] = _695 + _355 + _359 + _489 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _879
                            t = _106
                            continue 
                        mem[_355 + _359 + _489 + _695 + 32] = 0
                        _895 = mem[64]
                        mem[mem[64]] = _695 + _355 + _359 + _489 - mem[64]
                        mem[64] = _695 + _355 + _359 + _489 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _895
                        t = _106
                        continue 
                    mem[_355 + _359 + _489 + 32] = 0
                    _703 = mem[_208]
                    s = 0
                    while s < _703:
                        mem[s + _355 + _359 + _489 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_703) <= _703:
                        _880 = mem[64]
                        mem[mem[64]] = _703 + _355 + _359 + _489 - mem[64]
                        mem[64] = _703 + _355 + _359 + _489 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _880
                        t = _106
                        continue 
                    mem[_355 + _359 + _489 + _703 + 32] = 0
                    _896 = mem[64]
                    mem[mem[64]] = _703 + _355 + _359 + _489 - mem[64]
                    mem[64] = _703 + _355 + _359 + _489 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _896
                    t = _106
                    continue 
                mem[_355 + _359 + 32] = 0
                _495 = mem[_66]
                s = 0
                while s < _495:
                    mem[s + _355 + _359 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_495) <= _495:
                    _696 = mem[_208]
                    s = 0
                    while s < _696:
                        mem[s + _355 + _359 + _495 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_696) <= _696:
                        _881 = mem[64]
                        mem[mem[64]] = _696 + _355 + _359 + _495 - mem[64]
                        mem[64] = _696 + _355 + _359 + _495 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _881
                        t = _106
                        continue 
                    mem[_355 + _359 + _495 + _696 + 32] = 0
                    _897 = mem[64]
                    mem[mem[64]] = _696 + _355 + _359 + _495 - mem[64]
                    mem[64] = _696 + _355 + _359 + _495 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _897
                    t = _106
                    continue 
                mem[_355 + _359 + _495 + 32] = 0
                _704 = mem[_208]
                s = 0
                while s < _704:
                    mem[s + _355 + _359 + _495 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_704) <= _704:
                    _882 = mem[64]
                    mem[mem[64]] = _704 + _355 + _359 + _495 - mem[64]
                    mem[64] = _704 + _355 + _359 + _495 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _882
                    t = _106
                    continue 
                mem[_355 + _359 + _495 + _704 + 32] = 0
                _898 = mem[64]
                mem[mem[64]] = _704 + _355 + _359 + _495 - mem[64]
                mem[64] = _704 + _355 + _359 + _495 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _898
                t = _106
                continue 
            mem[_208 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _107
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_208]:
                    revert with 0, 50
                mem[v + _208 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _356 = mem[64]
            _360 = mem[s]
            t = 0
            while t < _360:
                mem[t + _356 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_360) <= _360:
                _490 = mem[_66]
                s = 0
                while s < _490:
                    mem[s + _356 + _360 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_490) <= _490:
                    _697 = mem[_208]
                    s = 0
                    while s < _697:
                        mem[s + _356 + _360 + _490 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _883 = mem[64]
                        mem[mem[64]] = _697 + _356 + _360 + _490 - mem[64]
                        mem[64] = _697 + _356 + _360 + _490 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _106
                        continue 
                    mem[_356 + _360 + _490 + _697 + 32] = 0
                    _899 = mem[64]
                    mem[mem[64]] = _697 + _356 + _360 + _490 - mem[64]
                    mem[64] = _697 + _356 + _360 + _490 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _899
                    t = _106
                    continue 
                mem[_356 + _360 + _490 + 32] = 0
                _705 = mem[_208]
                s = 0
                while s < _705:
                    mem[s + _356 + _360 + _490 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_705) <= _705:
                    _884 = mem[64]
                    mem[mem[64]] = _705 + _356 + _360 + _490 - mem[64]
                    mem[64] = _705 + _356 + _360 + _490 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _106
                    continue 
                mem[_356 + _360 + _490 + _705 + 32] = 0
                _900 = mem[64]
                mem[mem[64]] = _705 + _356 + _360 + _490 - mem[64]
                mem[64] = _705 + _356 + _360 + _490 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _900
                t = _106
                continue 
            mem[_356 + _360 + 32] = 0
            _496 = mem[_66]
            s = 0
            while s < _496:
                mem[s + _356 + _360 + 32] = mem[s + _66 + 32]
                s = s + 32
                continue 
            if ceil32(_496) <= _496:
                _698 = mem[_208]
                s = 0
                while s < _698:
                    mem[s + _356 + _360 + _496 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_698) <= _698:
                    _885 = mem[64]
                    mem[mem[64]] = _698 + _356 + _360 + _496 - mem[64]
                    mem[64] = _698 + _356 + _360 + _496 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _885
                    t = _106
                    continue 
                mem[_356 + _360 + _496 + _698 + 32] = 0
                _901 = mem[64]
                mem[mem[64]] = _698 + _356 + _360 + _496 - mem[64]
                mem[64] = _698 + _356 + _360 + _496 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _901
                t = _106
                continue 
            mem[_356 + _360 + _496 + 32] = 0
            _706 = mem[_208]
            s = 0
            while s < _706:
                mem[s + _356 + _360 + _496 + 32] = mem[s + _208 + 32]
                s = s + 32
                continue 
            if ceil32(_706) <= _706:
                _886 = mem[64]
                mem[mem[64]] = _706 + _356 + _360 + _496 - mem[64]
                mem[64] = _706 + _356 + _360 + _496 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _886
                t = _106
                continue 
            mem[_356 + _360 + _496 + _706 + 32] = 0
            _902 = mem[64]
            mem[mem[64]] = _706 + _356 + _360 + _496 - mem[64]
            mem[64] = _706 + _356 + _360 + _496 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _902
            t = _106
            continue 
        mem[mem[64]] = 32
        _108 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_108)] = mem[s + 32 len ceil32(_108)]
        if ceil32(_108) > _108:
            mem[mem[64] + _108 + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_108) + 32]
    s = 0
    idx = mem[mem[ceil32(return_data.size) + 128] + 32]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _104 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _62
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_104]:
                revert with 0, 50
            mem[t + _104 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _206 = mem[64]
        mem[64] = mem[64] + 64
        mem[_206] = 1
        mem[_206 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _104
        t = _59
        while idx < _56:
            if idx >= mem[ceil32(return_data.size) + 96]:
                revert with 0, 50
            _350 = mem[(32 * idx) + ceil32(return_data.size) + 128]
            _351 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
            if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]:
                _363 = mem[64]
                mem[64] = mem[64] + 64
                mem[_363] = 1
                mem[_363 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _368 = mem[64]
                _375 = mem[s]
                t = 0
                while t < _375:
                    mem[t + _368 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_375) <= _375:
                    _487 = mem[_206]
                    s = 0
                    while s < _487:
                        mem[s + _368 + _375 + 32] = mem[s + _206 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_487) <= _487:
                        _689 = mem[_363]
                        s = 0
                        while s < _689:
                            mem[s + _368 + _375 + _487 + 32] = mem[s + _363 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_689) <= _689:
                            _869 = mem[64]
                            mem[mem[64]] = _689 + _368 + _375 + _487 - mem[64]
                            mem[64] = _689 + _368 + _375 + _487 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _869
                            t = _350
                            continue 
                        mem[_368 + _375 + _487 + _689 + 32] = 0
                        _887 = mem[64]
                        mem[mem[64]] = _689 + _368 + _375 + _487 - mem[64]
                        mem[64] = _689 + _368 + _375 + _487 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _887
                        t = _350
                        continue 
                    mem[_368 + _375 + _487 + 32] = 0
                    _699 = mem[_363]
                    s = 0
                    while s < _699:
                        mem[s + _368 + _375 + _487 + 32] = mem[s + _363 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_699) <= _699:
                        _870 = mem[64]
                        mem[mem[64]] = _699 + _368 + _375 + _487 - mem[64]
                        mem[64] = _699 + _368 + _375 + _487 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _870
                        t = _350
                        continue 
                    mem[_368 + _375 + _487 + _699 + 32] = 0
                    _888 = mem[64]
                    mem[mem[64]] = _699 + _368 + _375 + _487 - mem[64]
                    mem[64] = _699 + _368 + _375 + _487 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _888
                    t = _350
                    continue 
                mem[_368 + _375 + 32] = 0
                _492 = mem[_206]
                s = 0
                while s < _492:
                    mem[s + _368 + _375 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_492) <= _492:
                    _690 = mem[_363]
                    s = 0
                    while s < _690:
                        mem[s + _368 + _375 + _492 + 32] = mem[s + _363 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_690) <= _690:
                        _871 = mem[64]
                        mem[mem[64]] = _690 + _368 + _375 + _492 - mem[64]
                        mem[64] = _690 + _368 + _375 + _492 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _871
                        t = _350
                        continue 
                    mem[_368 + _375 + _492 + _690 + 32] = 0
                    _889 = mem[64]
                    mem[mem[64]] = _690 + _368 + _375 + _492 - mem[64]
                    mem[64] = _690 + _368 + _375 + _492 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _889
                    t = _350
                    continue 
                mem[_368 + _375 + _492 + 32] = 0
                _700 = mem[_363]
                s = 0
                while s < _700:
                    mem[s + _368 + _375 + _492 + 32] = mem[s + _363 + 32]
                    s = s + 32
                    continue 
                if ceil32(_700) <= _700:
                    _872 = mem[64]
                    mem[mem[64]] = _700 + _368 + _375 + _492 - mem[64]
                    mem[64] = _700 + _368 + _375 + _492 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _872
                    t = _350
                    continue 
                mem[_368 + _375 + _492 + _700 + 32] = 0
                _890 = mem[64]
                mem[mem[64]] = _700 + _368 + _375 + _492 - mem[64]
                mem[64] = _700 + _368 + _375 + _492 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _890
                t = _350
                continue 
            u = 0
            t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _485 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _351
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_485]:
                        revert with 0, 50
                    mem[v + _485 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _683 = mem[64]
                _687 = mem[s]
                t = 0
                while t < _687:
                    mem[t + _683 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_687) <= _687:
                    _863 = mem[_206]
                    s = 0
                    while s < _863:
                        mem[s + _683 + _687 + 32] = mem[s + _206 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_863) <= _863:
                        _983 = mem[_485]
                        s = 0
                        while s < _983:
                            mem[s + _683 + _687 + _863 + 32] = mem[s + _485 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_983) <= _983:
                            _1063 = mem[64]
                            mem[mem[64]] = _983 + _683 + _687 + _863 - mem[64]
                            mem[64] = _983 + _683 + _687 + _863 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1063
                            t = _350
                            continue 
                        mem[_683 + _687 + _863 + _983 + 32] = 0
                        _1079 = mem[64]
                        mem[mem[64]] = _983 + _683 + _687 + _863 - mem[64]
                        mem[64] = _983 + _683 + _687 + _863 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1079
                        t = _350
                        continue 
                    mem[_683 + _687 + _863 + 32] = 0
                    _991 = mem[_485]
                    s = 0
                    while s < _991:
                        mem[s + _683 + _687 + _863 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_991) <= _991:
                        _1064 = mem[64]
                        mem[mem[64]] = _991 + _683 + _687 + _863 - mem[64]
                        mem[64] = _991 + _683 + _687 + _863 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1064
                        t = _350
                        continue 
                    mem[_683 + _687 + _863 + _991 + 32] = 0
                    _1080 = mem[64]
                    mem[mem[64]] = _991 + _683 + _687 + _863 - mem[64]
                    mem[64] = _991 + _683 + _687 + _863 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1080
                    t = _350
                    continue 
                mem[_683 + _687 + 32] = 0
                _867 = mem[_206]
                s = 0
                while s < _867:
                    mem[s + _683 + _687 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_867) <= _867:
                    _984 = mem[_485]
                    s = 0
                    while s < _984:
                        mem[s + _683 + _687 + _867 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_984) <= _984:
                        _1065 = mem[64]
                        mem[mem[64]] = _984 + _683 + _687 + _867 - mem[64]
                        mem[64] = _984 + _683 + _687 + _867 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1065
                        t = _350
                        continue 
                    mem[_683 + _687 + _867 + _984 + 32] = 0
                    _1081 = mem[64]
                    mem[mem[64]] = _984 + _683 + _687 + _867 - mem[64]
                    mem[64] = _984 + _683 + _687 + _867 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1081
                    t = _350
                    continue 
                mem[_683 + _687 + _867 + 32] = 0
                _992 = mem[_485]
                s = 0
                while s < _992:
                    mem[s + _683 + _687 + _867 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_992) <= _992:
                    _1066 = mem[64]
                    mem[mem[64]] = _992 + _683 + _687 + _867 - mem[64]
                    mem[64] = _992 + _683 + _687 + _867 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1066
                    t = _350
                    continue 
                mem[_683 + _687 + _867 + _992 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _992 + _683 + _687 + _867 - mem[64]
                mem[64] = _992 + _683 + _687 + _867 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1082
                t = _350
                continue 
            mem[_485 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _351
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_485]:
                    revert with 0, 50
                mem[v + _485 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _684 = mem[64]
            _688 = mem[s]
            t = 0
            while t < _688:
                mem[t + _684 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_688) <= _688:
                _864 = mem[_206]
                s = 0
                while s < _864:
                    mem[s + _684 + _688 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_864) <= _864:
                    _985 = mem[_485]
                    s = 0
                    while s < _985:
                        mem[s + _684 + _688 + _864 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1067 = mem[64]
                        mem[mem[64]] = _985 + _684 + _688 + _864 - mem[64]
                        mem[64] = _985 + _684 + _688 + _864 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1067
                        t = _350
                        continue 
                    mem[_684 + _688 + _864 + _985 + 32] = 0
                    _1083 = mem[64]
                    mem[mem[64]] = _985 + _684 + _688 + _864 - mem[64]
                    mem[64] = _985 + _684 + _688 + _864 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1083
                    t = _350
                    continue 
                mem[_684 + _688 + _864 + 32] = 0
                _993 = mem[_485]
                s = 0
                while s < _993:
                    mem[s + _684 + _688 + _864 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_993) <= _993:
                    _1068 = mem[64]
                    mem[mem[64]] = _993 + _684 + _688 + _864 - mem[64]
                    mem[64] = _993 + _684 + _688 + _864 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1068
                    t = _350
                    continue 
                mem[_684 + _688 + _864 + _993 + 32] = 0
                _1084 = mem[64]
                mem[mem[64]] = _993 + _684 + _688 + _864 - mem[64]
                mem[64] = _993 + _684 + _688 + _864 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1084
                t = _350
                continue 
            mem[_684 + _688 + 32] = 0
            _868 = mem[_206]
            s = 0
            while s < _868:
                mem[s + _684 + _688 + 32] = mem[s + _206 + 32]
                s = s + 32
                continue 
            if ceil32(_868) <= _868:
                _986 = mem[_485]
                s = 0
                while s < _986:
                    mem[s + _684 + _688 + _868 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1069 = mem[64]
                    mem[mem[64]] = _986 + _684 + _688 + _868 - mem[64]
                    mem[64] = _986 + _684 + _688 + _868 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1069
                    t = _350
                    continue 
                mem[_684 + _688 + _868 + _986 + 32] = 0
                _1085 = mem[64]
                mem[mem[64]] = _986 + _684 + _688 + _868 - mem[64]
                mem[64] = _986 + _684 + _688 + _868 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1085
                t = _350
                continue 
            mem[_684 + _688 + _868 + 32] = 0
            _994 = mem[_485]
            s = 0
            while s < _994:
                mem[s + _684 + _688 + _868 + 32] = mem[s + _485 + 32]
                s = s + 32
                continue 
            if ceil32(_994) <= _994:
                _1070 = mem[64]
                mem[mem[64]] = _994 + _684 + _688 + _868 - mem[64]
                mem[64] = _994 + _684 + _688 + _868 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1070
                t = _350
                continue 
            mem[_684 + _688 + _868 + _994 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _994 + _684 + _688 + _868 - mem[64]
            mem[64] = _994 + _684 + _688 + _868 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1086
            t = _350
            continue 
        mem[mem[64]] = 32
        _357 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_357)] = mem[s + 32 len ceil32(_357)]
        if ceil32(_357) > _357:
            mem[mem[64] + _357 + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_357) + 32]
    mem[_104 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _62
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_104]:
            revert with 0, 50
        mem[t + _104 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _207 = mem[64]
    mem[64] = mem[64] + 64
    mem[_207] = 1
    mem[_207 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _104
    t = _59
    while idx < _56:
        if idx >= mem[ceil32(return_data.size) + 96]:
            revert with 0, 50
        _353 = mem[(32 * idx) + ceil32(return_data.size) + 128]
        _354 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
        if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]:
            _364 = mem[64]
            mem[64] = mem[64] + 64
            mem[_364] = 1
            mem[_364 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _370 = mem[64]
            _376 = mem[s]
            t = 0
            while t < _376:
                mem[t + _370 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_376) <= _376:
                _488 = mem[_207]
                s = 0
                while s < _488:
                    mem[s + _370 + _376 + 32] = mem[s + _207 + 32]
                    s = s + 32
                    continue 
                if ceil32(_488) <= _488:
                    _693 = mem[_364]
                    s = 0
                    while s < _693:
                        mem[s + _370 + _376 + _488 + 32] = mem[s + _364 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_693) <= _693:
                        _875 = mem[64]
                        mem[mem[64]] = _693 + _370 + _376 + _488 - mem[64]
                        mem[64] = _693 + _370 + _376 + _488 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _875
                        t = _353
                        continue 
                    mem[_370 + _376 + _488 + _693 + 32] = 0
                    _891 = mem[64]
                    mem[mem[64]] = _693 + _370 + _376 + _488 - mem[64]
                    mem[64] = _693 + _370 + _376 + _488 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _891
                    t = _353
                    continue 
                mem[_370 + _376 + _488 + 32] = 0
                _701 = mem[_364]
                s = 0
                while s < _701:
                    mem[s + _370 + _376 + _488 + 32] = mem[s + _364 + 32]
                    s = s + 32
                    continue 
                if ceil32(_701) <= _701:
                    _876 = mem[64]
                    mem[mem[64]] = _701 + _370 + _376 + _488 - mem[64]
                    mem[64] = _701 + _370 + _376 + _488 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _876
                    t = _353
                    continue 
                mem[_370 + _376 + _488 + _701 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _701 + _370 + _376 + _488 - mem[64]
                mem[64] = _701 + _370 + _376 + _488 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _892
                t = _353
                continue 
            mem[_370 + _376 + 32] = 0
            _494 = mem[_207]
            s = 0
            while s < _494:
                mem[s + _370 + _376 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_494) <= _494:
                _694 = mem[_364]
                s = 0
                while s < _694:
                    mem[s + _370 + _376 + _494 + 32] = mem[s + _364 + 32]
                    s = s + 32
                    continue 
                if ceil32(_694) <= _694:
                    _877 = mem[64]
                    mem[mem[64]] = _694 + _370 + _376 + _494 - mem[64]
                    mem[64] = _694 + _370 + _376 + _494 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    t = _353
                    continue 
                mem[_370 + _376 + _494 + _694 + 32] = 0
                _893 = mem[64]
                mem[mem[64]] = _694 + _370 + _376 + _494 - mem[64]
                mem[64] = _694 + _370 + _376 + _494 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _893
                t = _353
                continue 
            mem[_370 + _376 + _494 + 32] = 0
            _702 = mem[_364]
            s = 0
            while s < _702:
                mem[s + _370 + _376 + _494 + 32] = mem[s + _364 + 32]
                s = s + 32
                continue 
            if ceil32(_702) <= _702:
                _878 = mem[64]
                mem[mem[64]] = _702 + _370 + _376 + _494 - mem[64]
                mem[64] = _702 + _370 + _376 + _494 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                t = _353
                continue 
            mem[_370 + _376 + _494 + _702 + 32] = 0
            _894 = mem[64]
            mem[mem[64]] = _702 + _370 + _376 + _494 - mem[64]
            mem[64] = _702 + _370 + _376 + _494 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _894
            t = _353
            continue 
        u = 0
        t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 32]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _486 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _354
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_486]:
                    revert with 0, 50
                mem[v + _486 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _685 = mem[64]
            _691 = mem[s]
            t = 0
            while t < _691:
                mem[t + _685 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_691) <= _691:
                _865 = mem[_207]
                s = 0
                while s < _865:
                    mem[s + _685 + _691 + 32] = mem[s + _207 + 32]
                    s = s + 32
                    continue 
                if ceil32(_865) <= _865:
                    _987 = mem[_486]
                    s = 0
                    while s < _987:
                        mem[s + _685 + _691 + _865 + 32] = mem[s + _486 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_987) <= _987:
                        _1071 = mem[64]
                        mem[mem[64]] = _987 + _685 + _691 + _865 - mem[64]
                        mem[64] = _987 + _685 + _691 + _865 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1071
                        t = _353
                        continue 
                    mem[_685 + _691 + _865 + _987 + 32] = 0
                    _1087 = mem[64]
                    mem[mem[64]] = _987 + _685 + _691 + _865 - mem[64]
                    mem[64] = _987 + _685 + _691 + _865 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1087
                    t = _353
                    continue 
                mem[_685 + _691 + _865 + 32] = 0
                _995 = mem[_486]
                s = 0
                while s < _995:
                    mem[s + _685 + _691 + _865 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_995) <= _995:
                    _1072 = mem[64]
                    mem[mem[64]] = _995 + _685 + _691 + _865 - mem[64]
                    mem[64] = _995 + _685 + _691 + _865 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1072
                    t = _353
                    continue 
                mem[_685 + _691 + _865 + _995 + 32] = 0
                _1088 = mem[64]
                mem[mem[64]] = _995 + _685 + _691 + _865 - mem[64]
                mem[64] = _995 + _685 + _691 + _865 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1088
                t = _353
                continue 
            mem[_685 + _691 + 32] = 0
            _873 = mem[_207]
            s = 0
            while s < _873:
                mem[s + _685 + _691 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_873) <= _873:
                _988 = mem[_486]
                s = 0
                while s < _988:
                    mem[s + _685 + _691 + _873 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_988) <= _988:
                    _1073 = mem[64]
                    mem[mem[64]] = _988 + _685 + _691 + _873 - mem[64]
                    mem[64] = _988 + _685 + _691 + _873 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1073
                    t = _353
                    continue 
                mem[_685 + _691 + _873 + _988 + 32] = 0
                _1089 = mem[64]
                mem[mem[64]] = _988 + _685 + _691 + _873 - mem[64]
                mem[64] = _988 + _685 + _691 + _873 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1089
                t = _353
                continue 
            mem[_685 + _691 + _873 + 32] = 0
            _996 = mem[_486]
            s = 0
            while s < _996:
                mem[s + _685 + _691 + _873 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_996) <= _996:
                _1074 = mem[64]
                mem[mem[64]] = _996 + _685 + _691 + _873 - mem[64]
                mem[64] = _996 + _685 + _691 + _873 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1074
                t = _353
                continue 
            mem[_685 + _691 + _873 + _996 + 32] = 0
            _1090 = mem[64]
            mem[mem[64]] = _996 + _685 + _691 + _873 - mem[64]
            mem[64] = _996 + _685 + _691 + _873 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1090
            t = _353
            continue 
        mem[_486 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _354
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_486]:
                revert with 0, 50
            mem[v + _486 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _686 = mem[64]
        _692 = mem[s]
        t = 0
        while t < _692:
            mem[t + _686 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_692) <= _692:
            _866 = mem[_207]
            s = 0
            while s < _866:
                mem[s + _686 + _692 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_866) <= _866:
                _989 = mem[_486]
                s = 0
                while s < _989:
                    mem[s + _686 + _692 + _866 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1075 = mem[64]
                    mem[mem[64]] = _989 + _686 + _692 + _866 - mem[64]
                    mem[64] = _989 + _686 + _692 + _866 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    t = _353
                    continue 
                mem[_686 + _692 + _866 + _989 + 32] = 0
                _1091 = mem[64]
                mem[mem[64]] = _989 + _686 + _692 + _866 - mem[64]
                mem[64] = _989 + _686 + _692 + _866 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1091
                t = _353
                continue 
            mem[_686 + _692 + _866 + 32] = 0
            _997 = mem[_486]
            s = 0
            while s < _997:
                mem[s + _686 + _692 + _866 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_997) <= _997:
                _1076 = mem[64]
                mem[mem[64]] = _997 + _686 + _692 + _866 - mem[64]
                mem[64] = _997 + _686 + _692 + _866 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                t = _353
                continue 
            mem[_686 + _692 + _866 + _997 + 32] = 0
            _1092 = mem[64]
            mem[mem[64]] = _997 + _686 + _692 + _866 - mem[64]
            mem[64] = _997 + _686 + _692 + _866 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1092
            t = _353
            continue 
        mem[_686 + _692 + 32] = 0
        _874 = mem[_207]
        s = 0
        while s < _874:
            mem[s + _686 + _692 + 32] = mem[s + _207 + 32]
            s = s + 32
            continue 
        if ceil32(_874) <= _874:
            _990 = mem[_486]
            s = 0
            while s < _990:
                mem[s + _686 + _692 + _874 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_990) <= _990:
                _1077 = mem[64]
                mem[mem[64]] = _990 + _686 + _692 + _874 - mem[64]
                mem[64] = _990 + _686 + _692 + _874 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1077
                t = _353
                continue 
            mem[_686 + _692 + _874 + _990 + 32] = 0
            _1093 = mem[64]
            mem[mem[64]] = _990 + _686 + _692 + _874 - mem[64]
            mem[64] = _990 + _686 + _692 + _874 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1093
            t = _353
            continue 
        mem[_686 + _692 + _874 + 32] = 0
        _998 = mem[_486]
        s = 0
        while s < _998:
            mem[s + _686 + _692 + _874 + 32] = mem[s + _486 + 32]
            s = s + 32
            continue 
        if ceil32(_998) <= _998:
            _1078 = mem[64]
            mem[mem[64]] = _998 + _686 + _692 + _874 - mem[64]
            mem[64] = _998 + _686 + _692 + _874 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1078
            t = _353
            continue 
        mem[_686 + _692 + _874 + _998 + 32] = 0
        _1094 = mem[64]
        mem[mem[64]] = _998 + _686 + _692 + _874 - mem[64]
        mem[64] = _998 + _686 + _692 + _874 + 32
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = _1094
        t = _353
        continue 
    mem[mem[64]] = 32
    _358 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_358)] = mem[s + 32 len ceil32(_358)]
    if ceil32(_358) > _358:
        mem[mem[64] + _358 + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_358) + 32]
}

function _getNodesLastClaimTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[100] = 0
    mem[132] = arg1
    require ext_code.size(0x83a099deff9c89036f4c697511a504ea917d192a)
    delegate 0x83a099deff9c89036f4c697511a504ea917d192a.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    mem[96] = delegate.return_data[0]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if delegate.return_data[0] <= 0:
        revert with 0, 'LAST CLAIME TIME: NO NODE OWNER'
    mem[0] = arg1
    mem[32] = 4
    mem[64] = ceil32(return_data.size) + (32 * sub_2130fe23[address(arg1)].field_0) + 128
    mem[ceil32(return_data.size) + 96] = sub_2130fe23[address(arg1)].field_0
    s = ceil32(return_data.size) + 128
    idx = 0
    while idx < sub_2130fe23[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _58 = mem[64]
        mem[64] = mem[64] + 128
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            _63 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
            mem[_63] = sub_2130fe23[address(arg1)][idx].field_1
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if sub_2130fe23[address(arg1)][idx].field_1:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_63 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_63 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _63 + 32
                        u = sha3(mem[0])
                        while _63 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_63 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_58] = _63
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_63 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _63 + 32
            u = sha3(mem[0])
            while _63 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_58] = _63
            mem[_58 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_58 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_58 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _58
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        _65 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
        mem[_65] = sub_2130fe23[address(arg1)][idx].field_1
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            if not sub_2130fe23[address(arg1)][idx].field_1:
                mem[_58] = _65
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_65 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                mem[_58] = _65
                mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                mem[s] = _58
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
            mem[_65 + 32] = sub_2130fe23[address(arg1)][idx].field_0
            t = _65 + 32
            u = sha3(mem[0])
            while _65 + sub_2130fe23[address(arg1)][u].field_1 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_58] = _65
            mem[_58 + 32] = sub_2130fe23[address(arg1)][u].field_256
            mem[_58 + 64] = sub_2130fe23[address(arg1)][u].field_512
            mem[_58 + 96] = sub_2130fe23[address(arg1)][u].field_768
            mem[t] = _58
            t = t + 32
            u = u + 1
            continue 
        if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
            revert with 0, 34
        if sub_2130fe23[address(arg1)][idx].field_1:
            if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                mem[_65 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                mem[_65 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                t = _65 + 32
                u = sha3(mem[0])
                while _65 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_58] = _65
        mem[_58 + 32] = sub_2130fe23[address(arg1)][idx].field_256
        mem[_58 + 64] = sub_2130fe23[address(arg1)][idx].field_512
        mem[_58 + 96] = sub_2130fe23[address(arg1)][idx].field_768
        mem[s] = _58
        s = s + 32
        idx = idx + 1
        continue 
    _56 = mem[ceil32(return_data.size) + 96]
    _59 = mem[64]
    mem[64] = mem[64] + 128
    mem[_59] = 96
    mem[_59 + 32] = 0
    mem[_59 + 64] = 0
    mem[_59 + 96] = 0
    if 0 >= mem[ceil32(return_data.size) + 96]:
        revert with 0, 50
    _62 = mem[mem[ceil32(return_data.size) + 128] + 64]
    if not mem[mem[ceil32(return_data.size) + 128] + 64]:
        _64 = mem[64]
        mem[64] = mem[64] + 64
        mem[_64] = 1
        mem[_64 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _66 = mem[64]
        mem[64] = mem[64] + 64
        mem[_66] = 1
        mem[_66 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _64
        t = _59
        while idx < _56:
            if idx >= mem[ceil32(return_data.size) + 96]:
                revert with 0, 50
            _106 = mem[(32 * idx) + ceil32(return_data.size) + 128]
            _107 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
            if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]:
                _109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_109] = 1
                mem[_109 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _112 = mem[64]
                _114 = mem[s]
                t = 0
                while t < _114:
                    mem[t + _112 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_114) <= _114:
                    _209 = mem[_66]
                    s = 0
                    while s < _209:
                        mem[s + _112 + _114 + 32] = mem[s + _66 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_209) <= _209:
                        _361 = mem[_109]
                        s = 0
                        while s < _361:
                            mem[s + _112 + _114 + _209 + 32] = mem[s + _109 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_361) <= _361:
                            _497 = mem[64]
                            mem[mem[64]] = _361 + _112 + _114 + _209 - mem[64]
                            mem[64] = _361 + _112 + _114 + _209 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _497
                            t = _106
                            continue 
                        mem[_112 + _114 + _209 + _361 + 32] = 0
                        _503 = mem[64]
                        mem[mem[64]] = _361 + _112 + _114 + _209 - mem[64]
                        mem[64] = _361 + _112 + _114 + _209 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _503
                        t = _106
                        continue 
                    mem[_112 + _114 + _209 + 32] = 0
                    _365 = mem[_109]
                    s = 0
                    while s < _365:
                        mem[s + _112 + _114 + _209 + 32] = mem[s + _109 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_365) <= _365:
                        _498 = mem[64]
                        mem[mem[64]] = _365 + _112 + _114 + _209 - mem[64]
                        mem[64] = _365 + _112 + _114 + _209 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _498
                        t = _106
                        continue 
                    mem[_112 + _114 + _209 + _365 + 32] = 0
                    _504 = mem[64]
                    mem[mem[64]] = _365 + _112 + _114 + _209 - mem[64]
                    mem[64] = _365 + _112 + _114 + _209 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _504
                    t = _106
                    continue 
                mem[_112 + _114 + 32] = 0
                _213 = mem[_66]
                s = 0
                while s < _213:
                    mem[s + _112 + _114 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_213) <= _213:
                    _362 = mem[_109]
                    s = 0
                    while s < _362:
                        mem[s + _112 + _114 + _213 + 32] = mem[s + _109 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_362) <= _362:
                        _499 = mem[64]
                        mem[mem[64]] = _362 + _112 + _114 + _213 - mem[64]
                        mem[64] = _362 + _112 + _114 + _213 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _499
                        t = _106
                        continue 
                    mem[_112 + _114 + _213 + _362 + 32] = 0
                    _505 = mem[64]
                    mem[mem[64]] = _362 + _112 + _114 + _213 - mem[64]
                    mem[64] = _362 + _112 + _114 + _213 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _505
                    t = _106
                    continue 
                mem[_112 + _114 + _213 + 32] = 0
                _366 = mem[_109]
                s = 0
                while s < _366:
                    mem[s + _112 + _114 + _213 + 32] = mem[s + _109 + 32]
                    s = s + 32
                    continue 
                if ceil32(_366) <= _366:
                    _500 = mem[64]
                    mem[mem[64]] = _366 + _112 + _114 + _213 - mem[64]
                    mem[64] = _366 + _112 + _114 + _213 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _500
                    t = _106
                    continue 
                mem[_112 + _114 + _213 + _366 + 32] = 0
                _506 = mem[64]
                mem[mem[64]] = _366 + _112 + _114 + _213 - mem[64]
                mem[64] = _366 + _112 + _114 + _213 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _506
                t = _106
                continue 
            u = 0
            t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _208 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _107
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_208]:
                        revert with 0, 50
                    mem[v + _208 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _355 = mem[64]
                _359 = mem[s]
                t = 0
                while t < _359:
                    mem[t + _355 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_359) <= _359:
                    _489 = mem[_66]
                    s = 0
                    while s < _489:
                        mem[s + _355 + _359 + 32] = mem[s + _66 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_489) <= _489:
                        _695 = mem[_208]
                        s = 0
                        while s < _695:
                            mem[s + _355 + _359 + _489 + 32] = mem[s + _208 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_695) <= _695:
                            _879 = mem[64]
                            mem[mem[64]] = _695 + _355 + _359 + _489 - mem[64]
                            mem[64] = _695 + _355 + _359 + _489 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _879
                            t = _106
                            continue 
                        mem[_355 + _359 + _489 + _695 + 32] = 0
                        _895 = mem[64]
                        mem[mem[64]] = _695 + _355 + _359 + _489 - mem[64]
                        mem[64] = _695 + _355 + _359 + _489 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _895
                        t = _106
                        continue 
                    mem[_355 + _359 + _489 + 32] = 0
                    _703 = mem[_208]
                    s = 0
                    while s < _703:
                        mem[s + _355 + _359 + _489 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_703) <= _703:
                        _880 = mem[64]
                        mem[mem[64]] = _703 + _355 + _359 + _489 - mem[64]
                        mem[64] = _703 + _355 + _359 + _489 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _880
                        t = _106
                        continue 
                    mem[_355 + _359 + _489 + _703 + 32] = 0
                    _896 = mem[64]
                    mem[mem[64]] = _703 + _355 + _359 + _489 - mem[64]
                    mem[64] = _703 + _355 + _359 + _489 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _896
                    t = _106
                    continue 
                mem[_355 + _359 + 32] = 0
                _495 = mem[_66]
                s = 0
                while s < _495:
                    mem[s + _355 + _359 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_495) <= _495:
                    _696 = mem[_208]
                    s = 0
                    while s < _696:
                        mem[s + _355 + _359 + _495 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_696) <= _696:
                        _881 = mem[64]
                        mem[mem[64]] = _696 + _355 + _359 + _495 - mem[64]
                        mem[64] = _696 + _355 + _359 + _495 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _881
                        t = _106
                        continue 
                    mem[_355 + _359 + _495 + _696 + 32] = 0
                    _897 = mem[64]
                    mem[mem[64]] = _696 + _355 + _359 + _495 - mem[64]
                    mem[64] = _696 + _355 + _359 + _495 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _897
                    t = _106
                    continue 
                mem[_355 + _359 + _495 + 32] = 0
                _704 = mem[_208]
                s = 0
                while s < _704:
                    mem[s + _355 + _359 + _495 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_704) <= _704:
                    _882 = mem[64]
                    mem[mem[64]] = _704 + _355 + _359 + _495 - mem[64]
                    mem[64] = _704 + _355 + _359 + _495 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _882
                    t = _106
                    continue 
                mem[_355 + _359 + _495 + _704 + 32] = 0
                _898 = mem[64]
                mem[mem[64]] = _704 + _355 + _359 + _495 - mem[64]
                mem[64] = _704 + _355 + _359 + _495 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _898
                t = _106
                continue 
            mem[_208 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _107
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_208]:
                    revert with 0, 50
                mem[v + _208 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _356 = mem[64]
            _360 = mem[s]
            t = 0
            while t < _360:
                mem[t + _356 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_360) <= _360:
                _490 = mem[_66]
                s = 0
                while s < _490:
                    mem[s + _356 + _360 + 32] = mem[s + _66 + 32]
                    s = s + 32
                    continue 
                if ceil32(_490) <= _490:
                    _697 = mem[_208]
                    s = 0
                    while s < _697:
                        mem[s + _356 + _360 + _490 + 32] = mem[s + _208 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _883 = mem[64]
                        mem[mem[64]] = _697 + _356 + _360 + _490 - mem[64]
                        mem[64] = _697 + _356 + _360 + _490 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _106
                        continue 
                    mem[_356 + _360 + _490 + _697 + 32] = 0
                    _899 = mem[64]
                    mem[mem[64]] = _697 + _356 + _360 + _490 - mem[64]
                    mem[64] = _697 + _356 + _360 + _490 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _899
                    t = _106
                    continue 
                mem[_356 + _360 + _490 + 32] = 0
                _705 = mem[_208]
                s = 0
                while s < _705:
                    mem[s + _356 + _360 + _490 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_705) <= _705:
                    _884 = mem[64]
                    mem[mem[64]] = _705 + _356 + _360 + _490 - mem[64]
                    mem[64] = _705 + _356 + _360 + _490 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _106
                    continue 
                mem[_356 + _360 + _490 + _705 + 32] = 0
                _900 = mem[64]
                mem[mem[64]] = _705 + _356 + _360 + _490 - mem[64]
                mem[64] = _705 + _356 + _360 + _490 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _900
                t = _106
                continue 
            mem[_356 + _360 + 32] = 0
            _496 = mem[_66]
            s = 0
            while s < _496:
                mem[s + _356 + _360 + 32] = mem[s + _66 + 32]
                s = s + 32
                continue 
            if ceil32(_496) <= _496:
                _698 = mem[_208]
                s = 0
                while s < _698:
                    mem[s + _356 + _360 + _496 + 32] = mem[s + _208 + 32]
                    s = s + 32
                    continue 
                if ceil32(_698) <= _698:
                    _885 = mem[64]
                    mem[mem[64]] = _698 + _356 + _360 + _496 - mem[64]
                    mem[64] = _698 + _356 + _360 + _496 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _885
                    t = _106
                    continue 
                mem[_356 + _360 + _496 + _698 + 32] = 0
                _901 = mem[64]
                mem[mem[64]] = _698 + _356 + _360 + _496 - mem[64]
                mem[64] = _698 + _356 + _360 + _496 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _901
                t = _106
                continue 
            mem[_356 + _360 + _496 + 32] = 0
            _706 = mem[_208]
            s = 0
            while s < _706:
                mem[s + _356 + _360 + _496 + 32] = mem[s + _208 + 32]
                s = s + 32
                continue 
            if ceil32(_706) <= _706:
                _886 = mem[64]
                mem[mem[64]] = _706 + _356 + _360 + _496 - mem[64]
                mem[64] = _706 + _356 + _360 + _496 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _886
                t = _106
                continue 
            mem[_356 + _360 + _496 + _706 + 32] = 0
            _902 = mem[64]
            mem[mem[64]] = _706 + _356 + _360 + _496 - mem[64]
            mem[64] = _706 + _356 + _360 + _496 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _902
            t = _106
            continue 
        mem[mem[64]] = 32
        _108 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_108)] = mem[s + 32 len ceil32(_108)]
        if ceil32(_108) > _108:
            mem[mem[64] + _108 + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_108) + 32]
    s = 0
    idx = mem[mem[ceil32(return_data.size) + 128] + 64]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _104 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _62
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_104]:
                revert with 0, 50
            mem[t + _104 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _206 = mem[64]
        mem[64] = mem[64] + 64
        mem[_206] = 1
        mem[_206 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _104
        t = _59
        while idx < _56:
            if idx >= mem[ceil32(return_data.size) + 96]:
                revert with 0, 50
            _350 = mem[(32 * idx) + ceil32(return_data.size) + 128]
            _351 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
            if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]:
                _363 = mem[64]
                mem[64] = mem[64] + 64
                mem[_363] = 1
                mem[_363 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _368 = mem[64]
                _375 = mem[s]
                t = 0
                while t < _375:
                    mem[t + _368 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_375) <= _375:
                    _487 = mem[_206]
                    s = 0
                    while s < _487:
                        mem[s + _368 + _375 + 32] = mem[s + _206 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_487) <= _487:
                        _689 = mem[_363]
                        s = 0
                        while s < _689:
                            mem[s + _368 + _375 + _487 + 32] = mem[s + _363 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_689) <= _689:
                            _869 = mem[64]
                            mem[mem[64]] = _689 + _368 + _375 + _487 - mem[64]
                            mem[64] = _689 + _368 + _375 + _487 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _869
                            t = _350
                            continue 
                        mem[_368 + _375 + _487 + _689 + 32] = 0
                        _887 = mem[64]
                        mem[mem[64]] = _689 + _368 + _375 + _487 - mem[64]
                        mem[64] = _689 + _368 + _375 + _487 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _887
                        t = _350
                        continue 
                    mem[_368 + _375 + _487 + 32] = 0
                    _699 = mem[_363]
                    s = 0
                    while s < _699:
                        mem[s + _368 + _375 + _487 + 32] = mem[s + _363 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_699) <= _699:
                        _870 = mem[64]
                        mem[mem[64]] = _699 + _368 + _375 + _487 - mem[64]
                        mem[64] = _699 + _368 + _375 + _487 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _870
                        t = _350
                        continue 
                    mem[_368 + _375 + _487 + _699 + 32] = 0
                    _888 = mem[64]
                    mem[mem[64]] = _699 + _368 + _375 + _487 - mem[64]
                    mem[64] = _699 + _368 + _375 + _487 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _888
                    t = _350
                    continue 
                mem[_368 + _375 + 32] = 0
                _492 = mem[_206]
                s = 0
                while s < _492:
                    mem[s + _368 + _375 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_492) <= _492:
                    _690 = mem[_363]
                    s = 0
                    while s < _690:
                        mem[s + _368 + _375 + _492 + 32] = mem[s + _363 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_690) <= _690:
                        _871 = mem[64]
                        mem[mem[64]] = _690 + _368 + _375 + _492 - mem[64]
                        mem[64] = _690 + _368 + _375 + _492 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _871
                        t = _350
                        continue 
                    mem[_368 + _375 + _492 + _690 + 32] = 0
                    _889 = mem[64]
                    mem[mem[64]] = _690 + _368 + _375 + _492 - mem[64]
                    mem[64] = _690 + _368 + _375 + _492 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _889
                    t = _350
                    continue 
                mem[_368 + _375 + _492 + 32] = 0
                _700 = mem[_363]
                s = 0
                while s < _700:
                    mem[s + _368 + _375 + _492 + 32] = mem[s + _363 + 32]
                    s = s + 32
                    continue 
                if ceil32(_700) <= _700:
                    _872 = mem[64]
                    mem[mem[64]] = _700 + _368 + _375 + _492 - mem[64]
                    mem[64] = _700 + _368 + _375 + _492 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _872
                    t = _350
                    continue 
                mem[_368 + _375 + _492 + _700 + 32] = 0
                _890 = mem[64]
                mem[mem[64]] = _700 + _368 + _375 + _492 - mem[64]
                mem[64] = _700 + _368 + _375 + _492 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _890
                t = _350
                continue 
            u = 0
            t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _485 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _351
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_485]:
                        revert with 0, 50
                    mem[v + _485 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _683 = mem[64]
                _687 = mem[s]
                t = 0
                while t < _687:
                    mem[t + _683 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_687) <= _687:
                    _863 = mem[_206]
                    s = 0
                    while s < _863:
                        mem[s + _683 + _687 + 32] = mem[s + _206 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_863) <= _863:
                        _983 = mem[_485]
                        s = 0
                        while s < _983:
                            mem[s + _683 + _687 + _863 + 32] = mem[s + _485 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_983) <= _983:
                            _1063 = mem[64]
                            mem[mem[64]] = _983 + _683 + _687 + _863 - mem[64]
                            mem[64] = _983 + _683 + _687 + _863 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1063
                            t = _350
                            continue 
                        mem[_683 + _687 + _863 + _983 + 32] = 0
                        _1079 = mem[64]
                        mem[mem[64]] = _983 + _683 + _687 + _863 - mem[64]
                        mem[64] = _983 + _683 + _687 + _863 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1079
                        t = _350
                        continue 
                    mem[_683 + _687 + _863 + 32] = 0
                    _991 = mem[_485]
                    s = 0
                    while s < _991:
                        mem[s + _683 + _687 + _863 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_991) <= _991:
                        _1064 = mem[64]
                        mem[mem[64]] = _991 + _683 + _687 + _863 - mem[64]
                        mem[64] = _991 + _683 + _687 + _863 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1064
                        t = _350
                        continue 
                    mem[_683 + _687 + _863 + _991 + 32] = 0
                    _1080 = mem[64]
                    mem[mem[64]] = _991 + _683 + _687 + _863 - mem[64]
                    mem[64] = _991 + _683 + _687 + _863 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1080
                    t = _350
                    continue 
                mem[_683 + _687 + 32] = 0
                _867 = mem[_206]
                s = 0
                while s < _867:
                    mem[s + _683 + _687 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_867) <= _867:
                    _984 = mem[_485]
                    s = 0
                    while s < _984:
                        mem[s + _683 + _687 + _867 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_984) <= _984:
                        _1065 = mem[64]
                        mem[mem[64]] = _984 + _683 + _687 + _867 - mem[64]
                        mem[64] = _984 + _683 + _687 + _867 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1065
                        t = _350
                        continue 
                    mem[_683 + _687 + _867 + _984 + 32] = 0
                    _1081 = mem[64]
                    mem[mem[64]] = _984 + _683 + _687 + _867 - mem[64]
                    mem[64] = _984 + _683 + _687 + _867 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1081
                    t = _350
                    continue 
                mem[_683 + _687 + _867 + 32] = 0
                _992 = mem[_485]
                s = 0
                while s < _992:
                    mem[s + _683 + _687 + _867 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_992) <= _992:
                    _1066 = mem[64]
                    mem[mem[64]] = _992 + _683 + _687 + _867 - mem[64]
                    mem[64] = _992 + _683 + _687 + _867 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1066
                    t = _350
                    continue 
                mem[_683 + _687 + _867 + _992 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _992 + _683 + _687 + _867 - mem[64]
                mem[64] = _992 + _683 + _687 + _867 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1082
                t = _350
                continue 
            mem[_485 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _351
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_485]:
                    revert with 0, 50
                mem[v + _485 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _684 = mem[64]
            _688 = mem[s]
            t = 0
            while t < _688:
                mem[t + _684 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_688) <= _688:
                _864 = mem[_206]
                s = 0
                while s < _864:
                    mem[s + _684 + _688 + 32] = mem[s + _206 + 32]
                    s = s + 32
                    continue 
                if ceil32(_864) <= _864:
                    _985 = mem[_485]
                    s = 0
                    while s < _985:
                        mem[s + _684 + _688 + _864 + 32] = mem[s + _485 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1067 = mem[64]
                        mem[mem[64]] = _985 + _684 + _688 + _864 - mem[64]
                        mem[64] = _985 + _684 + _688 + _864 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1067
                        t = _350
                        continue 
                    mem[_684 + _688 + _864 + _985 + 32] = 0
                    _1083 = mem[64]
                    mem[mem[64]] = _985 + _684 + _688 + _864 - mem[64]
                    mem[64] = _985 + _684 + _688 + _864 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1083
                    t = _350
                    continue 
                mem[_684 + _688 + _864 + 32] = 0
                _993 = mem[_485]
                s = 0
                while s < _993:
                    mem[s + _684 + _688 + _864 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_993) <= _993:
                    _1068 = mem[64]
                    mem[mem[64]] = _993 + _684 + _688 + _864 - mem[64]
                    mem[64] = _993 + _684 + _688 + _864 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1068
                    t = _350
                    continue 
                mem[_684 + _688 + _864 + _993 + 32] = 0
                _1084 = mem[64]
                mem[mem[64]] = _993 + _684 + _688 + _864 - mem[64]
                mem[64] = _993 + _684 + _688 + _864 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1084
                t = _350
                continue 
            mem[_684 + _688 + 32] = 0
            _868 = mem[_206]
            s = 0
            while s < _868:
                mem[s + _684 + _688 + 32] = mem[s + _206 + 32]
                s = s + 32
                continue 
            if ceil32(_868) <= _868:
                _986 = mem[_485]
                s = 0
                while s < _986:
                    mem[s + _684 + _688 + _868 + 32] = mem[s + _485 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1069 = mem[64]
                    mem[mem[64]] = _986 + _684 + _688 + _868 - mem[64]
                    mem[64] = _986 + _684 + _688 + _868 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1069
                    t = _350
                    continue 
                mem[_684 + _688 + _868 + _986 + 32] = 0
                _1085 = mem[64]
                mem[mem[64]] = _986 + _684 + _688 + _868 - mem[64]
                mem[64] = _986 + _684 + _688 + _868 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1085
                t = _350
                continue 
            mem[_684 + _688 + _868 + 32] = 0
            _994 = mem[_485]
            s = 0
            while s < _994:
                mem[s + _684 + _688 + _868 + 32] = mem[s + _485 + 32]
                s = s + 32
                continue 
            if ceil32(_994) <= _994:
                _1070 = mem[64]
                mem[mem[64]] = _994 + _684 + _688 + _868 - mem[64]
                mem[64] = _994 + _684 + _688 + _868 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1070
                t = _350
                continue 
            mem[_684 + _688 + _868 + _994 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _994 + _684 + _688 + _868 - mem[64]
            mem[64] = _994 + _684 + _688 + _868 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1086
            t = _350
            continue 
        mem[mem[64]] = 32
        _357 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_357)] = mem[s + 32 len ceil32(_357)]
        if ceil32(_357) > _357:
            mem[mem[64] + _357 + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_357) + 32]
    mem[_104 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _62
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_104]:
            revert with 0, 50
        mem[t + _104 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _207 = mem[64]
    mem[64] = mem[64] + 64
    mem[_207] = 1
    mem[_207 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _104
    t = _59
    while idx < _56:
        if idx >= mem[ceil32(return_data.size) + 96]:
            revert with 0, 50
        _353 = mem[(32 * idx) + ceil32(return_data.size) + 128]
        _354 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
        if not mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]:
            _364 = mem[64]
            mem[64] = mem[64] + 64
            mem[_364] = 1
            mem[_364 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _370 = mem[64]
            _376 = mem[s]
            t = 0
            while t < _376:
                mem[t + _370 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_376) <= _376:
                _488 = mem[_207]
                s = 0
                while s < _488:
                    mem[s + _370 + _376 + 32] = mem[s + _207 + 32]
                    s = s + 32
                    continue 
                if ceil32(_488) <= _488:
                    _693 = mem[_364]
                    s = 0
                    while s < _693:
                        mem[s + _370 + _376 + _488 + 32] = mem[s + _364 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_693) <= _693:
                        _875 = mem[64]
                        mem[mem[64]] = _693 + _370 + _376 + _488 - mem[64]
                        mem[64] = _693 + _370 + _376 + _488 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _875
                        t = _353
                        continue 
                    mem[_370 + _376 + _488 + _693 + 32] = 0
                    _891 = mem[64]
                    mem[mem[64]] = _693 + _370 + _376 + _488 - mem[64]
                    mem[64] = _693 + _370 + _376 + _488 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _891
                    t = _353
                    continue 
                mem[_370 + _376 + _488 + 32] = 0
                _701 = mem[_364]
                s = 0
                while s < _701:
                    mem[s + _370 + _376 + _488 + 32] = mem[s + _364 + 32]
                    s = s + 32
                    continue 
                if ceil32(_701) <= _701:
                    _876 = mem[64]
                    mem[mem[64]] = _701 + _370 + _376 + _488 - mem[64]
                    mem[64] = _701 + _370 + _376 + _488 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _876
                    t = _353
                    continue 
                mem[_370 + _376 + _488 + _701 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _701 + _370 + _376 + _488 - mem[64]
                mem[64] = _701 + _370 + _376 + _488 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _892
                t = _353
                continue 
            mem[_370 + _376 + 32] = 0
            _494 = mem[_207]
            s = 0
            while s < _494:
                mem[s + _370 + _376 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_494) <= _494:
                _694 = mem[_364]
                s = 0
                while s < _694:
                    mem[s + _370 + _376 + _494 + 32] = mem[s + _364 + 32]
                    s = s + 32
                    continue 
                if ceil32(_694) <= _694:
                    _877 = mem[64]
                    mem[mem[64]] = _694 + _370 + _376 + _494 - mem[64]
                    mem[64] = _694 + _370 + _376 + _494 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    t = _353
                    continue 
                mem[_370 + _376 + _494 + _694 + 32] = 0
                _893 = mem[64]
                mem[mem[64]] = _694 + _370 + _376 + _494 - mem[64]
                mem[64] = _694 + _370 + _376 + _494 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _893
                t = _353
                continue 
            mem[_370 + _376 + _494 + 32] = 0
            _702 = mem[_364]
            s = 0
            while s < _702:
                mem[s + _370 + _376 + _494 + 32] = mem[s + _364 + 32]
                s = s + 32
                continue 
            if ceil32(_702) <= _702:
                _878 = mem[64]
                mem[mem[64]] = _702 + _370 + _376 + _494 - mem[64]
                mem[64] = _702 + _370 + _376 + _494 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                t = _353
                continue 
            mem[_370 + _376 + _494 + _702 + 32] = 0
            _894 = mem[64]
            mem[mem[64]] = _702 + _370 + _376 + _494 - mem[64]
            mem[64] = _702 + _370 + _376 + _494 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _894
            t = _353
            continue 
        u = 0
        t = mem[mem[(32 * idx) + ceil32(return_data.size) + 128] + 64]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _486 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _354
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_486]:
                    revert with 0, 50
                mem[v + _486 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _685 = mem[64]
            _691 = mem[s]
            t = 0
            while t < _691:
                mem[t + _685 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_691) <= _691:
                _865 = mem[_207]
                s = 0
                while s < _865:
                    mem[s + _685 + _691 + 32] = mem[s + _207 + 32]
                    s = s + 32
                    continue 
                if ceil32(_865) <= _865:
                    _987 = mem[_486]
                    s = 0
                    while s < _987:
                        mem[s + _685 + _691 + _865 + 32] = mem[s + _486 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_987) <= _987:
                        _1071 = mem[64]
                        mem[mem[64]] = _987 + _685 + _691 + _865 - mem[64]
                        mem[64] = _987 + _685 + _691 + _865 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1071
                        t = _353
                        continue 
                    mem[_685 + _691 + _865 + _987 + 32] = 0
                    _1087 = mem[64]
                    mem[mem[64]] = _987 + _685 + _691 + _865 - mem[64]
                    mem[64] = _987 + _685 + _691 + _865 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1087
                    t = _353
                    continue 
                mem[_685 + _691 + _865 + 32] = 0
                _995 = mem[_486]
                s = 0
                while s < _995:
                    mem[s + _685 + _691 + _865 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_995) <= _995:
                    _1072 = mem[64]
                    mem[mem[64]] = _995 + _685 + _691 + _865 - mem[64]
                    mem[64] = _995 + _685 + _691 + _865 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1072
                    t = _353
                    continue 
                mem[_685 + _691 + _865 + _995 + 32] = 0
                _1088 = mem[64]
                mem[mem[64]] = _995 + _685 + _691 + _865 - mem[64]
                mem[64] = _995 + _685 + _691 + _865 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1088
                t = _353
                continue 
            mem[_685 + _691 + 32] = 0
            _873 = mem[_207]
            s = 0
            while s < _873:
                mem[s + _685 + _691 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_873) <= _873:
                _988 = mem[_486]
                s = 0
                while s < _988:
                    mem[s + _685 + _691 + _873 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_988) <= _988:
                    _1073 = mem[64]
                    mem[mem[64]] = _988 + _685 + _691 + _873 - mem[64]
                    mem[64] = _988 + _685 + _691 + _873 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1073
                    t = _353
                    continue 
                mem[_685 + _691 + _873 + _988 + 32] = 0
                _1089 = mem[64]
                mem[mem[64]] = _988 + _685 + _691 + _873 - mem[64]
                mem[64] = _988 + _685 + _691 + _873 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1089
                t = _353
                continue 
            mem[_685 + _691 + _873 + 32] = 0
            _996 = mem[_486]
            s = 0
            while s < _996:
                mem[s + _685 + _691 + _873 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_996) <= _996:
                _1074 = mem[64]
                mem[mem[64]] = _996 + _685 + _691 + _873 - mem[64]
                mem[64] = _996 + _685 + _691 + _873 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1074
                t = _353
                continue 
            mem[_685 + _691 + _873 + _996 + 32] = 0
            _1090 = mem[64]
            mem[mem[64]] = _996 + _685 + _691 + _873 - mem[64]
            mem[64] = _996 + _685 + _691 + _873 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1090
            t = _353
            continue 
        mem[_486 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _354
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_486]:
                revert with 0, 50
            mem[v + _486 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _686 = mem[64]
        _692 = mem[s]
        t = 0
        while t < _692:
            mem[t + _686 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_692) <= _692:
            _866 = mem[_207]
            s = 0
            while s < _866:
                mem[s + _686 + _692 + 32] = mem[s + _207 + 32]
                s = s + 32
                continue 
            if ceil32(_866) <= _866:
                _989 = mem[_486]
                s = 0
                while s < _989:
                    mem[s + _686 + _692 + _866 + 32] = mem[s + _486 + 32]
                    s = s + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1075 = mem[64]
                    mem[mem[64]] = _989 + _686 + _692 + _866 - mem[64]
                    mem[64] = _989 + _686 + _692 + _866 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    t = _353
                    continue 
                mem[_686 + _692 + _866 + _989 + 32] = 0
                _1091 = mem[64]
                mem[mem[64]] = _989 + _686 + _692 + _866 - mem[64]
                mem[64] = _989 + _686 + _692 + _866 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1091
                t = _353
                continue 
            mem[_686 + _692 + _866 + 32] = 0
            _997 = mem[_486]
            s = 0
            while s < _997:
                mem[s + _686 + _692 + _866 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_997) <= _997:
                _1076 = mem[64]
                mem[mem[64]] = _997 + _686 + _692 + _866 - mem[64]
                mem[64] = _997 + _686 + _692 + _866 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                t = _353
                continue 
            mem[_686 + _692 + _866 + _997 + 32] = 0
            _1092 = mem[64]
            mem[mem[64]] = _997 + _686 + _692 + _866 - mem[64]
            mem[64] = _997 + _686 + _692 + _866 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1092
            t = _353
            continue 
        mem[_686 + _692 + 32] = 0
        _874 = mem[_207]
        s = 0
        while s < _874:
            mem[s + _686 + _692 + 32] = mem[s + _207 + 32]
            s = s + 32
            continue 
        if ceil32(_874) <= _874:
            _990 = mem[_486]
            s = 0
            while s < _990:
                mem[s + _686 + _692 + _874 + 32] = mem[s + _486 + 32]
                s = s + 32
                continue 
            if ceil32(_990) <= _990:
                _1077 = mem[64]
                mem[mem[64]] = _990 + _686 + _692 + _874 - mem[64]
                mem[64] = _990 + _686 + _692 + _874 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1077
                t = _353
                continue 
            mem[_686 + _692 + _874 + _990 + 32] = 0
            _1093 = mem[64]
            mem[mem[64]] = _990 + _686 + _692 + _874 - mem[64]
            mem[64] = _990 + _686 + _692 + _874 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1093
            t = _353
            continue 
        mem[_686 + _692 + _874 + 32] = 0
        _998 = mem[_486]
        s = 0
        while s < _998:
            mem[s + _686 + _692 + _874 + 32] = mem[s + _486 + 32]
            s = s + 32
            continue 
        if ceil32(_998) <= _998:
            _1078 = mem[64]
            mem[mem[64]] = _998 + _686 + _692 + _874 - mem[64]
            mem[64] = _998 + _686 + _692 + _874 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1078
            t = _353
            continue 
        mem[_686 + _692 + _874 + _998 + 32] = 0
        _1094 = mem[64]
        mem[mem[64]] = _998 + _686 + _692 + _874 - mem[64]
        mem[64] = _998 + _686 + _692 + _874 + 32
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = _1094
        t = _353
        continue 
    mem[mem[64]] = 32
    _358 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_358)] = mem[s + 32 len ceil32(_358)]
    if ceil32(_358) > _358:
        mem[mem[64] + _358 + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_358) + 32]
}

function _getRewardAmountOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 4
    idx = 0
    s = 0
    while idx < sub_2130fe23[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _520 = mem[64]
        mem[64] = mem[64] + 128
        if sub_2130fe23[address(arg1)][idx].field_0:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            _522 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
            mem[_522] = sub_2130fe23[address(arg1)][idx].field_1
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if not sub_2130fe23[address(arg1)][idx].field_1:
                    mem[_520] = _522
                    mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                    mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                    mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                    if sub_2130fe23[address(arg1)][idx].field_512:
                        _530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_530] = 30
                        mem[_530 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                            _538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _538 + 68] = mem[idx + _530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _538 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_581] = 26
                        mem[_581 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _602 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _602 + 68] = mem[idx + _581 + 32]
                                idx = idx + 32
                                continue 
                            mem[_602 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _602 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                        continue 
                    _572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_572] = 30
                    mem[_572 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                        _592 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _592 + 68] = mem[idx + _572 + 32]
                            idx = idx + 32
                            continue 
                        mem[_592 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _592 + -mem[64] + 100
                    if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_684] = 26
                    mem[_684 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _712 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _712 + 68] = mem[idx + _684 + 32]
                            idx = idx + 32
                            continue 
                        mem[_712 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _712 + -mem[64] + 100
                else:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_522 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                        mem[_520] = _522
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_540] = 30
                            mem[_540 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _551 + 68] = mem[idx + _540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _551 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _606 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_606] = 26
                            mem[_606 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _636 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _636 + 68] = mem[idx + _606 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_636 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _636 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_594] = 30
                        mem[_594 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _620 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _620 + 68] = mem[idx + _594 + 32]
                                idx = idx + 32
                                continue 
                            mem[_620 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _620 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _715 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_715] = 26
                        mem[_715 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _741 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _741 + 68] = mem[idx + _715 + 32]
                                idx = idx + 32
                                continue 
                            mem[_741 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _741 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_522 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_520] = _522
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _1104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1104] = 30
                            mem[_1104 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _1136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1136 + 68] = mem[idx + _1104 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1136 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1156] = 26
                            mem[_1156 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1168 + 68] = mem[idx + _1156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1168 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1168 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _1152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1152] = 30
                        mem[_1152 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _1161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1161 + 68] = mem[idx + _1152 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1161 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1192] = 26
                        mem[_1192 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1201 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1201 + 68] = mem[idx + _1192 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1201 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1201 + -mem[64] + 100
            else:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if not sub_2130fe23[address(arg1)][idx].field_1:
                    mem[_520] = _522
                    mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                    mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                    mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                    if sub_2130fe23[address(arg1)][idx].field_512:
                        _534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_534] = 30
                        mem[_534 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                            _544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _544 + 68] = mem[idx + _534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _544 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_595] = 26
                        mem[_595 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _621 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _621 + 68] = mem[idx + _595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_621 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _621 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                        continue 
                    _583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_583] = 30
                    mem[_583 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                        _608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _608 + 68] = mem[idx + _583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_608 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _608 + -mem[64] + 100
                    if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_701] = 26
                    mem[_701 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _728 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _728 + 68] = mem[idx + _701 + 32]
                            idx = idx + 32
                            continue 
                        mem[_728 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _728 + -mem[64] + 100
                else:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_522 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                        mem[_520] = _522
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_546] = 30
                            mem[_546 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _560 + 68] = mem[idx + _546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_560 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _560 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_625] = 26
                            mem[_625 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _657 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _657 + 68] = mem[idx + _625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_657 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _657 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_610] = 30
                        mem[_610 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _642 + 68] = mem[idx + _610 + 32]
                                idx = idx + 32
                                continue 
                            mem[_642 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _642 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _731 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_731] = 26
                        mem[_731 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _762 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _762 + 68] = mem[idx + _731 + 32]
                                idx = idx + 32
                                continue 
                            mem[_762 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _762 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_522 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_520] = _522
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _1113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1113] = 30
                            mem[_1113 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _1137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1137 + 68] = mem[idx + _1113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1137 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1157] = 26
                            mem[_1157 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1171 + 68] = mem[idx + _1157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1171 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1171 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _1153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1153] = 30
                        mem[_1153 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _1163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1163 + 68] = mem[idx + _1153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1163 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1163 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1193] = 26
                        mem[_1193 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1204 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1204 + 68] = mem[idx + _1193 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1204 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1204 + -mem[64] + 100
        else:
            if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                revert with 0, 34
            _523 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
            mem[_523] = sub_2130fe23[address(arg1)][idx].field_1
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if not sub_2130fe23[address(arg1)][idx].field_1:
                    mem[_520] = _523
                    mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                    mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                    mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                    if sub_2130fe23[address(arg1)][idx].field_512:
                        _536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_536] = 30
                        mem[_536 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                            _547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _547 + 68] = mem[idx + _536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _547 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_597] = 26
                        mem[_597 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _626 + 68] = mem[idx + _597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_626 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _626 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                        continue 
                    _586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_586] = 30
                    mem[_586 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                        _612 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _612 + 68] = mem[idx + _586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_612 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _612 + -mem[64] + 100
                    if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _704 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_704] = 26
                    mem[_704 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _733 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _733 + 68] = mem[idx + _704 + 32]
                            idx = idx + 32
                            continue 
                        mem[_733 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _733 + -mem[64] + 100
                else:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_523 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                        mem[_520] = _523
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_549] = 30
                            mem[_549 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _562 + 68] = mem[idx + _549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_562 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _562 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_630] = 26
                            mem[_630 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _661 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _661 + 68] = mem[idx + _630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_661 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _661 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _614 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_614] = 30
                        mem[_614 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _646 + 68] = mem[idx + _614 + 32]
                                idx = idx + 32
                                continue 
                            mem[_646 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _646 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_736] = 26
                        mem[_736 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _766 + 68] = mem[idx + _736 + 32]
                                idx = idx + 32
                                continue 
                            mem[_766 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _766 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_523 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_520] = _523
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _1122 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1122] = 30
                            mem[_1122 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _1138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1138 + 68] = mem[idx + _1122 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1138 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1158] = 26
                            mem[_1158 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1174 + 68] = mem[idx + _1158 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1174 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1174 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _1154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1154] = 30
                        mem[_1154 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _1165 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1165 + 68] = mem[idx + _1154 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1165 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1165 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1194] = 26
                        mem[_1194 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1207 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1207 + 68] = mem[idx + _1194 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1207 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1207 + -mem[64] + 100
            else:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                if not sub_2130fe23[address(arg1)][idx].field_1:
                    mem[_520] = _523
                    mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                    mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                    mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                    if sub_2130fe23[address(arg1)][idx].field_512:
                        _541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_541] = 30
                        mem[_541 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                            _554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _554 + 68] = mem[idx + _541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _554 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_615] = 26
                        mem[_615 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _647 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _647 + 68] = mem[idx + _615 + 32]
                                idx = idx + 32
                                continue 
                            mem[_647 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _647 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                        continue 
                    _599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_599] = 30
                    mem[_599 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                        _632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _632 + 68] = mem[idx + _599 + 32]
                            idx = idx + 32
                            continue 
                        mem[_632 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _632 + -mem[64] + 100
                    if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _720 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_720] = 26
                    mem[_720 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _752 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _752 + 68] = mem[idx + _720 + 32]
                            idx = idx + 32
                            continue 
                        mem[_752 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _752 + -mem[64] + 100
                else:
                    if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_523 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                        mem[_520] = _523
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_556] = 30
                            mem[_556 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _571 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _571 + 68] = mem[idx + _556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_571 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _571 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_651] = 26
                            mem[_651 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _681 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _681 + 68] = mem[idx + _651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_681 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _681 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _634 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_634] = 30
                        mem[_634 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _667 + 68] = mem[idx + _634 + 32]
                                idx = idx + 32
                                continue 
                            mem[_667 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _667 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_755] = 26
                        mem[_755 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _786 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _786 + 68] = mem[idx + _755 + 32]
                                idx = idx + 32
                                continue 
                            mem[_786 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _786 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_523 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_520] = _523
                        mem[_520 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_520 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_520 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _1131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1131] = 30
                            mem[_1131 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _1139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1139 + 68] = mem[idx + _1131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1139 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1159] = 26
                            mem[_1159 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1177 + 68] = mem[idx + _1159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1177 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1177 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        _1155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1155] = 30
                        mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _1167 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1167 + 68] = mem[idx + _1155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1167 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1167 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1195 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1195] = 26
                        mem[_1195 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1210 + 68] = mem[idx + _1195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1210 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1210 + -mem[64] + 100
        ('stor', ('name', 'claimTime', 7))
        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
            revert with 0, 17
        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
            revert with 0, 'SafeMath: addition overflow'
        if not rewardPerNode:
            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                revert with 0, 17
            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + sub_2130fe23[address(arg1)][idx].field_768
            continue 
        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
            revert with 0, 17
        if not rewardPerNode:
            revert with 0, 18
        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
            revert with 0, 'SafeMath: multiplication overflow'
        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
            revert with 0, 17
        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
        continue 
    return s
}

function _cashoutAllNodesReward(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == tokenAddress:
        mem[0] = arg1
        mem[32] = 4
        idx = 0
        s = 0
        while idx < sub_2130fe23[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 4)
            _2672 = mem[64]
            mem[64] = mem[64] + 128
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                _2677 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
                mem[_2677] = sub_2130fe23[address(arg1)][idx].field_1
                if sub_2130fe23[address(arg1)][idx].field_0:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2672] = _2677
                        mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2693] = 30
                            mem[_2693 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2709 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2709 + 68] = mem[idx + _2693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2709 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2709 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2795 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2795] = 26
                            mem[_2795 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2837 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2837 + 68] = mem[idx + _2795 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2837 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2837 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3681] = 26
                                        mem[_3681 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3827] = 26
                                    mem[_3827 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3682 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3682] = 26
                                    mem[_3682 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3829 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3829] = 26
                                mem[_3829 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3825 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3825] = 26
                                    mem[_3825 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4073] = 26
                                mem[_4073 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3826] = 26
                                mem[_3826 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4075 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4075] = 26
                            mem[_4075 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2777] = 30
                        mem[_2777 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2816 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2816 + 68] = mem[idx + _2777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2816 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2816 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3001 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3001] = 26
                        mem[_3001 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3056 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3056 + 68] = mem[idx + _3001 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3056 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3056 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3857] = 26
                                    mem[_3857 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4119 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4119] = 26
                                mem[_4119 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3858] = 26
                                mem[_3858 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4121 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4121] = 26
                            mem[_4121 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4117] = 26
                                mem[_4117 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4465 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4465] = 26
                            mem[_4465 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4118 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4118] = 26
                            mem[_4118 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4467 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4467] = 26
                        mem[_4467 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2677 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2672] = _2677
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2711 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2711] = 30
                                mem[_2711 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2734 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2734 + 68] = mem[idx + _2711 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2734 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2734 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2841] = 26
                                mem[_2841 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2904 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2904 + 68] = mem[idx + _2841 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2904 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2904 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3730 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3730] = 26
                                            mem[_3730 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3904 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3904] = 26
                                        mem[_3904 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3731] = 26
                                        mem[_3731 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3906] = 26
                                    mem[_3906 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3902] = 26
                                        mem[_3902 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4167] = 26
                                    mem[_4167 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3903 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3903] = 26
                                    mem[_3903 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4169] = 26
                                mem[_4169 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2818] = 30
                            mem[_2818 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2870 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2870 + 68] = mem[idx + _2818 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2870 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2870 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3059 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3059] = 26
                            mem[_3059 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3113 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3113 + 68] = mem[idx + _3059 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3113 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3113 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3943] = 26
                                        mem[_3943 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4227 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4227] = 26
                                    mem[_4227 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3944] = 26
                                    mem[_3944 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4229] = 26
                                mem[_4229 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4225] = 26
                                    mem[_4225 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4555] = 26
                                mem[_4555 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4226 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4226] = 26
                                mem[_4226 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4557] = 26
                            mem[_4557 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2677 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2677 + 32
                            u = sha3(mem[0])
                            while _2677 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2672] = _2677
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5469] = 30
                                mem[_5469 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5537 + 68] = mem[idx + _5469 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5537 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5537 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5577 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5577] = 26
                                mem[_5577 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5601 + 68] = mem[idx + _5577 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5601 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5601 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5873] = 26
                                            mem[_5873 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5923] = 26
                                        mem[_5923 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5874] = 26
                                        mem[_5874 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5925] = 26
                                    mem[_5925 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5921] = 26
                                        mem[_5921 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6017] = 26
                                    mem[_6017 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5922] = 26
                                    mem[_5922 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6019 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6019] = 26
                                mem[_6019 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5569] = 30
                            mem[_5569 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5586 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5586 + 68] = mem[idx + _5569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5586 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5586 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5649] = 26
                            mem[_5649 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5666 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5666 + 68] = mem[idx + _5649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5666 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5666 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5969 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5969] = 26
                                        mem[_5969 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6051] = 26
                                    mem[_6051 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5970 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5970] = 26
                                    mem[_5970 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6053] = 26
                                mem[_6053 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6049] = 26
                                    mem[_6049 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6145] = 26
                                mem[_6145 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6050] = 26
                                mem[_6050 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6147] = 26
                            mem[_6147 + 32] = 'SafeMath: division by zero'
                else:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2672] = _2677
                        mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2701] = 30
                            mem[_2701 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2720 + 68] = mem[idx + _2701 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2720 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2819 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2819] = 26
                            mem[_2819 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2871 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2871 + 68] = mem[idx + _2819 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2871 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2871 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3708 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3708] = 26
                                        mem[_3708 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3861 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3861] = 26
                                    mem[_3861 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3709] = 26
                                    mem[_3709 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3863 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3863] = 26
                                mem[_3863 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3859] = 26
                                    mem[_3859 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4125] = 26
                                mem[_4125 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3860 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3860] = 26
                                mem[_3860 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4127] = 26
                            mem[_4127 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2797] = 30
                        mem[_2797 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2843 + 68] = mem[idx + _2797 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2843 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3033] = 26
                        mem[_3033 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3084 + 68] = mem[idx + _3033 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3084 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3084 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3908] = 26
                                    mem[_3908 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4173] = 26
                                mem[_4173 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3909 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3909] = 26
                                mem[_3909 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4175] = 26
                            mem[_4175 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4171] = 26
                                mem[_4171 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4511] = 26
                            mem[_4511 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4172 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4172] = 26
                            mem[_4172 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4513 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4513] = 26
                        mem[_4513 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2677 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2672] = _2677
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2722] = 30
                                mem[_2722 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2750 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2750 + 68] = mem[idx + _2722 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2750 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2750 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2875 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2875] = 26
                                mem[_2875 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2942 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2942 + 68] = mem[idx + _2875 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2942 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2942 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3756] = 26
                                            mem[_3756 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3950 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3950] = 26
                                        mem[_3950 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3757] = 26
                                        mem[_3757 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3952] = 26
                                    mem[_3952 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3948] = 26
                                        mem[_3948 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4233] = 26
                                    mem[_4233 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3949] = 26
                                    mem[_3949 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4235 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4235] = 26
                                mem[_4235 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2845 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2845] = 30
                            mem[_2845 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2910 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2910 + 68] = mem[idx + _2845 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2910 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2910 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3087] = 26
                            mem[_3087 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3151 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3151 + 68] = mem[idx + _3087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3151 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3151 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3995 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3995] = 26
                                        mem[_3995 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4293] = 26
                                    mem[_4293 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3996] = 26
                                    mem[_3996 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4295] = 26
                                mem[_4295 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4291] = 26
                                    mem[_4291 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4605 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4605] = 26
                                mem[_4605 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4292] = 26
                                mem[_4292 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4607 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4607] = 26
                            mem[_4607 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2677 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2677 + 32
                            u = sha3(mem[0])
                            while _2677 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2672] = _2677
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5478] = 30
                                mem[_5478 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5538 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5538 + 68] = mem[idx + _5478 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5538 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5538 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5578 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5578] = 26
                                mem[_5578 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5604 + 68] = mem[idx + _5578 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5604 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5604 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5875] = 26
                                            mem[_5875 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5929 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5929] = 26
                                        mem[_5929 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5876 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5876] = 26
                                        mem[_5876 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5931] = 26
                                    mem[_5931 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5927] = 26
                                        mem[_5927 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6021] = 26
                                    mem[_6021 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5928] = 26
                                    mem[_5928 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6023] = 26
                                mem[_6023 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5570] = 30
                            mem[_5570 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5588 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5588 + 68] = mem[idx + _5570 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5588 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5588 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5650] = 26
                            mem[_5650 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5669 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5669 + 68] = mem[idx + _5650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5669 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5669 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5971 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5971] = 26
                                        mem[_5971 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6057] = 26
                                    mem[_6057 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5972] = 26
                                    mem[_5972 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6059] = 26
                                mem[_6059 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6055 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6055] = 26
                                    mem[_6055 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6149] = 26
                                mem[_6149 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6056] = 26
                                mem[_6056 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6151] = 26
                            mem[_6151 + 32] = 'SafeMath: division by zero'
            else:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                _2679 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
                mem[_2679] = sub_2130fe23[address(arg1)][idx].field_1
                if sub_2130fe23[address(arg1)][idx].field_0:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2672] = _2679
                        mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2703 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2703] = 30
                            mem[_2703 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2723 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2723 + 68] = mem[idx + _2703 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2723 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2723 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2821] = 26
                            mem[_2821 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2876 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2876 + 68] = mem[idx + _2821 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2876 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2876 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3711 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3711] = 26
                                        mem[_3711 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3870 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3870] = 26
                                    mem[_3870 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3712 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3712] = 26
                                    mem[_3712 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3872] = 26
                                mem[_3872 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3868 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3868] = 26
                                    mem[_3868 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4131] = 26
                                mem[_4131 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3869 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3869] = 26
                                mem[_3869 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4133] = 26
                            mem[_4133 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2800 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2800] = 30
                        mem[_2800 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2847 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2847 + 68] = mem[idx + _2800 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2847 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2847 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3036] = 26
                        mem[_3036 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3089 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3089 + 68] = mem[idx + _3036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3089 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3089 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3910] = 26
                                    mem[_3910 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4181] = 26
                                mem[_4181 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3911] = 26
                                mem[_3911 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4183 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4183] = 26
                            mem[_4183 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4179] = 26
                                mem[_4179 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4519] = 26
                            mem[_4519 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4180] = 26
                            mem[_4180 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4521 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4521] = 26
                        mem[_4521 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2679 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2672] = _2679
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2725] = 30
                                mem[_2725 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2752 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2752 + 68] = mem[idx + _2725 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2752 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2752 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2880 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2880] = 26
                                mem[_2880 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2946 + 68] = mem[idx + _2880 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2946 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2946 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3759 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3759] = 26
                                            mem[_3759 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3959 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3959] = 26
                                        mem[_3959 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3760 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3760] = 26
                                        mem[_3760 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3961] = 26
                                    mem[_3961 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3957] = 26
                                        mem[_3957 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4239 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4239] = 26
                                    mem[_4239 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3958] = 26
                                    mem[_3958 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4241] = 26
                                mem[_4241 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2849 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2849] = 30
                            mem[_2849 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2914 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2914 + 68] = mem[idx + _2849 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2914 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2914 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3092 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3092] = 26
                            mem[_3092 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3155 + 68] = mem[idx + _3092 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3155 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3155 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3997 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3997] = 26
                                        mem[_3997 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4303] = 26
                                    mem[_4303 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3998 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3998] = 26
                                    mem[_3998 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4305] = 26
                                mem[_4305 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4301] = 26
                                    mem[_4301 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4615] = 26
                                mem[_4615 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4302] = 26
                                mem[_4302 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4617] = 26
                            mem[_4617 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2679 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2679 + 32
                            u = sha3(mem[0])
                            while _2679 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2672] = _2679
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5487] = 30
                                mem[_5487 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5539 + 68] = mem[idx + _5487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5539 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5539 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5579] = 26
                                mem[_5579 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5607 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5607 + 68] = mem[idx + _5579 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5607 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5607 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5877 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5877] = 26
                                            mem[_5877 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5935 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5935] = 26
                                        mem[_5935 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5878 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5878] = 26
                                        mem[_5878 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5937] = 26
                                    mem[_5937 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5933] = 26
                                        mem[_5933 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6025] = 26
                                    mem[_6025 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5934] = 26
                                    mem[_5934 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6027 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6027] = 26
                                mem[_6027 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5571] = 30
                            mem[_5571 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5590 + 68] = mem[idx + _5571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5590 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5590 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5651] = 26
                            mem[_5651 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5672 + 68] = mem[idx + _5651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5672 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5672 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5973 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5973] = 26
                                        mem[_5973 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6063 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6063] = 26
                                    mem[_6063 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5974] = 26
                                    mem[_5974 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6065 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6065] = 26
                                mem[_6065 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6061 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6061] = 26
                                    mem[_6061 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6153] = 26
                                mem[_6153 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6062] = 26
                                mem[_6062 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6155] = 26
                            mem[_6155 + 32] = 'SafeMath: division by zero'
                else:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2672] = _2679
                        mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2712 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2712] = 30
                            mem[_2712 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2737 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2737 + 68] = mem[idx + _2712 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2737 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2737 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2850 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2850] = 26
                            mem[_2850 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2915 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2915 + 68] = mem[idx + _2850 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2915 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2915 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3738 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3738] = 26
                                        mem[_3738 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3914] = 26
                                    mem[_3914 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3739] = 26
                                    mem[_3739 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3916] = 26
                                mem[_3916 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3912] = 26
                                    mem[_3912 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4187 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4187] = 26
                                mem[_4187 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3913 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3913] = 26
                                mem[_3913 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4189] = 26
                            mem[_4189 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2823] = 30
                        mem[_2823 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2882 + 68] = mem[idx + _2823 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2882 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2882 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3064 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3064] = 26
                        mem[_3064 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3124 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3124 + 68] = mem[idx + _3064 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3124 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3124 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3963] = 26
                                    mem[_3963 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4245 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4245] = 26
                                mem[_4245 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3964 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3964] = 26
                                mem[_3964 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4247] = 26
                            mem[_4247 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4243] = 26
                                mem[_4243 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4563] = 26
                            mem[_4563 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4244] = 26
                            mem[_4244 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4565 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4565] = 26
                        mem[_4565 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2679 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2672] = _2679
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2739 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2739] = 30
                                mem[_2739 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2768 + 68] = mem[idx + _2739 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2768 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2768 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2919] = 26
                                mem[_2919 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2982 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2982 + 68] = mem[idx + _2919 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2982 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2982 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3785 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3785] = 26
                                            mem[_3785 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4004] = 26
                                        mem[_4004 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3786] = 26
                                        mem[_3786 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4006] = 26
                                    mem[_4006 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4002] = 26
                                        mem[_4002 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4309] = 26
                                    mem[_4309 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4003] = 26
                                    mem[_4003 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4311] = 26
                                mem[_4311 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2884 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2884] = 30
                            mem[_2884 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2952 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2952 + 68] = mem[idx + _2884 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2952 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2952 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3127] = 26
                            mem[_3127 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3191 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3191 + 68] = mem[idx + _3127 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3191 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3191 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4049] = 26
                                        mem[_4049 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4373] = 26
                                    mem[_4373 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4050] = 26
                                    mem[_4050 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4375 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4375] = 26
                                mem[_4375 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4371] = 26
                                    mem[_4371 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4677] = 26
                                mem[_4677 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4372] = 26
                                mem[_4372 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4679 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4679] = 26
                            mem[_4679 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2679 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2679 + 32
                            u = sha3(mem[0])
                            while _2679 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2672] = _2679
                            mem[_2672 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2672 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2672 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5496] = 30
                                mem[_5496 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5540 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5540 + 68] = mem[idx + _5496 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5540 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5540 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5580] = 26
                                mem[_5580 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5610 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5610 + 68] = mem[idx + _5580 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5610 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5610 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5879] = 26
                                            mem[_5879 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5941] = 26
                                        mem[_5941 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5880 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5880] = 26
                                        mem[_5880 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5943 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5943] = 26
                                    mem[_5943 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5939] = 26
                                        mem[_5939 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6029] = 26
                                    mem[_6029 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5940 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5940] = 26
                                    mem[_5940 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6031] = 26
                                mem[_6031 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5572 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5572] = 30
                            mem[_5572 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5592 + 68] = mem[idx + _5572 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5592 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5592 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5652] = 26
                            mem[_5652 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5675 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5675 + 68] = mem[idx + _5652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5675 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5675 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5975] = 26
                                        mem[_5975 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6069] = 26
                                    mem[_6069 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5976] = 26
                                    mem[_5976 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6071] = 26
                                mem[_6071 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6067] = 26
                                    mem[_6067 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6157] = 26
                                mem[_6157 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6068 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6068] = 26
                                mem[_6068 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6159] = 26
                            mem[_6159 + 32] = 'SafeMath: division by zero'
            if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                revert with 0, 17
            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                revert with 0, 17
            if idx >= sub_2130fe23[address(arg1)].field_0:
                revert with 0, 50
            sub_2130fe23[address(arg1)][idx].field_768 = 0
            mem[0] = sha3(address(arg1), 4)
            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
            continue 
    else:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'Fuck off'
        mem[0] = arg1
        mem[32] = 4
        idx = 0
        s = 0
        while idx < sub_2130fe23[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 4)
            _2674 = mem[64]
            mem[64] = mem[64] + 128
            if sub_2130fe23[address(arg1)][idx].field_0:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                _2678 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
                mem[_2678] = sub_2130fe23[address(arg1)][idx].field_1
                if sub_2130fe23[address(arg1)][idx].field_0:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2674] = _2678
                        mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2697] = 30
                            mem[_2697 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2714 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2714 + 68] = mem[idx + _2697 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2714 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2714 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2805] = 26
                            mem[_2805 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2852 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2852 + 68] = mem[idx + _2805 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2852 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2852 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3693] = 26
                                        mem[_3693 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3843 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3843] = 26
                                    mem[_3843 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3694] = 26
                                    mem[_3694 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3845 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3845] = 26
                                mem[_3845 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3841 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3841] = 26
                                    mem[_3841 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4095] = 26
                                mem[_4095 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3842] = 26
                                mem[_3842 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4097 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4097] = 26
                            mem[_4097 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2786 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2786] = 30
                        mem[_2786 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2827 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2827 + 68] = mem[idx + _2786 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2827 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2827 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3016 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3016] = 26
                        mem[_3016 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3068 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3068 + 68] = mem[idx + _3016 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3068 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3068 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3878 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3878] = 26
                                    mem[_3878 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4143] = 26
                                mem[_4143 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3879 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3879] = 26
                                mem[_3879 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4145 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4145] = 26
                            mem[_4145 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4141] = 26
                                mem[_4141 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4487] = 26
                            mem[_4487 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4142] = 26
                            mem[_4142 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4489] = 26
                        mem[_4489 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2678 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2674] = _2678
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2716] = 30
                                mem[_2716 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2741 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2741 + 68] = mem[idx + _2716 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2741 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2741 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2856 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2856] = 26
                                mem[_2856 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2921 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2921 + 68] = mem[idx + _2856 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2921 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2921 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3742 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3742] = 26
                                            mem[_3742 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3926 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3926] = 26
                                        mem[_3926 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3743 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3743] = 26
                                        mem[_3743 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3928] = 26
                                    mem[_3928 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3924] = 26
                                        mem[_3924 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4195 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4195] = 26
                                    mem[_4195 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3925] = 26
                                    mem[_3925 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4197 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4197] = 26
                                mem[_4197 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2829] = 30
                            mem[_2829 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2888 + 68] = mem[idx + _2829 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2888 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2888 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3071 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3071] = 26
                            mem[_3071 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3130 + 68] = mem[idx + _3071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3130 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3130 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3965] = 26
                                        mem[_3965 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4257] = 26
                                    mem[_4257 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3966] = 26
                                    mem[_3966 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4259] = 26
                                mem[_4259 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4255] = 26
                                    mem[_4255 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4577 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4577] = 26
                                mem[_4577 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4256 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4256] = 26
                                mem[_4256 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4579] = 26
                            mem[_4579 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2678 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2678 + 32
                            u = sha3(mem[0])
                            while _2678 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2674] = _2678
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5505 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5505] = 30
                                mem[_5505 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5541 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5541 + 68] = mem[idx + _5505 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5541 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5541 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5581] = 26
                                mem[_5581 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5613 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5613 + 68] = mem[idx + _5581 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5613 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5613 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5881 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5881] = 26
                                            mem[_5881 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5947] = 26
                                        mem[_5947 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5882 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5882] = 26
                                        mem[_5882 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5949] = 26
                                    mem[_5949 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5945 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5945] = 26
                                        mem[_5945 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6033] = 26
                                    mem[_6033 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5946] = 26
                                    mem[_5946 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6035 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6035] = 26
                                mem[_6035 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5573] = 30
                            mem[_5573 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5594 + 68] = mem[idx + _5573 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5594 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5653] = 26
                            mem[_5653 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5678 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5678 + 68] = mem[idx + _5653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5678 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5678 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5977 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5977] = 26
                                        mem[_5977 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6075] = 26
                                    mem[_6075 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5978 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5978] = 26
                                    mem[_5978 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6077] = 26
                                mem[_6077 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6073 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6073] = 26
                                    mem[_6073 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6161] = 26
                                mem[_6161 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6074] = 26
                                mem[_6074 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6163] = 26
                            mem[_6163 + 32] = 'SafeMath: division by zero'
                else:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2674] = _2678
                        mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2705 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2705] = 30
                            mem[_2705 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2727 + 68] = mem[idx + _2705 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2727 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2727 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2830] = 26
                            mem[_2830 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2889 + 68] = mem[idx + _2830 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2889 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2889 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3720 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3720] = 26
                                        mem[_3720 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3882] = 26
                                    mem[_3882 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3721 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3721] = 26
                                    mem[_3721 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3884 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3884] = 26
                                mem[_3884 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3880 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3880] = 26
                                    mem[_3880 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4149] = 26
                                mem[_4149 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3881 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3881] = 26
                                mem[_3881 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4151] = 26
                            mem[_4151 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2807] = 30
                        mem[_2807 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2858 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2858 + 68] = mem[idx + _2807 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2858 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2858 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3045] = 26
                        mem[_3045 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3100 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3100 + 68] = mem[idx + _3045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3100 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3100 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3930] = 26
                                    mem[_3930 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4201] = 26
                                mem[_4201 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3931 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3931] = 26
                                mem[_3931 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4203] = 26
                            mem[_4203 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4199] = 26
                                mem[_4199 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4531 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4531] = 26
                            mem[_4531 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4200] = 26
                            mem[_4200 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4533] = 26
                        mem[_4533 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2678 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2674] = _2678
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2729] = 30
                                mem[_2729 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2757 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2757 + 68] = mem[idx + _2729 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2757 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2757 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2893] = 26
                                mem[_2893 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2958 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2958 + 68] = mem[idx + _2893 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2958 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2958 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3767 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3767] = 26
                                            mem[_3767 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3972] = 26
                                        mem[_3972 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3768 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3768] = 26
                                        mem[_3768 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3974] = 26
                                    mem[_3974 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3970 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3970] = 26
                                        mem[_3970 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4263] = 26
                                    mem[_4263 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3971 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3971] = 26
                                    mem[_3971 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4265] = 26
                                mem[_4265 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2860 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2860] = 30
                            mem[_2860 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2927 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2927 + 68] = mem[idx + _2860 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2927 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2927 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3103] = 26
                            mem[_3103 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3167 + 68] = mem[idx + _3103 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3167 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3167 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4016 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4016] = 26
                                        mem[_4016 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4325] = 26
                                    mem[_4325 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4017] = 26
                                    mem[_4017 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4327] = 26
                                mem[_4327 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4323] = 26
                                    mem[_4323 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4633 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4633] = 26
                                mem[_4633 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4324] = 26
                                mem[_4324 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4635] = 26
                            mem[_4635 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2678 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2678 + 32
                            u = sha3(mem[0])
                            while _2678 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2674] = _2678
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5514] = 30
                                mem[_5514 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5542 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5542 + 68] = mem[idx + _5514 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5542 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5542 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5582] = 26
                                mem[_5582 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5616 + 68] = mem[idx + _5582 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5616 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5616 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5883 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5883] = 26
                                            mem[_5883 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5953 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5953] = 26
                                        mem[_5953 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5884 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5884] = 26
                                        mem[_5884 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5955] = 26
                                    mem[_5955 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5951] = 26
                                        mem[_5951 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6037] = 26
                                    mem[_6037 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5952] = 26
                                    mem[_5952 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6039] = 26
                                mem[_6039 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5574 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5574] = 30
                            mem[_5574 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5596 + 68] = mem[idx + _5574 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5596 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5596 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5654] = 26
                            mem[_5654 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5681 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5681 + 68] = mem[idx + _5654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5681 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5681 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5979] = 26
                                        mem[_5979 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6081] = 26
                                    mem[_6081 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5980 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5980] = 26
                                    mem[_5980 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6083 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6083] = 26
                                mem[_6083 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6079] = 26
                                    mem[_6079 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6165] = 26
                                mem[_6165 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6080] = 26
                                mem[_6080 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6167] = 26
                            mem[_6167 + 32] = 'SafeMath: division by zero'
            else:
                if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                    revert with 0, 34
                _2680 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2130fe23[address(arg1)][idx].field_1) + 32
                mem[_2680] = sub_2130fe23[address(arg1)][idx].field_1
                if sub_2130fe23[address(arg1)][idx].field_0:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2674] = _2680
                        mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2707] = 30
                            mem[_2707 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2730 + 68] = mem[idx + _2707 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2730 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2730 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2832 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2832] = 26
                            mem[_2832 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2894 + 68] = mem[idx + _2832 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2894 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2894 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3723 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3723] = 26
                                        mem[_3723 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3891 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3891] = 26
                                    mem[_3891 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3724] = 26
                                    mem[_3724 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3893] = 26
                                mem[_3893 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3889 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3889] = 26
                                    mem[_3889 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4155] = 26
                                mem[_4155 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3890] = 26
                                mem[_3890 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4157] = 26
                            mem[_4157 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2810] = 30
                        mem[_2810 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2862 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2862 + 68] = mem[idx + _2810 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2862 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2862 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3048] = 26
                        mem[_3048 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3105 + 68] = mem[idx + _3048 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3105 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3105 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3932] = 26
                                    mem[_3932 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4209] = 26
                                mem[_4209 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3933] = 26
                                mem[_3933 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4211] = 26
                            mem[_4211 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4207] = 26
                                mem[_4207 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4539] = 26
                            mem[_4539 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4208] = 26
                            mem[_4208 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4541] = 26
                        mem[_4541 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2680 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2674] = _2680
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2732] = 30
                                mem[_2732 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2759 + 68] = mem[idx + _2732 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2759 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2898] = 26
                                mem[_2898 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2962 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2962 + 68] = mem[idx + _2898 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2962 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2962 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3770 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3770] = 26
                                            mem[_3770 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3981 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3981] = 26
                                        mem[_3981 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3771] = 26
                                        mem[_3771 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3983 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3983] = 26
                                    mem[_3983 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3979] = 26
                                        mem[_3979 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4269 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4269] = 26
                                    mem[_4269 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3980 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3980] = 26
                                    mem[_3980 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4271] = 26
                                mem[_4271 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2864 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2864] = 30
                            mem[_2864 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2931 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2931 + 68] = mem[idx + _2864 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2931 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2931 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3108] = 26
                            mem[_3108 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3171 + 68] = mem[idx + _3108 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3171 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3171 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4018] = 26
                                        mem[_4018 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4335 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4335] = 26
                                    mem[_4335 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4019] = 26
                                    mem[_4019 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4337] = 26
                                mem[_4337 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4333] = 26
                                    mem[_4333 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4643] = 26
                                mem[_4643 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4334] = 26
                                mem[_4334 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4645 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4645] = 26
                            mem[_4645 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2680 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2680 + 32
                            u = sha3(mem[0])
                            while _2680 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2674] = _2680
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5523] = 30
                                mem[_5523 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5543 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5543 + 68] = mem[idx + _5523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5543 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5543 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5583] = 26
                                mem[_5583 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5619 + 68] = mem[idx + _5583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5619 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5619 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5885 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5885] = 26
                                            mem[_5885 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5959 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5959] = 26
                                        mem[_5959 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5886 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5886] = 26
                                        mem[_5886 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5961] = 26
                                    mem[_5961 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5957] = 26
                                        mem[_5957 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6041 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6041] = 26
                                    mem[_6041 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5958] = 26
                                    mem[_5958 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6043] = 26
                                mem[_6043 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5575] = 30
                            mem[_5575 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5598 + 68] = mem[idx + _5575 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5598 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5655] = 26
                            mem[_5655 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5684 + 68] = mem[idx + _5655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5684 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5684 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5981 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5981] = 26
                                        mem[_5981 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6087 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6087] = 26
                                    mem[_6087 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5982 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5982] = 26
                                    mem[_5982 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6089] = 26
                                mem[_6089 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6085] = 26
                                    mem[_6085 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6169] = 26
                                mem[_6169 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6086 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6086] = 26
                                mem[_6086 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6171 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6171] = 26
                            mem[_6171 + 32] = 'SafeMath: division by zero'
                else:
                    if sub_2130fe23[address(arg1)][idx].field_0 == sub_2130fe23[address(arg1)][idx].field_1 < 32:
                        revert with 0, 34
                    if not sub_2130fe23[address(arg1)][idx].field_1:
                        mem[_2674] = _2680
                        mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                        mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                        mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                        if sub_2130fe23[address(arg1)][idx].field_512:
                            _2717 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2717] = 30
                            mem[_2717 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                _2744 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2744 + 68] = mem[idx + _2717 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2744 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2744 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2865] = 26
                            mem[_2865 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2932 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2932 + 68] = mem[idx + _2865 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2932 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2932 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3750] = 26
                                        mem[_3750 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3936 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3936] = 26
                                    mem[_3936 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3751] = 26
                                    mem[_3751 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3938] = 26
                                mem[_3938 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3934] = 26
                                    mem[_3934 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4215 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4215] = 26
                                mem[_4215 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                _3935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3935] = 26
                                mem[_3935 + 32] = 'SafeMath: division by zero'
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4217] = 26
                            mem[_4217 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        _2834 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2834] = 30
                        mem[_2834 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                            _2900 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2900 + 68] = mem[idx + _2834 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2900 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2900 + -mem[64] + 100
                        if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3076 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3076] = 26
                        mem[_3076 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _3141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3141 + 68] = mem[idx + _3076 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3141 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3141 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _3985 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3985] = 26
                                    mem[_3985 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4275 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4275] = 26
                                mem[_4275 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                _3986 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3986] = 26
                                mem[_3986 + 32] = 'SafeMath: division by zero'
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4277] = 26
                            mem[_4277 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                revert with 0, 17
                            if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2130fe23[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4273] = 26
                                mem[_4273 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4585] = 26
                            mem[_4585 + 32] = 'SafeMath: division by zero'
                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                revert with 0, 17
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                            continue 
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            _4274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4274] = 26
                            mem[_4274 + 32] = 'SafeMath: division by zero'
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 4)
                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                            continue 
                        if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                            revert with 0, 18
                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4587 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4587] = 26
                        mem[_4587 + 32] = 'SafeMath: division by zero'
                    else:
                        if 31 >= sub_2130fe23[address(arg1)][idx].field_1:
                            mem[_2680 + 32] = 256 * sub_2130fe23[address(arg1)][idx].field_8
                            mem[_2674] = _2680
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _2746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2746] = 30
                                mem[_2746 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _2776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2776 + 68] = mem[idx + _2746 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2776 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2776 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2936 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2936] = 26
                                mem[_2936 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2998 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2998 + 68] = mem[idx + _2936 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2998 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2998 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _3797 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3797] = 26
                                            mem[_3797 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _4025 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4025] = 26
                                        mem[_4025 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _3798 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3798] = 26
                                        mem[_3798 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4027] = 26
                                    mem[_4027 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4023 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4023] = 26
                                        mem[_4023 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4341] = 26
                                    mem[_4341 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4024] = 26
                                    mem[_4024 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4343 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4343] = 26
                                mem[_4343 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _2902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2902] = 30
                            mem[_2902 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _2968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2968 + 68] = mem[idx + _2902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2968 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3144 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3144] = 26
                            mem[_3144 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _3207 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3207 + 68] = mem[idx + _3144 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3207 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3207 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _4071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_4071] = 26
                                        mem[_4071 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _4405 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4405] = 26
                                    mem[_4405 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4072] = 26
                                    mem[_4072 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4407] = 26
                                mem[_4407 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _4403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4403] = 26
                                    mem[_4403 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _4709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4709] = 26
                                mem[_4709 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _4404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4404] = 26
                                mem[_4404 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4711] = 26
                            mem[_4711 + 32] = 'SafeMath: division by zero'
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2680 + 32] = sub_2130fe23[address(arg1)][idx].field_0
                            t = _2680 + 32
                            u = sha3(mem[0])
                            while _2680 + sub_2130fe23[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2674] = _2680
                            mem[_2674 + 32] = sub_2130fe23[address(arg1)][idx].field_256
                            mem[_2674 + 64] = sub_2130fe23[address(arg1)][idx].field_512
                            mem[_2674 + 96] = sub_2130fe23[address(arg1)][idx].field_768
                            if sub_2130fe23[address(arg1)][idx].field_512:
                                _5532 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5532] = 30
                                mem[_5532 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2130fe23[address(arg1)][idx].field_512 > block.timestamp:
                                    _5544 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5544 + 68] = mem[idx + _5532 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5544 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5544 + -mem[64] + 100
                                if block.timestamp < sub_2130fe23[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5584 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5584] = 26
                                mem[_5584 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _5622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5622 + 68] = mem[idx + _5584 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5622 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5622 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 4)
                                    if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            _5887 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5887] = 26
                                            mem[_5887 + 32] = 'SafeMath: division by zero'
                                            if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                                revert with 0, 17
                                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                                revert with 0, 50
                                            sub_2130fe23[address(arg1)][idx].field_768 = 0
                                            mem[0] = sha3(address(arg1), 4)
                                            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + sub_2130fe23[address(arg1)][idx].field_768
                                            continue 
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5965] = 26
                                        mem[_5965 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                        continue 
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5888 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5888] = 26
                                        mem[_5888 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5967 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5967] = 26
                                    mem[_5967 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5963 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5963] = 26
                                        mem[_5963 + 32] = 'SafeMath: division by zero'
                                        if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6045 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6045] = 26
                                    mem[_6045 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5964 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5964] = 26
                                    mem[_5964 + 32] = 'SafeMath: division by zero'
                                    if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6047] = 26
                                mem[_6047 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2130fe23[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            _5576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5576] = 30
                            mem[_5576 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2130fe23[address(arg1)][idx].field_256 > block.timestamp:
                                _5600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5600 + 68] = mem[idx + _5576 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5600 + -mem[64] + 100
                            if block.timestamp < sub_2130fe23[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5656] = 26
                            mem[_5656 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _5687 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5687 + 68] = mem[idx + _5656 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5687 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5687 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 4)
                                if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        _5983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5983] = 26
                                        mem[_5983 + 32] = 'SafeMath: division by zero'
                                        if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 17
                                        if idx >= sub_2130fe23[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2130fe23[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 4)
                                        sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2130fe23[address(arg1)][idx].field_768
                                        continue 
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6093] = 26
                                    mem[_6093 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                    continue 
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    _5984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5984] = 26
                                    mem[_5984 + 32] = 'SafeMath: division by zero'
                                    if s + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6095] = 26
                                mem[_6095 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                                if s + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2130fe23[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if sub_2130fe23[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2130fe23[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    _6091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6091] = 26
                                    mem[_6091 + 32] = 'SafeMath: division by zero'
                                    if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 17
                                    if idx >= sub_2130fe23[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2130fe23[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                    continue 
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6173] = 26
                                mem[_6173 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_af89f87c) / 100)
                                continue 
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                _6092 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6092] = 26
                                mem[_6092 + 32] = 'SafeMath: division by zero'
                                if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 17
                                if idx >= sub_2130fe23[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2130fe23[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 4)
                                sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768
                                continue 
                            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768:
                                revert with 0, 18
                            if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 != sub_b137b854:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6175] = 26
                            mem[_6175 + 32] = 'SafeMath: division by zero'
            if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                revert with 0, 17
            if s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 < (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100:
                revert with 0, 17
            if idx >= sub_2130fe23[address(arg1)].field_0:
                revert with 0, 50
            sub_2130fe23[address(arg1)][idx].field_768 = 0
            mem[0] = sha3(address(arg1), 4)
            sub_2130fe23[address(arg1)][idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2130fe23[address(arg1)][idx].field_768 - ((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2130fe23[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2130fe23[address(arg1)][idx].field_768 * sub_b137b854) / 100)
            continue 
    return s, 0
}



}
